
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model OrgMember
 * 
 */
export type OrgMember = $Result.DefaultSelection<Prisma.$OrgMemberPayload>
/**
 * Model Invitation
 * 
 */
export type Invitation = $Result.DefaultSelection<Prisma.$InvitationPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model Check
 * 
 */
export type Check = $Result.DefaultSelection<Prisma.$CheckPayload>
/**
 * Model Ping
 * 
 */
export type Ping = $Result.DefaultSelection<Prisma.$PingPayload>
/**
 * Model CheckDailyStat
 * 
 */
export type CheckDailyStat = $Result.DefaultSelection<Prisma.$CheckDailyStatPayload>
/**
 * Model Channel
 * 
 */
export type Channel = $Result.DefaultSelection<Prisma.$ChannelPayload>
/**
 * Model CheckChannel
 * 
 */
export type CheckChannel = $Result.DefaultSelection<Prisma.$CheckChannelPayload>
/**
 * Model Alert
 * 
 */
export type Alert = $Result.DefaultSelection<Prisma.$AlertPayload>
/**
 * Model ApiKey
 * 
 */
export type ApiKey = $Result.DefaultSelection<Prisma.$ApiKeyPayload>
/**
 * Model Incident
 * 
 */
export type Incident = $Result.DefaultSelection<Prisma.$IncidentPayload>
/**
 * Model IncidentUpdate
 * 
 */
export type IncidentUpdate = $Result.DefaultSelection<Prisma.$IncidentUpdatePayload>
/**
 * Model IncidentCheck
 * 
 */
export type IncidentCheck = $Result.DefaultSelection<Prisma.$IncidentCheckPayload>
/**
 * Model Maintenance
 * 
 */
export type Maintenance = $Result.DefaultSelection<Prisma.$MaintenancePayload>
/**
 * Model MaintenanceCheck
 * 
 */
export type MaintenanceCheck = $Result.DefaultSelection<Prisma.$MaintenanceCheckPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const CheckStatus: {
  NEW: 'NEW',
  UP: 'UP',
  LATE: 'LATE',
  DOWN: 'DOWN',
  PAUSED: 'PAUSED'
};

export type CheckStatus = (typeof CheckStatus)[keyof typeof CheckStatus]


export const PingType: {
  SUCCESS: 'SUCCESS',
  START: 'START',
  FAIL: 'FAIL'
};

export type PingType = (typeof PingType)[keyof typeof PingType]


export const ScheduleType: {
  PERIOD: 'PERIOD',
  CRON: 'CRON'
};

export type ScheduleType = (typeof ScheduleType)[keyof typeof ScheduleType]


export const ChannelType: {
  EMAIL: 'EMAIL',
  SLACK_WEBHOOK: 'SLACK_WEBHOOK',
  SLACK_APP: 'SLACK_APP',
  DISCORD: 'DISCORD',
  PAGERDUTY: 'PAGERDUTY',
  OPSGENIE: 'OPSGENIE',
  WEBHOOK: 'WEBHOOK'
};

export type ChannelType = (typeof ChannelType)[keyof typeof ChannelType]


export const IncidentStatus: {
  INVESTIGATING: 'INVESTIGATING',
  IDENTIFIED: 'IDENTIFIED',
  MONITORING: 'MONITORING',
  RESOLVED: 'RESOLVED'
};

export type IncidentStatus = (typeof IncidentStatus)[keyof typeof IncidentStatus]


export const IncidentImpact: {
  NONE: 'NONE',
  MINOR: 'MINOR',
  MAJOR: 'MAJOR',
  CRITICAL: 'CRITICAL'
};

export type IncidentImpact = (typeof IncidentImpact)[keyof typeof IncidentImpact]

}

export type CheckStatus = $Enums.CheckStatus

export const CheckStatus: typeof $Enums.CheckStatus

export type PingType = $Enums.PingType

export const PingType: typeof $Enums.PingType

export type ScheduleType = $Enums.ScheduleType

export const ScheduleType: typeof $Enums.ScheduleType

export type ChannelType = $Enums.ChannelType

export const ChannelType: typeof $Enums.ChannelType

export type IncidentStatus = $Enums.IncidentStatus

export const IncidentStatus: typeof $Enums.IncidentStatus

export type IncidentImpact = $Enums.IncidentImpact

export const IncidentImpact: typeof $Enums.IncidentImpact

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs>;

  /**
   * `prisma.orgMember`: Exposes CRUD operations for the **OrgMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrgMembers
    * const orgMembers = await prisma.orgMember.findMany()
    * ```
    */
  get orgMember(): Prisma.OrgMemberDelegate<ExtArgs>;

  /**
   * `prisma.invitation`: Exposes CRUD operations for the **Invitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invitations
    * const invitations = await prisma.invitation.findMany()
    * ```
    */
  get invitation(): Prisma.InvitationDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs>;

  /**
   * `prisma.check`: Exposes CRUD operations for the **Check** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Checks
    * const checks = await prisma.check.findMany()
    * ```
    */
  get check(): Prisma.CheckDelegate<ExtArgs>;

  /**
   * `prisma.ping`: Exposes CRUD operations for the **Ping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pings
    * const pings = await prisma.ping.findMany()
    * ```
    */
  get ping(): Prisma.PingDelegate<ExtArgs>;

  /**
   * `prisma.checkDailyStat`: Exposes CRUD operations for the **CheckDailyStat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CheckDailyStats
    * const checkDailyStats = await prisma.checkDailyStat.findMany()
    * ```
    */
  get checkDailyStat(): Prisma.CheckDailyStatDelegate<ExtArgs>;

  /**
   * `prisma.channel`: Exposes CRUD operations for the **Channel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Channels
    * const channels = await prisma.channel.findMany()
    * ```
    */
  get channel(): Prisma.ChannelDelegate<ExtArgs>;

  /**
   * `prisma.checkChannel`: Exposes CRUD operations for the **CheckChannel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CheckChannels
    * const checkChannels = await prisma.checkChannel.findMany()
    * ```
    */
  get checkChannel(): Prisma.CheckChannelDelegate<ExtArgs>;

  /**
   * `prisma.alert`: Exposes CRUD operations for the **Alert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alerts
    * const alerts = await prisma.alert.findMany()
    * ```
    */
  get alert(): Prisma.AlertDelegate<ExtArgs>;

  /**
   * `prisma.apiKey`: Exposes CRUD operations for the **ApiKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiKeys
    * const apiKeys = await prisma.apiKey.findMany()
    * ```
    */
  get apiKey(): Prisma.ApiKeyDelegate<ExtArgs>;

  /**
   * `prisma.incident`: Exposes CRUD operations for the **Incident** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Incidents
    * const incidents = await prisma.incident.findMany()
    * ```
    */
  get incident(): Prisma.IncidentDelegate<ExtArgs>;

  /**
   * `prisma.incidentUpdate`: Exposes CRUD operations for the **IncidentUpdate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IncidentUpdates
    * const incidentUpdates = await prisma.incidentUpdate.findMany()
    * ```
    */
  get incidentUpdate(): Prisma.IncidentUpdateDelegate<ExtArgs>;

  /**
   * `prisma.incidentCheck`: Exposes CRUD operations for the **IncidentCheck** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IncidentChecks
    * const incidentChecks = await prisma.incidentCheck.findMany()
    * ```
    */
  get incidentCheck(): Prisma.IncidentCheckDelegate<ExtArgs>;

  /**
   * `prisma.maintenance`: Exposes CRUD operations for the **Maintenance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Maintenances
    * const maintenances = await prisma.maintenance.findMany()
    * ```
    */
  get maintenance(): Prisma.MaintenanceDelegate<ExtArgs>;

  /**
   * `prisma.maintenanceCheck`: Exposes CRUD operations for the **MaintenanceCheck** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaintenanceChecks
    * const maintenanceChecks = await prisma.maintenanceCheck.findMany()
    * ```
    */
  get maintenanceCheck(): Prisma.MaintenanceCheckDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.1.0
   * Query Engine version: 11f085a2012c0f4778414c8db2651556ee0ef959
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Organization: 'Organization',
    OrgMember: 'OrgMember',
    Invitation: 'Invitation',
    Session: 'Session',
    Account: 'Account',
    Verification: 'Verification',
    Project: 'Project',
    Check: 'Check',
    Ping: 'Ping',
    CheckDailyStat: 'CheckDailyStat',
    Channel: 'Channel',
    CheckChannel: 'CheckChannel',
    Alert: 'Alert',
    ApiKey: 'ApiKey',
    Incident: 'Incident',
    IncidentUpdate: 'IncidentUpdate',
    IncidentCheck: 'IncidentCheck',
    Maintenance: 'Maintenance',
    MaintenanceCheck: 'MaintenanceCheck'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "organization" | "orgMember" | "invitation" | "session" | "account" | "verification" | "project" | "check" | "ping" | "checkDailyStat" | "channel" | "checkChannel" | "alert" | "apiKey" | "incident" | "incidentUpdate" | "incidentCheck" | "maintenance" | "maintenanceCheck"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      OrgMember: {
        payload: Prisma.$OrgMemberPayload<ExtArgs>
        fields: Prisma.OrgMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrgMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrgMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgMemberPayload>
          }
          findFirst: {
            args: Prisma.OrgMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrgMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgMemberPayload>
          }
          findMany: {
            args: Prisma.OrgMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgMemberPayload>[]
          }
          create: {
            args: Prisma.OrgMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgMemberPayload>
          }
          createMany: {
            args: Prisma.OrgMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrgMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgMemberPayload>[]
          }
          delete: {
            args: Prisma.OrgMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgMemberPayload>
          }
          update: {
            args: Prisma.OrgMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgMemberPayload>
          }
          deleteMany: {
            args: Prisma.OrgMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrgMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrgMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgMemberPayload>
          }
          aggregate: {
            args: Prisma.OrgMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrgMember>
          }
          groupBy: {
            args: Prisma.OrgMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrgMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrgMemberCountArgs<ExtArgs>
            result: $Utils.Optional<OrgMemberCountAggregateOutputType> | number
          }
        }
      }
      Invitation: {
        payload: Prisma.$InvitationPayload<ExtArgs>
        fields: Prisma.InvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          findFirst: {
            args: Prisma.InvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          findMany: {
            args: Prisma.InvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          create: {
            args: Prisma.InvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          createMany: {
            args: Prisma.InvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          delete: {
            args: Prisma.InvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          update: {
            args: Prisma.InvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          deleteMany: {
            args: Prisma.InvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          aggregate: {
            args: Prisma.InvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvitation>
          }
          groupBy: {
            args: Prisma.InvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvitationCountArgs<ExtArgs>
            result: $Utils.Optional<InvitationCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      Check: {
        payload: Prisma.$CheckPayload<ExtArgs>
        fields: Prisma.CheckFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CheckFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CheckFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckPayload>
          }
          findFirst: {
            args: Prisma.CheckFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CheckFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckPayload>
          }
          findMany: {
            args: Prisma.CheckFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckPayload>[]
          }
          create: {
            args: Prisma.CheckCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckPayload>
          }
          createMany: {
            args: Prisma.CheckCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CheckCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckPayload>[]
          }
          delete: {
            args: Prisma.CheckDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckPayload>
          }
          update: {
            args: Prisma.CheckUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckPayload>
          }
          deleteMany: {
            args: Prisma.CheckDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CheckUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CheckUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckPayload>
          }
          aggregate: {
            args: Prisma.CheckAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCheck>
          }
          groupBy: {
            args: Prisma.CheckGroupByArgs<ExtArgs>
            result: $Utils.Optional<CheckGroupByOutputType>[]
          }
          count: {
            args: Prisma.CheckCountArgs<ExtArgs>
            result: $Utils.Optional<CheckCountAggregateOutputType> | number
          }
        }
      }
      Ping: {
        payload: Prisma.$PingPayload<ExtArgs>
        fields: Prisma.PingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PingPayload>
          }
          findFirst: {
            args: Prisma.PingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PingPayload>
          }
          findMany: {
            args: Prisma.PingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PingPayload>[]
          }
          create: {
            args: Prisma.PingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PingPayload>
          }
          createMany: {
            args: Prisma.PingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PingPayload>[]
          }
          delete: {
            args: Prisma.PingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PingPayload>
          }
          update: {
            args: Prisma.PingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PingPayload>
          }
          deleteMany: {
            args: Prisma.PingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PingPayload>
          }
          aggregate: {
            args: Prisma.PingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePing>
          }
          groupBy: {
            args: Prisma.PingGroupByArgs<ExtArgs>
            result: $Utils.Optional<PingGroupByOutputType>[]
          }
          count: {
            args: Prisma.PingCountArgs<ExtArgs>
            result: $Utils.Optional<PingCountAggregateOutputType> | number
          }
        }
      }
      CheckDailyStat: {
        payload: Prisma.$CheckDailyStatPayload<ExtArgs>
        fields: Prisma.CheckDailyStatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CheckDailyStatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckDailyStatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CheckDailyStatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckDailyStatPayload>
          }
          findFirst: {
            args: Prisma.CheckDailyStatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckDailyStatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CheckDailyStatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckDailyStatPayload>
          }
          findMany: {
            args: Prisma.CheckDailyStatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckDailyStatPayload>[]
          }
          create: {
            args: Prisma.CheckDailyStatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckDailyStatPayload>
          }
          createMany: {
            args: Prisma.CheckDailyStatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CheckDailyStatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckDailyStatPayload>[]
          }
          delete: {
            args: Prisma.CheckDailyStatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckDailyStatPayload>
          }
          update: {
            args: Prisma.CheckDailyStatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckDailyStatPayload>
          }
          deleteMany: {
            args: Prisma.CheckDailyStatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CheckDailyStatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CheckDailyStatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckDailyStatPayload>
          }
          aggregate: {
            args: Prisma.CheckDailyStatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCheckDailyStat>
          }
          groupBy: {
            args: Prisma.CheckDailyStatGroupByArgs<ExtArgs>
            result: $Utils.Optional<CheckDailyStatGroupByOutputType>[]
          }
          count: {
            args: Prisma.CheckDailyStatCountArgs<ExtArgs>
            result: $Utils.Optional<CheckDailyStatCountAggregateOutputType> | number
          }
        }
      }
      Channel: {
        payload: Prisma.$ChannelPayload<ExtArgs>
        fields: Prisma.ChannelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChannelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChannelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          findFirst: {
            args: Prisma.ChannelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChannelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          findMany: {
            args: Prisma.ChannelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>[]
          }
          create: {
            args: Prisma.ChannelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          createMany: {
            args: Prisma.ChannelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChannelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>[]
          }
          delete: {
            args: Prisma.ChannelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          update: {
            args: Prisma.ChannelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          deleteMany: {
            args: Prisma.ChannelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChannelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChannelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          aggregate: {
            args: Prisma.ChannelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChannel>
          }
          groupBy: {
            args: Prisma.ChannelGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChannelGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChannelCountArgs<ExtArgs>
            result: $Utils.Optional<ChannelCountAggregateOutputType> | number
          }
        }
      }
      CheckChannel: {
        payload: Prisma.$CheckChannelPayload<ExtArgs>
        fields: Prisma.CheckChannelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CheckChannelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckChannelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CheckChannelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckChannelPayload>
          }
          findFirst: {
            args: Prisma.CheckChannelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckChannelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CheckChannelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckChannelPayload>
          }
          findMany: {
            args: Prisma.CheckChannelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckChannelPayload>[]
          }
          create: {
            args: Prisma.CheckChannelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckChannelPayload>
          }
          createMany: {
            args: Prisma.CheckChannelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CheckChannelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckChannelPayload>[]
          }
          delete: {
            args: Prisma.CheckChannelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckChannelPayload>
          }
          update: {
            args: Prisma.CheckChannelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckChannelPayload>
          }
          deleteMany: {
            args: Prisma.CheckChannelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CheckChannelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CheckChannelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckChannelPayload>
          }
          aggregate: {
            args: Prisma.CheckChannelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCheckChannel>
          }
          groupBy: {
            args: Prisma.CheckChannelGroupByArgs<ExtArgs>
            result: $Utils.Optional<CheckChannelGroupByOutputType>[]
          }
          count: {
            args: Prisma.CheckChannelCountArgs<ExtArgs>
            result: $Utils.Optional<CheckChannelCountAggregateOutputType> | number
          }
        }
      }
      Alert: {
        payload: Prisma.$AlertPayload<ExtArgs>
        fields: Prisma.AlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findFirst: {
            args: Prisma.AlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findMany: {
            args: Prisma.AlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          create: {
            args: Prisma.AlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          createMany: {
            args: Prisma.AlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          delete: {
            args: Prisma.AlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          update: {
            args: Prisma.AlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          deleteMany: {
            args: Prisma.AlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          aggregate: {
            args: Prisma.AlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlert>
          }
          groupBy: {
            args: Prisma.AlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertCountArgs<ExtArgs>
            result: $Utils.Optional<AlertCountAggregateOutputType> | number
          }
        }
      }
      ApiKey: {
        payload: Prisma.$ApiKeyPayload<ExtArgs>
        fields: Prisma.ApiKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findFirst: {
            args: Prisma.ApiKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findMany: {
            args: Prisma.ApiKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          create: {
            args: Prisma.ApiKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          createMany: {
            args: Prisma.ApiKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiKeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          delete: {
            args: Prisma.ApiKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          update: {
            args: Prisma.ApiKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          deleteMany: {
            args: Prisma.ApiKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApiKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          aggregate: {
            args: Prisma.ApiKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiKey>
          }
          groupBy: {
            args: Prisma.ApiKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiKeyCountArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyCountAggregateOutputType> | number
          }
        }
      }
      Incident: {
        payload: Prisma.$IncidentPayload<ExtArgs>
        fields: Prisma.IncidentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncidentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncidentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          findFirst: {
            args: Prisma.IncidentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncidentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          findMany: {
            args: Prisma.IncidentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>[]
          }
          create: {
            args: Prisma.IncidentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          createMany: {
            args: Prisma.IncidentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IncidentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>[]
          }
          delete: {
            args: Prisma.IncidentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          update: {
            args: Prisma.IncidentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          deleteMany: {
            args: Prisma.IncidentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncidentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IncidentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          aggregate: {
            args: Prisma.IncidentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncident>
          }
          groupBy: {
            args: Prisma.IncidentGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncidentGroupByOutputType>[]
          }
          count: {
            args: Prisma.IncidentCountArgs<ExtArgs>
            result: $Utils.Optional<IncidentCountAggregateOutputType> | number
          }
        }
      }
      IncidentUpdate: {
        payload: Prisma.$IncidentUpdatePayload<ExtArgs>
        fields: Prisma.IncidentUpdateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncidentUpdateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentUpdatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncidentUpdateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentUpdatePayload>
          }
          findFirst: {
            args: Prisma.IncidentUpdateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentUpdatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncidentUpdateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentUpdatePayload>
          }
          findMany: {
            args: Prisma.IncidentUpdateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentUpdatePayload>[]
          }
          create: {
            args: Prisma.IncidentUpdateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentUpdatePayload>
          }
          createMany: {
            args: Prisma.IncidentUpdateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IncidentUpdateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentUpdatePayload>[]
          }
          delete: {
            args: Prisma.IncidentUpdateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentUpdatePayload>
          }
          update: {
            args: Prisma.IncidentUpdateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentUpdatePayload>
          }
          deleteMany: {
            args: Prisma.IncidentUpdateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncidentUpdateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IncidentUpdateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentUpdatePayload>
          }
          aggregate: {
            args: Prisma.IncidentUpdateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncidentUpdate>
          }
          groupBy: {
            args: Prisma.IncidentUpdateGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncidentUpdateGroupByOutputType>[]
          }
          count: {
            args: Prisma.IncidentUpdateCountArgs<ExtArgs>
            result: $Utils.Optional<IncidentUpdateCountAggregateOutputType> | number
          }
        }
      }
      IncidentCheck: {
        payload: Prisma.$IncidentCheckPayload<ExtArgs>
        fields: Prisma.IncidentCheckFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncidentCheckFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentCheckPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncidentCheckFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentCheckPayload>
          }
          findFirst: {
            args: Prisma.IncidentCheckFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentCheckPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncidentCheckFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentCheckPayload>
          }
          findMany: {
            args: Prisma.IncidentCheckFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentCheckPayload>[]
          }
          create: {
            args: Prisma.IncidentCheckCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentCheckPayload>
          }
          createMany: {
            args: Prisma.IncidentCheckCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IncidentCheckCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentCheckPayload>[]
          }
          delete: {
            args: Prisma.IncidentCheckDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentCheckPayload>
          }
          update: {
            args: Prisma.IncidentCheckUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentCheckPayload>
          }
          deleteMany: {
            args: Prisma.IncidentCheckDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncidentCheckUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IncidentCheckUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentCheckPayload>
          }
          aggregate: {
            args: Prisma.IncidentCheckAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncidentCheck>
          }
          groupBy: {
            args: Prisma.IncidentCheckGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncidentCheckGroupByOutputType>[]
          }
          count: {
            args: Prisma.IncidentCheckCountArgs<ExtArgs>
            result: $Utils.Optional<IncidentCheckCountAggregateOutputType> | number
          }
        }
      }
      Maintenance: {
        payload: Prisma.$MaintenancePayload<ExtArgs>
        fields: Prisma.MaintenanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaintenanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaintenanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          findFirst: {
            args: Prisma.MaintenanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaintenanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          findMany: {
            args: Prisma.MaintenanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>[]
          }
          create: {
            args: Prisma.MaintenanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          createMany: {
            args: Prisma.MaintenanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaintenanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>[]
          }
          delete: {
            args: Prisma.MaintenanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          update: {
            args: Prisma.MaintenanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          deleteMany: {
            args: Prisma.MaintenanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaintenanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaintenanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          aggregate: {
            args: Prisma.MaintenanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintenance>
          }
          groupBy: {
            args: Prisma.MaintenanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaintenanceCountArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceCountAggregateOutputType> | number
          }
        }
      }
      MaintenanceCheck: {
        payload: Prisma.$MaintenanceCheckPayload<ExtArgs>
        fields: Prisma.MaintenanceCheckFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaintenanceCheckFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceCheckPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaintenanceCheckFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceCheckPayload>
          }
          findFirst: {
            args: Prisma.MaintenanceCheckFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceCheckPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaintenanceCheckFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceCheckPayload>
          }
          findMany: {
            args: Prisma.MaintenanceCheckFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceCheckPayload>[]
          }
          create: {
            args: Prisma.MaintenanceCheckCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceCheckPayload>
          }
          createMany: {
            args: Prisma.MaintenanceCheckCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaintenanceCheckCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceCheckPayload>[]
          }
          delete: {
            args: Prisma.MaintenanceCheckDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceCheckPayload>
          }
          update: {
            args: Prisma.MaintenanceCheckUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceCheckPayload>
          }
          deleteMany: {
            args: Prisma.MaintenanceCheckDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaintenanceCheckUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaintenanceCheckUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceCheckPayload>
          }
          aggregate: {
            args: Prisma.MaintenanceCheckAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintenanceCheck>
          }
          groupBy: {
            args: Prisma.MaintenanceCheckGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceCheckGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaintenanceCheckCountArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceCheckCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    accounts: number
    memberships: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    memberships?: boolean | UserCountOutputTypeCountMembershipsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrgMemberWhereInput
  }


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    members: number
    projects: number
    invitations: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | OrganizationCountOutputTypeCountMembersArgs
    projects?: boolean | OrganizationCountOutputTypeCountProjectsArgs
    invitations?: boolean | OrganizationCountOutputTypeCountInvitationsArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrgMemberWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    checks: number
    channels: number
    apiKeys: number
    incidents: number
    maintenance: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checks?: boolean | ProjectCountOutputTypeCountChecksArgs
    channels?: boolean | ProjectCountOutputTypeCountChannelsArgs
    apiKeys?: boolean | ProjectCountOutputTypeCountApiKeysArgs
    incidents?: boolean | ProjectCountOutputTypeCountIncidentsArgs
    maintenance?: boolean | ProjectCountOutputTypeCountMaintenanceArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountApiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountIncidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMaintenanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceWhereInput
  }


  /**
   * Count Type CheckCountOutputType
   */

  export type CheckCountOutputType = {
    pings: number
    checkChannels: number
    alerts: number
    incidentChecks: number
    maintenanceChecks: number
    dailyStats: number
  }

  export type CheckCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pings?: boolean | CheckCountOutputTypeCountPingsArgs
    checkChannels?: boolean | CheckCountOutputTypeCountCheckChannelsArgs
    alerts?: boolean | CheckCountOutputTypeCountAlertsArgs
    incidentChecks?: boolean | CheckCountOutputTypeCountIncidentChecksArgs
    maintenanceChecks?: boolean | CheckCountOutputTypeCountMaintenanceChecksArgs
    dailyStats?: boolean | CheckCountOutputTypeCountDailyStatsArgs
  }

  // Custom InputTypes
  /**
   * CheckCountOutputType without action
   */
  export type CheckCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckCountOutputType
     */
    select?: CheckCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CheckCountOutputType without action
   */
  export type CheckCountOutputTypeCountPingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PingWhereInput
  }

  /**
   * CheckCountOutputType without action
   */
  export type CheckCountOutputTypeCountCheckChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckChannelWhereInput
  }

  /**
   * CheckCountOutputType without action
   */
  export type CheckCountOutputTypeCountAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
  }

  /**
   * CheckCountOutputType without action
   */
  export type CheckCountOutputTypeCountIncidentChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentCheckWhereInput
  }

  /**
   * CheckCountOutputType without action
   */
  export type CheckCountOutputTypeCountMaintenanceChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceCheckWhereInput
  }

  /**
   * CheckCountOutputType without action
   */
  export type CheckCountOutputTypeCountDailyStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckDailyStatWhereInput
  }


  /**
   * Count Type ChannelCountOutputType
   */

  export type ChannelCountOutputType = {
    checkChannels: number
  }

  export type ChannelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checkChannels?: boolean | ChannelCountOutputTypeCountCheckChannelsArgs
  }

  // Custom InputTypes
  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCountOutputType
     */
    select?: ChannelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeCountCheckChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckChannelWhereInput
  }


  /**
   * Count Type IncidentCountOutputType
   */

  export type IncidentCountOutputType = {
    updates: number
    checks: number
  }

  export type IncidentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    updates?: boolean | IncidentCountOutputTypeCountUpdatesArgs
    checks?: boolean | IncidentCountOutputTypeCountChecksArgs
  }

  // Custom InputTypes
  /**
   * IncidentCountOutputType without action
   */
  export type IncidentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentCountOutputType
     */
    select?: IncidentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IncidentCountOutputType without action
   */
  export type IncidentCountOutputTypeCountUpdatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentUpdateWhereInput
  }

  /**
   * IncidentCountOutputType without action
   */
  export type IncidentCountOutputTypeCountChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentCheckWhereInput
  }


  /**
   * Count Type MaintenanceCountOutputType
   */

  export type MaintenanceCountOutputType = {
    checks: number
  }

  export type MaintenanceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checks?: boolean | MaintenanceCountOutputTypeCountChecksArgs
  }

  // Custom InputTypes
  /**
   * MaintenanceCountOutputType without action
   */
  export type MaintenanceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceCountOutputType
     */
    select?: MaintenanceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaintenanceCountOutputType without action
   */
  export type MaintenanceCountOutputTypeCountChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceCheckWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    emailVerified: boolean | null
    name: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    emailVerified: boolean | null
    name: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    emailVerified: number
    name: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    name?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    name?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    name?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    emailVerified: boolean
    name: string | null
    image: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    name?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    memberships?: boolean | User$membershipsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    name?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    name?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    memberships?: boolean | User$membershipsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      memberships: Prisma.$OrgMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      emailVerified: boolean
      name: string | null
      image: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany"> | Null>
    memberships<T extends User$membershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrgMemberPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly name: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.memberships
   */
  export type User$membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgMember
     */
    select?: OrgMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMemberInclude<ExtArgs> | null
    where?: OrgMemberWhereInput
    orderBy?: OrgMemberOrderByWithRelationInput | OrgMemberOrderByWithRelationInput[]
    cursor?: OrgMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrgMemberScalarFieldEnum | OrgMemberScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    plan: string | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    trialEndsAt: Date | null
    autoCreateIncidents: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    plan: string | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    trialEndsAt: Date | null
    autoCreateIncidents: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    plan: number
    stripeCustomerId: number
    stripeSubscriptionId: number
    trialEndsAt: number
    autoCreateIncidents: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    plan?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    trialEndsAt?: true
    autoCreateIncidents?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    plan?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    trialEndsAt?: true
    autoCreateIncidents?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    plan?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    trialEndsAt?: true
    autoCreateIncidents?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    name: string
    slug: string
    plan: string
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    trialEndsAt: Date | null
    autoCreateIncidents: boolean
    createdAt: Date
    updatedAt: Date
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    plan?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    trialEndsAt?: boolean
    autoCreateIncidents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | Organization$membersArgs<ExtArgs>
    projects?: boolean | Organization$projectsArgs<ExtArgs>
    invitations?: boolean | Organization$invitationsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    plan?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    trialEndsAt?: boolean
    autoCreateIncidents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    plan?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    trialEndsAt?: boolean
    autoCreateIncidents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Organization$membersArgs<ExtArgs>
    projects?: boolean | Organization$projectsArgs<ExtArgs>
    invitations?: boolean | Organization$invitationsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      members: Prisma.$OrgMemberPayload<ExtArgs>[]
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      invitations: Prisma.$InvitationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      plan: string
      stripeCustomerId: string | null
      stripeSubscriptionId: string | null
      trialEndsAt: Date | null
      autoCreateIncidents: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Organization$membersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrgMemberPayload<ExtArgs>, T, "findMany"> | Null>
    projects<T extends Organization$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    invitations<T extends Organization$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */ 
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly slug: FieldRef<"Organization", 'String'>
    readonly plan: FieldRef<"Organization", 'String'>
    readonly stripeCustomerId: FieldRef<"Organization", 'String'>
    readonly stripeSubscriptionId: FieldRef<"Organization", 'String'>
    readonly trialEndsAt: FieldRef<"Organization", 'DateTime'>
    readonly autoCreateIncidents: FieldRef<"Organization", 'Boolean'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
    readonly updatedAt: FieldRef<"Organization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
  }

  /**
   * Organization.members
   */
  export type Organization$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgMember
     */
    select?: OrgMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMemberInclude<ExtArgs> | null
    where?: OrgMemberWhereInput
    orderBy?: OrgMemberOrderByWithRelationInput | OrgMemberOrderByWithRelationInput[]
    cursor?: OrgMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrgMemberScalarFieldEnum | OrgMemberScalarFieldEnum[]
  }

  /**
   * Organization.projects
   */
  export type Organization$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Organization.invitations
   */
  export type Organization$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    cursor?: InvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model OrgMember
   */

  export type AggregateOrgMember = {
    _count: OrgMemberCountAggregateOutputType | null
    _min: OrgMemberMinAggregateOutputType | null
    _max: OrgMemberMaxAggregateOutputType | null
  }

  export type OrgMemberMinAggregateOutputType = {
    id: string | null
    role: string | null
    userId: string | null
    orgId: string | null
    createdAt: Date | null
  }

  export type OrgMemberMaxAggregateOutputType = {
    id: string | null
    role: string | null
    userId: string | null
    orgId: string | null
    createdAt: Date | null
  }

  export type OrgMemberCountAggregateOutputType = {
    id: number
    role: number
    userId: number
    orgId: number
    createdAt: number
    _all: number
  }


  export type OrgMemberMinAggregateInputType = {
    id?: true
    role?: true
    userId?: true
    orgId?: true
    createdAt?: true
  }

  export type OrgMemberMaxAggregateInputType = {
    id?: true
    role?: true
    userId?: true
    orgId?: true
    createdAt?: true
  }

  export type OrgMemberCountAggregateInputType = {
    id?: true
    role?: true
    userId?: true
    orgId?: true
    createdAt?: true
    _all?: true
  }

  export type OrgMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrgMember to aggregate.
     */
    where?: OrgMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrgMembers to fetch.
     */
    orderBy?: OrgMemberOrderByWithRelationInput | OrgMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrgMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrgMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrgMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrgMembers
    **/
    _count?: true | OrgMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrgMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrgMemberMaxAggregateInputType
  }

  export type GetOrgMemberAggregateType<T extends OrgMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateOrgMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrgMember[P]>
      : GetScalarType<T[P], AggregateOrgMember[P]>
  }




  export type OrgMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrgMemberWhereInput
    orderBy?: OrgMemberOrderByWithAggregationInput | OrgMemberOrderByWithAggregationInput[]
    by: OrgMemberScalarFieldEnum[] | OrgMemberScalarFieldEnum
    having?: OrgMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrgMemberCountAggregateInputType | true
    _min?: OrgMemberMinAggregateInputType
    _max?: OrgMemberMaxAggregateInputType
  }

  export type OrgMemberGroupByOutputType = {
    id: string
    role: string
    userId: string
    orgId: string
    createdAt: Date
    _count: OrgMemberCountAggregateOutputType | null
    _min: OrgMemberMinAggregateOutputType | null
    _max: OrgMemberMaxAggregateOutputType | null
  }

  type GetOrgMemberGroupByPayload<T extends OrgMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrgMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrgMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrgMemberGroupByOutputType[P]>
            : GetScalarType<T[P], OrgMemberGroupByOutputType[P]>
        }
      >
    >


  export type OrgMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    userId?: boolean
    orgId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orgMember"]>

  export type OrgMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    userId?: boolean
    orgId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orgMember"]>

  export type OrgMemberSelectScalar = {
    id?: boolean
    role?: boolean
    userId?: boolean
    orgId?: boolean
    createdAt?: boolean
  }

  export type OrgMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type OrgMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $OrgMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrgMember"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      org: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      role: string
      userId: string
      orgId: string
      createdAt: Date
    }, ExtArgs["result"]["orgMember"]>
    composites: {}
  }

  type OrgMemberGetPayload<S extends boolean | null | undefined | OrgMemberDefaultArgs> = $Result.GetResult<Prisma.$OrgMemberPayload, S>

  type OrgMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrgMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrgMemberCountAggregateInputType | true
    }

  export interface OrgMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrgMember'], meta: { name: 'OrgMember' } }
    /**
     * Find zero or one OrgMember that matches the filter.
     * @param {OrgMemberFindUniqueArgs} args - Arguments to find a OrgMember
     * @example
     * // Get one OrgMember
     * const orgMember = await prisma.orgMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrgMemberFindUniqueArgs>(args: SelectSubset<T, OrgMemberFindUniqueArgs<ExtArgs>>): Prisma__OrgMemberClient<$Result.GetResult<Prisma.$OrgMemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OrgMember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrgMemberFindUniqueOrThrowArgs} args - Arguments to find a OrgMember
     * @example
     * // Get one OrgMember
     * const orgMember = await prisma.orgMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrgMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, OrgMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrgMemberClient<$Result.GetResult<Prisma.$OrgMemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OrgMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgMemberFindFirstArgs} args - Arguments to find a OrgMember
     * @example
     * // Get one OrgMember
     * const orgMember = await prisma.orgMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrgMemberFindFirstArgs>(args?: SelectSubset<T, OrgMemberFindFirstArgs<ExtArgs>>): Prisma__OrgMemberClient<$Result.GetResult<Prisma.$OrgMemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OrgMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgMemberFindFirstOrThrowArgs} args - Arguments to find a OrgMember
     * @example
     * // Get one OrgMember
     * const orgMember = await prisma.orgMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrgMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, OrgMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrgMemberClient<$Result.GetResult<Prisma.$OrgMemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OrgMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrgMembers
     * const orgMembers = await prisma.orgMember.findMany()
     * 
     * // Get first 10 OrgMembers
     * const orgMembers = await prisma.orgMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orgMemberWithIdOnly = await prisma.orgMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrgMemberFindManyArgs>(args?: SelectSubset<T, OrgMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrgMemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OrgMember.
     * @param {OrgMemberCreateArgs} args - Arguments to create a OrgMember.
     * @example
     * // Create one OrgMember
     * const OrgMember = await prisma.orgMember.create({
     *   data: {
     *     // ... data to create a OrgMember
     *   }
     * })
     * 
     */
    create<T extends OrgMemberCreateArgs>(args: SelectSubset<T, OrgMemberCreateArgs<ExtArgs>>): Prisma__OrgMemberClient<$Result.GetResult<Prisma.$OrgMemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OrgMembers.
     * @param {OrgMemberCreateManyArgs} args - Arguments to create many OrgMembers.
     * @example
     * // Create many OrgMembers
     * const orgMember = await prisma.orgMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrgMemberCreateManyArgs>(args?: SelectSubset<T, OrgMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrgMembers and returns the data saved in the database.
     * @param {OrgMemberCreateManyAndReturnArgs} args - Arguments to create many OrgMembers.
     * @example
     * // Create many OrgMembers
     * const orgMember = await prisma.orgMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrgMembers and only return the `id`
     * const orgMemberWithIdOnly = await prisma.orgMember.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrgMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, OrgMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrgMemberPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OrgMember.
     * @param {OrgMemberDeleteArgs} args - Arguments to delete one OrgMember.
     * @example
     * // Delete one OrgMember
     * const OrgMember = await prisma.orgMember.delete({
     *   where: {
     *     // ... filter to delete one OrgMember
     *   }
     * })
     * 
     */
    delete<T extends OrgMemberDeleteArgs>(args: SelectSubset<T, OrgMemberDeleteArgs<ExtArgs>>): Prisma__OrgMemberClient<$Result.GetResult<Prisma.$OrgMemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OrgMember.
     * @param {OrgMemberUpdateArgs} args - Arguments to update one OrgMember.
     * @example
     * // Update one OrgMember
     * const orgMember = await prisma.orgMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrgMemberUpdateArgs>(args: SelectSubset<T, OrgMemberUpdateArgs<ExtArgs>>): Prisma__OrgMemberClient<$Result.GetResult<Prisma.$OrgMemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OrgMembers.
     * @param {OrgMemberDeleteManyArgs} args - Arguments to filter OrgMembers to delete.
     * @example
     * // Delete a few OrgMembers
     * const { count } = await prisma.orgMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrgMemberDeleteManyArgs>(args?: SelectSubset<T, OrgMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrgMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrgMembers
     * const orgMember = await prisma.orgMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrgMemberUpdateManyArgs>(args: SelectSubset<T, OrgMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrgMember.
     * @param {OrgMemberUpsertArgs} args - Arguments to update or create a OrgMember.
     * @example
     * // Update or create a OrgMember
     * const orgMember = await prisma.orgMember.upsert({
     *   create: {
     *     // ... data to create a OrgMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrgMember we want to update
     *   }
     * })
     */
    upsert<T extends OrgMemberUpsertArgs>(args: SelectSubset<T, OrgMemberUpsertArgs<ExtArgs>>): Prisma__OrgMemberClient<$Result.GetResult<Prisma.$OrgMemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OrgMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgMemberCountArgs} args - Arguments to filter OrgMembers to count.
     * @example
     * // Count the number of OrgMembers
     * const count = await prisma.orgMember.count({
     *   where: {
     *     // ... the filter for the OrgMembers we want to count
     *   }
     * })
    **/
    count<T extends OrgMemberCountArgs>(
      args?: Subset<T, OrgMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrgMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrgMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrgMemberAggregateArgs>(args: Subset<T, OrgMemberAggregateArgs>): Prisma.PrismaPromise<GetOrgMemberAggregateType<T>>

    /**
     * Group by OrgMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrgMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrgMemberGroupByArgs['orderBy'] }
        : { orderBy?: OrgMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrgMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrgMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrgMember model
   */
  readonly fields: OrgMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrgMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrgMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    org<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrgMember model
   */ 
  interface OrgMemberFieldRefs {
    readonly id: FieldRef<"OrgMember", 'String'>
    readonly role: FieldRef<"OrgMember", 'String'>
    readonly userId: FieldRef<"OrgMember", 'String'>
    readonly orgId: FieldRef<"OrgMember", 'String'>
    readonly createdAt: FieldRef<"OrgMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrgMember findUnique
   */
  export type OrgMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgMember
     */
    select?: OrgMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrgMember to fetch.
     */
    where: OrgMemberWhereUniqueInput
  }

  /**
   * OrgMember findUniqueOrThrow
   */
  export type OrgMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgMember
     */
    select?: OrgMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrgMember to fetch.
     */
    where: OrgMemberWhereUniqueInput
  }

  /**
   * OrgMember findFirst
   */
  export type OrgMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgMember
     */
    select?: OrgMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrgMember to fetch.
     */
    where?: OrgMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrgMembers to fetch.
     */
    orderBy?: OrgMemberOrderByWithRelationInput | OrgMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrgMembers.
     */
    cursor?: OrgMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrgMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrgMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrgMembers.
     */
    distinct?: OrgMemberScalarFieldEnum | OrgMemberScalarFieldEnum[]
  }

  /**
   * OrgMember findFirstOrThrow
   */
  export type OrgMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgMember
     */
    select?: OrgMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrgMember to fetch.
     */
    where?: OrgMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrgMembers to fetch.
     */
    orderBy?: OrgMemberOrderByWithRelationInput | OrgMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrgMembers.
     */
    cursor?: OrgMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrgMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrgMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrgMembers.
     */
    distinct?: OrgMemberScalarFieldEnum | OrgMemberScalarFieldEnum[]
  }

  /**
   * OrgMember findMany
   */
  export type OrgMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgMember
     */
    select?: OrgMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrgMembers to fetch.
     */
    where?: OrgMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrgMembers to fetch.
     */
    orderBy?: OrgMemberOrderByWithRelationInput | OrgMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrgMembers.
     */
    cursor?: OrgMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrgMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrgMembers.
     */
    skip?: number
    distinct?: OrgMemberScalarFieldEnum | OrgMemberScalarFieldEnum[]
  }

  /**
   * OrgMember create
   */
  export type OrgMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgMember
     */
    select?: OrgMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a OrgMember.
     */
    data: XOR<OrgMemberCreateInput, OrgMemberUncheckedCreateInput>
  }

  /**
   * OrgMember createMany
   */
  export type OrgMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrgMembers.
     */
    data: OrgMemberCreateManyInput | OrgMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrgMember createManyAndReturn
   */
  export type OrgMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgMember
     */
    select?: OrgMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OrgMembers.
     */
    data: OrgMemberCreateManyInput | OrgMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrgMember update
   */
  export type OrgMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgMember
     */
    select?: OrgMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a OrgMember.
     */
    data: XOR<OrgMemberUpdateInput, OrgMemberUncheckedUpdateInput>
    /**
     * Choose, which OrgMember to update.
     */
    where: OrgMemberWhereUniqueInput
  }

  /**
   * OrgMember updateMany
   */
  export type OrgMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrgMembers.
     */
    data: XOR<OrgMemberUpdateManyMutationInput, OrgMemberUncheckedUpdateManyInput>
    /**
     * Filter which OrgMembers to update
     */
    where?: OrgMemberWhereInput
  }

  /**
   * OrgMember upsert
   */
  export type OrgMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgMember
     */
    select?: OrgMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the OrgMember to update in case it exists.
     */
    where: OrgMemberWhereUniqueInput
    /**
     * In case the OrgMember found by the `where` argument doesn't exist, create a new OrgMember with this data.
     */
    create: XOR<OrgMemberCreateInput, OrgMemberUncheckedCreateInput>
    /**
     * In case the OrgMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrgMemberUpdateInput, OrgMemberUncheckedUpdateInput>
  }

  /**
   * OrgMember delete
   */
  export type OrgMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgMember
     */
    select?: OrgMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMemberInclude<ExtArgs> | null
    /**
     * Filter which OrgMember to delete.
     */
    where: OrgMemberWhereUniqueInput
  }

  /**
   * OrgMember deleteMany
   */
  export type OrgMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrgMembers to delete
     */
    where?: OrgMemberWhereInput
  }

  /**
   * OrgMember without action
   */
  export type OrgMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgMember
     */
    select?: OrgMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMemberInclude<ExtArgs> | null
  }


  /**
   * Model Invitation
   */

  export type AggregateInvitation = {
    _count: InvitationCountAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  export type InvitationMinAggregateOutputType = {
    id: string | null
    email: string | null
    orgId: string | null
    role: string | null
    token: string | null
    expiresAt: Date | null
    acceptedAt: Date | null
    createdAt: Date | null
  }

  export type InvitationMaxAggregateOutputType = {
    id: string | null
    email: string | null
    orgId: string | null
    role: string | null
    token: string | null
    expiresAt: Date | null
    acceptedAt: Date | null
    createdAt: Date | null
  }

  export type InvitationCountAggregateOutputType = {
    id: number
    email: number
    orgId: number
    role: number
    token: number
    expiresAt: number
    acceptedAt: number
    createdAt: number
    _all: number
  }


  export type InvitationMinAggregateInputType = {
    id?: true
    email?: true
    orgId?: true
    role?: true
    token?: true
    expiresAt?: true
    acceptedAt?: true
    createdAt?: true
  }

  export type InvitationMaxAggregateInputType = {
    id?: true
    email?: true
    orgId?: true
    role?: true
    token?: true
    expiresAt?: true
    acceptedAt?: true
    createdAt?: true
  }

  export type InvitationCountAggregateInputType = {
    id?: true
    email?: true
    orgId?: true
    role?: true
    token?: true
    expiresAt?: true
    acceptedAt?: true
    createdAt?: true
    _all?: true
  }

  export type InvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitation to aggregate.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invitations
    **/
    _count?: true | InvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvitationMaxAggregateInputType
  }

  export type GetInvitationAggregateType<T extends InvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvitation[P]>
      : GetScalarType<T[P], AggregateInvitation[P]>
  }




  export type InvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithAggregationInput | InvitationOrderByWithAggregationInput[]
    by: InvitationScalarFieldEnum[] | InvitationScalarFieldEnum
    having?: InvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvitationCountAggregateInputType | true
    _min?: InvitationMinAggregateInputType
    _max?: InvitationMaxAggregateInputType
  }

  export type InvitationGroupByOutputType = {
    id: string
    email: string
    orgId: string
    role: string
    token: string
    expiresAt: Date
    acceptedAt: Date | null
    createdAt: Date
    _count: InvitationCountAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  type GetInvitationGroupByPayload<T extends InvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvitationGroupByOutputType[P]>
            : GetScalarType<T[P], InvitationGroupByOutputType[P]>
        }
      >
    >


  export type InvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    orgId?: boolean
    role?: boolean
    token?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    createdAt?: boolean
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    orgId?: boolean
    role?: boolean
    token?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    createdAt?: boolean
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectScalar = {
    id?: boolean
    email?: boolean
    orgId?: boolean
    role?: boolean
    token?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    createdAt?: boolean
  }

  export type InvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type InvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $InvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invitation"
    objects: {
      org: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      orgId: string
      role: string
      token: string
      expiresAt: Date
      acceptedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["invitation"]>
    composites: {}
  }

  type InvitationGetPayload<S extends boolean | null | undefined | InvitationDefaultArgs> = $Result.GetResult<Prisma.$InvitationPayload, S>

  type InvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvitationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvitationCountAggregateInputType | true
    }

  export interface InvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invitation'], meta: { name: 'Invitation' } }
    /**
     * Find zero or one Invitation that matches the filter.
     * @param {InvitationFindUniqueArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvitationFindUniqueArgs>(args: SelectSubset<T, InvitationFindUniqueArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invitation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvitationFindUniqueOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, InvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvitationFindFirstArgs>(args?: SelectSubset<T, InvitationFindFirstArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, InvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invitations
     * const invitations = await prisma.invitation.findMany()
     * 
     * // Get first 10 Invitations
     * const invitations = await prisma.invitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invitationWithIdOnly = await prisma.invitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvitationFindManyArgs>(args?: SelectSubset<T, InvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invitation.
     * @param {InvitationCreateArgs} args - Arguments to create a Invitation.
     * @example
     * // Create one Invitation
     * const Invitation = await prisma.invitation.create({
     *   data: {
     *     // ... data to create a Invitation
     *   }
     * })
     * 
     */
    create<T extends InvitationCreateArgs>(args: SelectSubset<T, InvitationCreateArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invitations.
     * @param {InvitationCreateManyArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitation = await prisma.invitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvitationCreateManyArgs>(args?: SelectSubset<T, InvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invitations and returns the data saved in the database.
     * @param {InvitationCreateManyAndReturnArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitation = await prisma.invitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invitations and only return the `id`
     * const invitationWithIdOnly = await prisma.invitation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, InvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Invitation.
     * @param {InvitationDeleteArgs} args - Arguments to delete one Invitation.
     * @example
     * // Delete one Invitation
     * const Invitation = await prisma.invitation.delete({
     *   where: {
     *     // ... filter to delete one Invitation
     *   }
     * })
     * 
     */
    delete<T extends InvitationDeleteArgs>(args: SelectSubset<T, InvitationDeleteArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invitation.
     * @param {InvitationUpdateArgs} args - Arguments to update one Invitation.
     * @example
     * // Update one Invitation
     * const invitation = await prisma.invitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvitationUpdateArgs>(args: SelectSubset<T, InvitationUpdateArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invitations.
     * @param {InvitationDeleteManyArgs} args - Arguments to filter Invitations to delete.
     * @example
     * // Delete a few Invitations
     * const { count } = await prisma.invitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvitationDeleteManyArgs>(args?: SelectSubset<T, InvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invitations
     * const invitation = await prisma.invitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvitationUpdateManyArgs>(args: SelectSubset<T, InvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invitation.
     * @param {InvitationUpsertArgs} args - Arguments to update or create a Invitation.
     * @example
     * // Update or create a Invitation
     * const invitation = await prisma.invitation.upsert({
     *   create: {
     *     // ... data to create a Invitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invitation we want to update
     *   }
     * })
     */
    upsert<T extends InvitationUpsertArgs>(args: SelectSubset<T, InvitationUpsertArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationCountArgs} args - Arguments to filter Invitations to count.
     * @example
     * // Count the number of Invitations
     * const count = await prisma.invitation.count({
     *   where: {
     *     // ... the filter for the Invitations we want to count
     *   }
     * })
    **/
    count<T extends InvitationCountArgs>(
      args?: Subset<T, InvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvitationAggregateArgs>(args: Subset<T, InvitationAggregateArgs>): Prisma.PrismaPromise<GetInvitationAggregateType<T>>

    /**
     * Group by Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvitationGroupByArgs['orderBy'] }
        : { orderBy?: InvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invitation model
   */
  readonly fields: InvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    org<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invitation model
   */ 
  interface InvitationFieldRefs {
    readonly id: FieldRef<"Invitation", 'String'>
    readonly email: FieldRef<"Invitation", 'String'>
    readonly orgId: FieldRef<"Invitation", 'String'>
    readonly role: FieldRef<"Invitation", 'String'>
    readonly token: FieldRef<"Invitation", 'String'>
    readonly expiresAt: FieldRef<"Invitation", 'DateTime'>
    readonly acceptedAt: FieldRef<"Invitation", 'DateTime'>
    readonly createdAt: FieldRef<"Invitation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invitation findUnique
   */
  export type InvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation findUniqueOrThrow
   */
  export type InvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation findFirst
   */
  export type InvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation findFirstOrThrow
   */
  export type InvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation findMany
   */
  export type InvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitations to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation create
   */
  export type InvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a Invitation.
     */
    data: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
  }

  /**
   * Invitation createMany
   */
  export type InvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invitations.
     */
    data: InvitationCreateManyInput | InvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invitation createManyAndReturn
   */
  export type InvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Invitations.
     */
    data: InvitationCreateManyInput | InvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invitation update
   */
  export type InvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a Invitation.
     */
    data: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
    /**
     * Choose, which Invitation to update.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation updateMany
   */
  export type InvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invitations.
     */
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyInput>
    /**
     * Filter which Invitations to update
     */
    where?: InvitationWhereInput
  }

  /**
   * Invitation upsert
   */
  export type InvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the Invitation to update in case it exists.
     */
    where: InvitationWhereUniqueInput
    /**
     * In case the Invitation found by the `where` argument doesn't exist, create a new Invitation with this data.
     */
    create: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
    /**
     * In case the Invitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
  }

  /**
   * Invitation delete
   */
  export type InvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter which Invitation to delete.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation deleteMany
   */
  export type InvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitations to delete
     */
    where?: InvitationWhereInput
  }

  /**
   * Invitation without action
   */
  export type InvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    ipAddress: number
    userAgent: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    token: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    ipAddress: string | null
    userAgent: string | null
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
      ipAddress: string | null
      userAgent: string | null
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly token: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    accountId: string | null
    providerId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    accountId: string | null
    providerId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    accountId: number
    providerId: number
    accessToken: number
    refreshToken: number
    idToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    scope: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    accountId: string
    providerId: string
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      accountId: string
      providerId: string
      accessToken: string | null
      refreshToken: string | null
      idToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      scope: string | null
      password: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */ 
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    name: string | null
    slug: string | null
    timezone: string | null
    statusPageEnabled: boolean | null
    statusPageTitle: string | null
    statusPageLogoUrl: string | null
    customDomain: string | null
    domainVerified: boolean | null
    domainVerifyToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    name: string | null
    slug: string | null
    timezone: string | null
    statusPageEnabled: boolean | null
    statusPageTitle: string | null
    statusPageLogoUrl: string | null
    customDomain: string | null
    domainVerified: boolean | null
    domainVerifyToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    orgId: number
    name: number
    slug: number
    timezone: number
    statusPageEnabled: number
    statusPageTitle: number
    statusPageLogoUrl: number
    customDomain: number
    domainVerified: number
    domainVerifyToken: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectMinAggregateInputType = {
    id?: true
    orgId?: true
    name?: true
    slug?: true
    timezone?: true
    statusPageEnabled?: true
    statusPageTitle?: true
    statusPageLogoUrl?: true
    customDomain?: true
    domainVerified?: true
    domainVerifyToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    orgId?: true
    name?: true
    slug?: true
    timezone?: true
    statusPageEnabled?: true
    statusPageTitle?: true
    statusPageLogoUrl?: true
    customDomain?: true
    domainVerified?: true
    domainVerifyToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    orgId?: true
    name?: true
    slug?: true
    timezone?: true
    statusPageEnabled?: true
    statusPageTitle?: true
    statusPageLogoUrl?: true
    customDomain?: true
    domainVerified?: true
    domainVerifyToken?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    orgId: string
    name: string
    slug: string
    timezone: string
    statusPageEnabled: boolean
    statusPageTitle: string | null
    statusPageLogoUrl: string | null
    customDomain: string | null
    domainVerified: boolean
    domainVerifyToken: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    name?: boolean
    slug?: boolean
    timezone?: boolean
    statusPageEnabled?: boolean
    statusPageTitle?: boolean
    statusPageLogoUrl?: boolean
    customDomain?: boolean
    domainVerified?: boolean
    domainVerifyToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    checks?: boolean | Project$checksArgs<ExtArgs>
    channels?: boolean | Project$channelsArgs<ExtArgs>
    apiKeys?: boolean | Project$apiKeysArgs<ExtArgs>
    incidents?: boolean | Project$incidentsArgs<ExtArgs>
    maintenance?: boolean | Project$maintenanceArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    name?: boolean
    slug?: boolean
    timezone?: boolean
    statusPageEnabled?: boolean
    statusPageTitle?: boolean
    statusPageLogoUrl?: boolean
    customDomain?: boolean
    domainVerified?: boolean
    domainVerifyToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    orgId?: boolean
    name?: boolean
    slug?: boolean
    timezone?: boolean
    statusPageEnabled?: boolean
    statusPageTitle?: boolean
    statusPageLogoUrl?: boolean
    customDomain?: boolean
    domainVerified?: boolean
    domainVerifyToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    checks?: boolean | Project$checksArgs<ExtArgs>
    channels?: boolean | Project$channelsArgs<ExtArgs>
    apiKeys?: boolean | Project$apiKeysArgs<ExtArgs>
    incidents?: boolean | Project$incidentsArgs<ExtArgs>
    maintenance?: boolean | Project$maintenanceArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      org: Prisma.$OrganizationPayload<ExtArgs>
      checks: Prisma.$CheckPayload<ExtArgs>[]
      channels: Prisma.$ChannelPayload<ExtArgs>[]
      apiKeys: Prisma.$ApiKeyPayload<ExtArgs>[]
      incidents: Prisma.$IncidentPayload<ExtArgs>[]
      maintenance: Prisma.$MaintenancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      name: string
      slug: string
      timezone: string
      statusPageEnabled: boolean
      statusPageTitle: string | null
      statusPageLogoUrl: string | null
      customDomain: string | null
      domainVerified: boolean
      domainVerifyToken: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    org<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    checks<T extends Project$checksArgs<ExtArgs> = {}>(args?: Subset<T, Project$checksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckPayload<ExtArgs>, T, "findMany"> | Null>
    channels<T extends Project$channelsArgs<ExtArgs> = {}>(args?: Subset<T, Project$channelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findMany"> | Null>
    apiKeys<T extends Project$apiKeysArgs<ExtArgs> = {}>(args?: Subset<T, Project$apiKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany"> | Null>
    incidents<T extends Project$incidentsArgs<ExtArgs> = {}>(args?: Subset<T, Project$incidentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findMany"> | Null>
    maintenance<T extends Project$maintenanceArgs<ExtArgs> = {}>(args?: Subset<T, Project$maintenanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */ 
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly orgId: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly slug: FieldRef<"Project", 'String'>
    readonly timezone: FieldRef<"Project", 'String'>
    readonly statusPageEnabled: FieldRef<"Project", 'Boolean'>
    readonly statusPageTitle: FieldRef<"Project", 'String'>
    readonly statusPageLogoUrl: FieldRef<"Project", 'String'>
    readonly customDomain: FieldRef<"Project", 'String'>
    readonly domainVerified: FieldRef<"Project", 'Boolean'>
    readonly domainVerifyToken: FieldRef<"Project", 'String'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
  }

  /**
   * Project.checks
   */
  export type Project$checksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Check
     */
    select?: CheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInclude<ExtArgs> | null
    where?: CheckWhereInput
    orderBy?: CheckOrderByWithRelationInput | CheckOrderByWithRelationInput[]
    cursor?: CheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CheckScalarFieldEnum | CheckScalarFieldEnum[]
  }

  /**
   * Project.channels
   */
  export type Project$channelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    where?: ChannelWhereInput
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    cursor?: ChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Project.apiKeys
   */
  export type Project$apiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    cursor?: ApiKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * Project.incidents
   */
  export type Project$incidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    where?: IncidentWhereInput
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    cursor?: IncidentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Project.maintenance
   */
  export type Project$maintenanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    where?: MaintenanceWhereInput
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    cursor?: MaintenanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceScalarFieldEnum | MaintenanceScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model Check
   */

  export type AggregateCheck = {
    _count: CheckCountAggregateOutputType | null
    _avg: CheckAvgAggregateOutputType | null
    _sum: CheckSumAggregateOutputType | null
    _min: CheckMinAggregateOutputType | null
    _max: CheckMaxAggregateOutputType | null
  }

  export type CheckAvgAggregateOutputType = {
    graceSeconds: number | null
    reminderIntervalHours: number | null
  }

  export type CheckSumAggregateOutputType = {
    graceSeconds: number | null
    reminderIntervalHours: number | null
  }

  export type CheckMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    slug: string | null
    scheduleType: $Enums.ScheduleType | null
    scheduleValue: string | null
    graceSeconds: number | null
    timezone: string | null
    status: $Enums.CheckStatus | null
    lastPingAt: Date | null
    lastStartedAt: Date | null
    nextExpectedAt: Date | null
    lastAlertAt: Date | null
    alertOnRecovery: boolean | null
    reminderIntervalHours: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CheckMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    slug: string | null
    scheduleType: $Enums.ScheduleType | null
    scheduleValue: string | null
    graceSeconds: number | null
    timezone: string | null
    status: $Enums.CheckStatus | null
    lastPingAt: Date | null
    lastStartedAt: Date | null
    nextExpectedAt: Date | null
    lastAlertAt: Date | null
    alertOnRecovery: boolean | null
    reminderIntervalHours: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CheckCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    slug: number
    scheduleType: number
    scheduleValue: number
    graceSeconds: number
    timezone: number
    status: number
    lastPingAt: number
    lastStartedAt: number
    nextExpectedAt: number
    lastAlertAt: number
    alertOnRecovery: number
    reminderIntervalHours: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CheckAvgAggregateInputType = {
    graceSeconds?: true
    reminderIntervalHours?: true
  }

  export type CheckSumAggregateInputType = {
    graceSeconds?: true
    reminderIntervalHours?: true
  }

  export type CheckMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    slug?: true
    scheduleType?: true
    scheduleValue?: true
    graceSeconds?: true
    timezone?: true
    status?: true
    lastPingAt?: true
    lastStartedAt?: true
    nextExpectedAt?: true
    lastAlertAt?: true
    alertOnRecovery?: true
    reminderIntervalHours?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CheckMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    slug?: true
    scheduleType?: true
    scheduleValue?: true
    graceSeconds?: true
    timezone?: true
    status?: true
    lastPingAt?: true
    lastStartedAt?: true
    nextExpectedAt?: true
    lastAlertAt?: true
    alertOnRecovery?: true
    reminderIntervalHours?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CheckCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    slug?: true
    scheduleType?: true
    scheduleValue?: true
    graceSeconds?: true
    timezone?: true
    status?: true
    lastPingAt?: true
    lastStartedAt?: true
    nextExpectedAt?: true
    lastAlertAt?: true
    alertOnRecovery?: true
    reminderIntervalHours?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CheckAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Check to aggregate.
     */
    where?: CheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Checks to fetch.
     */
    orderBy?: CheckOrderByWithRelationInput | CheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Checks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Checks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Checks
    **/
    _count?: true | CheckCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CheckAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CheckSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CheckMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CheckMaxAggregateInputType
  }

  export type GetCheckAggregateType<T extends CheckAggregateArgs> = {
        [P in keyof T & keyof AggregateCheck]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCheck[P]>
      : GetScalarType<T[P], AggregateCheck[P]>
  }




  export type CheckGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckWhereInput
    orderBy?: CheckOrderByWithAggregationInput | CheckOrderByWithAggregationInput[]
    by: CheckScalarFieldEnum[] | CheckScalarFieldEnum
    having?: CheckScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CheckCountAggregateInputType | true
    _avg?: CheckAvgAggregateInputType
    _sum?: CheckSumAggregateInputType
    _min?: CheckMinAggregateInputType
    _max?: CheckMaxAggregateInputType
  }

  export type CheckGroupByOutputType = {
    id: string
    projectId: string
    name: string
    slug: string | null
    scheduleType: $Enums.ScheduleType
    scheduleValue: string
    graceSeconds: number
    timezone: string | null
    status: $Enums.CheckStatus
    lastPingAt: Date | null
    lastStartedAt: Date | null
    nextExpectedAt: Date | null
    lastAlertAt: Date | null
    alertOnRecovery: boolean
    reminderIntervalHours: number | null
    createdAt: Date
    updatedAt: Date
    _count: CheckCountAggregateOutputType | null
    _avg: CheckAvgAggregateOutputType | null
    _sum: CheckSumAggregateOutputType | null
    _min: CheckMinAggregateOutputType | null
    _max: CheckMaxAggregateOutputType | null
  }

  type GetCheckGroupByPayload<T extends CheckGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CheckGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CheckGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CheckGroupByOutputType[P]>
            : GetScalarType<T[P], CheckGroupByOutputType[P]>
        }
      >
    >


  export type CheckSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    slug?: boolean
    scheduleType?: boolean
    scheduleValue?: boolean
    graceSeconds?: boolean
    timezone?: boolean
    status?: boolean
    lastPingAt?: boolean
    lastStartedAt?: boolean
    nextExpectedAt?: boolean
    lastAlertAt?: boolean
    alertOnRecovery?: boolean
    reminderIntervalHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    pings?: boolean | Check$pingsArgs<ExtArgs>
    checkChannels?: boolean | Check$checkChannelsArgs<ExtArgs>
    alerts?: boolean | Check$alertsArgs<ExtArgs>
    incidentChecks?: boolean | Check$incidentChecksArgs<ExtArgs>
    maintenanceChecks?: boolean | Check$maintenanceChecksArgs<ExtArgs>
    dailyStats?: boolean | Check$dailyStatsArgs<ExtArgs>
    _count?: boolean | CheckCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["check"]>

  export type CheckSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    slug?: boolean
    scheduleType?: boolean
    scheduleValue?: boolean
    graceSeconds?: boolean
    timezone?: boolean
    status?: boolean
    lastPingAt?: boolean
    lastStartedAt?: boolean
    nextExpectedAt?: boolean
    lastAlertAt?: boolean
    alertOnRecovery?: boolean
    reminderIntervalHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["check"]>

  export type CheckSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    slug?: boolean
    scheduleType?: boolean
    scheduleValue?: boolean
    graceSeconds?: boolean
    timezone?: boolean
    status?: boolean
    lastPingAt?: boolean
    lastStartedAt?: boolean
    nextExpectedAt?: boolean
    lastAlertAt?: boolean
    alertOnRecovery?: boolean
    reminderIntervalHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CheckInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    pings?: boolean | Check$pingsArgs<ExtArgs>
    checkChannels?: boolean | Check$checkChannelsArgs<ExtArgs>
    alerts?: boolean | Check$alertsArgs<ExtArgs>
    incidentChecks?: boolean | Check$incidentChecksArgs<ExtArgs>
    maintenanceChecks?: boolean | Check$maintenanceChecksArgs<ExtArgs>
    dailyStats?: boolean | Check$dailyStatsArgs<ExtArgs>
    _count?: boolean | CheckCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CheckIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $CheckPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Check"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      pings: Prisma.$PingPayload<ExtArgs>[]
      checkChannels: Prisma.$CheckChannelPayload<ExtArgs>[]
      alerts: Prisma.$AlertPayload<ExtArgs>[]
      incidentChecks: Prisma.$IncidentCheckPayload<ExtArgs>[]
      maintenanceChecks: Prisma.$MaintenanceCheckPayload<ExtArgs>[]
      dailyStats: Prisma.$CheckDailyStatPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      name: string
      slug: string | null
      scheduleType: $Enums.ScheduleType
      scheduleValue: string
      graceSeconds: number
      timezone: string | null
      status: $Enums.CheckStatus
      lastPingAt: Date | null
      lastStartedAt: Date | null
      nextExpectedAt: Date | null
      lastAlertAt: Date | null
      alertOnRecovery: boolean
      reminderIntervalHours: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["check"]>
    composites: {}
  }

  type CheckGetPayload<S extends boolean | null | undefined | CheckDefaultArgs> = $Result.GetResult<Prisma.$CheckPayload, S>

  type CheckCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CheckFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CheckCountAggregateInputType | true
    }

  export interface CheckDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Check'], meta: { name: 'Check' } }
    /**
     * Find zero or one Check that matches the filter.
     * @param {CheckFindUniqueArgs} args - Arguments to find a Check
     * @example
     * // Get one Check
     * const check = await prisma.check.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CheckFindUniqueArgs>(args: SelectSubset<T, CheckFindUniqueArgs<ExtArgs>>): Prisma__CheckClient<$Result.GetResult<Prisma.$CheckPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Check that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CheckFindUniqueOrThrowArgs} args - Arguments to find a Check
     * @example
     * // Get one Check
     * const check = await prisma.check.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CheckFindUniqueOrThrowArgs>(args: SelectSubset<T, CheckFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CheckClient<$Result.GetResult<Prisma.$CheckPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Check that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckFindFirstArgs} args - Arguments to find a Check
     * @example
     * // Get one Check
     * const check = await prisma.check.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CheckFindFirstArgs>(args?: SelectSubset<T, CheckFindFirstArgs<ExtArgs>>): Prisma__CheckClient<$Result.GetResult<Prisma.$CheckPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Check that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckFindFirstOrThrowArgs} args - Arguments to find a Check
     * @example
     * // Get one Check
     * const check = await prisma.check.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CheckFindFirstOrThrowArgs>(args?: SelectSubset<T, CheckFindFirstOrThrowArgs<ExtArgs>>): Prisma__CheckClient<$Result.GetResult<Prisma.$CheckPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Checks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Checks
     * const checks = await prisma.check.findMany()
     * 
     * // Get first 10 Checks
     * const checks = await prisma.check.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const checkWithIdOnly = await prisma.check.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CheckFindManyArgs>(args?: SelectSubset<T, CheckFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Check.
     * @param {CheckCreateArgs} args - Arguments to create a Check.
     * @example
     * // Create one Check
     * const Check = await prisma.check.create({
     *   data: {
     *     // ... data to create a Check
     *   }
     * })
     * 
     */
    create<T extends CheckCreateArgs>(args: SelectSubset<T, CheckCreateArgs<ExtArgs>>): Prisma__CheckClient<$Result.GetResult<Prisma.$CheckPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Checks.
     * @param {CheckCreateManyArgs} args - Arguments to create many Checks.
     * @example
     * // Create many Checks
     * const check = await prisma.check.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CheckCreateManyArgs>(args?: SelectSubset<T, CheckCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Checks and returns the data saved in the database.
     * @param {CheckCreateManyAndReturnArgs} args - Arguments to create many Checks.
     * @example
     * // Create many Checks
     * const check = await prisma.check.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Checks and only return the `id`
     * const checkWithIdOnly = await prisma.check.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CheckCreateManyAndReturnArgs>(args?: SelectSubset<T, CheckCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Check.
     * @param {CheckDeleteArgs} args - Arguments to delete one Check.
     * @example
     * // Delete one Check
     * const Check = await prisma.check.delete({
     *   where: {
     *     // ... filter to delete one Check
     *   }
     * })
     * 
     */
    delete<T extends CheckDeleteArgs>(args: SelectSubset<T, CheckDeleteArgs<ExtArgs>>): Prisma__CheckClient<$Result.GetResult<Prisma.$CheckPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Check.
     * @param {CheckUpdateArgs} args - Arguments to update one Check.
     * @example
     * // Update one Check
     * const check = await prisma.check.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CheckUpdateArgs>(args: SelectSubset<T, CheckUpdateArgs<ExtArgs>>): Prisma__CheckClient<$Result.GetResult<Prisma.$CheckPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Checks.
     * @param {CheckDeleteManyArgs} args - Arguments to filter Checks to delete.
     * @example
     * // Delete a few Checks
     * const { count } = await prisma.check.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CheckDeleteManyArgs>(args?: SelectSubset<T, CheckDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Checks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Checks
     * const check = await prisma.check.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CheckUpdateManyArgs>(args: SelectSubset<T, CheckUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Check.
     * @param {CheckUpsertArgs} args - Arguments to update or create a Check.
     * @example
     * // Update or create a Check
     * const check = await prisma.check.upsert({
     *   create: {
     *     // ... data to create a Check
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Check we want to update
     *   }
     * })
     */
    upsert<T extends CheckUpsertArgs>(args: SelectSubset<T, CheckUpsertArgs<ExtArgs>>): Prisma__CheckClient<$Result.GetResult<Prisma.$CheckPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Checks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckCountArgs} args - Arguments to filter Checks to count.
     * @example
     * // Count the number of Checks
     * const count = await prisma.check.count({
     *   where: {
     *     // ... the filter for the Checks we want to count
     *   }
     * })
    **/
    count<T extends CheckCountArgs>(
      args?: Subset<T, CheckCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CheckCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Check.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CheckAggregateArgs>(args: Subset<T, CheckAggregateArgs>): Prisma.PrismaPromise<GetCheckAggregateType<T>>

    /**
     * Group by Check.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CheckGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CheckGroupByArgs['orderBy'] }
        : { orderBy?: CheckGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CheckGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCheckGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Check model
   */
  readonly fields: CheckFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Check.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CheckClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    pings<T extends Check$pingsArgs<ExtArgs> = {}>(args?: Subset<T, Check$pingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PingPayload<ExtArgs>, T, "findMany"> | Null>
    checkChannels<T extends Check$checkChannelsArgs<ExtArgs> = {}>(args?: Subset<T, Check$checkChannelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckChannelPayload<ExtArgs>, T, "findMany"> | Null>
    alerts<T extends Check$alertsArgs<ExtArgs> = {}>(args?: Subset<T, Check$alertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany"> | Null>
    incidentChecks<T extends Check$incidentChecksArgs<ExtArgs> = {}>(args?: Subset<T, Check$incidentChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentCheckPayload<ExtArgs>, T, "findMany"> | Null>
    maintenanceChecks<T extends Check$maintenanceChecksArgs<ExtArgs> = {}>(args?: Subset<T, Check$maintenanceChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceCheckPayload<ExtArgs>, T, "findMany"> | Null>
    dailyStats<T extends Check$dailyStatsArgs<ExtArgs> = {}>(args?: Subset<T, Check$dailyStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckDailyStatPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Check model
   */ 
  interface CheckFieldRefs {
    readonly id: FieldRef<"Check", 'String'>
    readonly projectId: FieldRef<"Check", 'String'>
    readonly name: FieldRef<"Check", 'String'>
    readonly slug: FieldRef<"Check", 'String'>
    readonly scheduleType: FieldRef<"Check", 'ScheduleType'>
    readonly scheduleValue: FieldRef<"Check", 'String'>
    readonly graceSeconds: FieldRef<"Check", 'Int'>
    readonly timezone: FieldRef<"Check", 'String'>
    readonly status: FieldRef<"Check", 'CheckStatus'>
    readonly lastPingAt: FieldRef<"Check", 'DateTime'>
    readonly lastStartedAt: FieldRef<"Check", 'DateTime'>
    readonly nextExpectedAt: FieldRef<"Check", 'DateTime'>
    readonly lastAlertAt: FieldRef<"Check", 'DateTime'>
    readonly alertOnRecovery: FieldRef<"Check", 'Boolean'>
    readonly reminderIntervalHours: FieldRef<"Check", 'Int'>
    readonly createdAt: FieldRef<"Check", 'DateTime'>
    readonly updatedAt: FieldRef<"Check", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Check findUnique
   */
  export type CheckFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Check
     */
    select?: CheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInclude<ExtArgs> | null
    /**
     * Filter, which Check to fetch.
     */
    where: CheckWhereUniqueInput
  }

  /**
   * Check findUniqueOrThrow
   */
  export type CheckFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Check
     */
    select?: CheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInclude<ExtArgs> | null
    /**
     * Filter, which Check to fetch.
     */
    where: CheckWhereUniqueInput
  }

  /**
   * Check findFirst
   */
  export type CheckFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Check
     */
    select?: CheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInclude<ExtArgs> | null
    /**
     * Filter, which Check to fetch.
     */
    where?: CheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Checks to fetch.
     */
    orderBy?: CheckOrderByWithRelationInput | CheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Checks.
     */
    cursor?: CheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Checks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Checks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Checks.
     */
    distinct?: CheckScalarFieldEnum | CheckScalarFieldEnum[]
  }

  /**
   * Check findFirstOrThrow
   */
  export type CheckFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Check
     */
    select?: CheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInclude<ExtArgs> | null
    /**
     * Filter, which Check to fetch.
     */
    where?: CheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Checks to fetch.
     */
    orderBy?: CheckOrderByWithRelationInput | CheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Checks.
     */
    cursor?: CheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Checks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Checks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Checks.
     */
    distinct?: CheckScalarFieldEnum | CheckScalarFieldEnum[]
  }

  /**
   * Check findMany
   */
  export type CheckFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Check
     */
    select?: CheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInclude<ExtArgs> | null
    /**
     * Filter, which Checks to fetch.
     */
    where?: CheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Checks to fetch.
     */
    orderBy?: CheckOrderByWithRelationInput | CheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Checks.
     */
    cursor?: CheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Checks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Checks.
     */
    skip?: number
    distinct?: CheckScalarFieldEnum | CheckScalarFieldEnum[]
  }

  /**
   * Check create
   */
  export type CheckCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Check
     */
    select?: CheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInclude<ExtArgs> | null
    /**
     * The data needed to create a Check.
     */
    data: XOR<CheckCreateInput, CheckUncheckedCreateInput>
  }

  /**
   * Check createMany
   */
  export type CheckCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Checks.
     */
    data: CheckCreateManyInput | CheckCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Check createManyAndReturn
   */
  export type CheckCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Check
     */
    select?: CheckSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Checks.
     */
    data: CheckCreateManyInput | CheckCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Check update
   */
  export type CheckUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Check
     */
    select?: CheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInclude<ExtArgs> | null
    /**
     * The data needed to update a Check.
     */
    data: XOR<CheckUpdateInput, CheckUncheckedUpdateInput>
    /**
     * Choose, which Check to update.
     */
    where: CheckWhereUniqueInput
  }

  /**
   * Check updateMany
   */
  export type CheckUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Checks.
     */
    data: XOR<CheckUpdateManyMutationInput, CheckUncheckedUpdateManyInput>
    /**
     * Filter which Checks to update
     */
    where?: CheckWhereInput
  }

  /**
   * Check upsert
   */
  export type CheckUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Check
     */
    select?: CheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInclude<ExtArgs> | null
    /**
     * The filter to search for the Check to update in case it exists.
     */
    where: CheckWhereUniqueInput
    /**
     * In case the Check found by the `where` argument doesn't exist, create a new Check with this data.
     */
    create: XOR<CheckCreateInput, CheckUncheckedCreateInput>
    /**
     * In case the Check was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CheckUpdateInput, CheckUncheckedUpdateInput>
  }

  /**
   * Check delete
   */
  export type CheckDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Check
     */
    select?: CheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInclude<ExtArgs> | null
    /**
     * Filter which Check to delete.
     */
    where: CheckWhereUniqueInput
  }

  /**
   * Check deleteMany
   */
  export type CheckDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Checks to delete
     */
    where?: CheckWhereInput
  }

  /**
   * Check.pings
   */
  export type Check$pingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ping
     */
    select?: PingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PingInclude<ExtArgs> | null
    where?: PingWhereInput
    orderBy?: PingOrderByWithRelationInput | PingOrderByWithRelationInput[]
    cursor?: PingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PingScalarFieldEnum | PingScalarFieldEnum[]
  }

  /**
   * Check.checkChannels
   */
  export type Check$checkChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckChannel
     */
    select?: CheckChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckChannelInclude<ExtArgs> | null
    where?: CheckChannelWhereInput
    orderBy?: CheckChannelOrderByWithRelationInput | CheckChannelOrderByWithRelationInput[]
    cursor?: CheckChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CheckChannelScalarFieldEnum | CheckChannelScalarFieldEnum[]
  }

  /**
   * Check.alerts
   */
  export type Check$alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    cursor?: AlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Check.incidentChecks
   */
  export type Check$incidentChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentCheck
     */
    select?: IncidentCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentCheckInclude<ExtArgs> | null
    where?: IncidentCheckWhereInput
    orderBy?: IncidentCheckOrderByWithRelationInput | IncidentCheckOrderByWithRelationInput[]
    cursor?: IncidentCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentCheckScalarFieldEnum | IncidentCheckScalarFieldEnum[]
  }

  /**
   * Check.maintenanceChecks
   */
  export type Check$maintenanceChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceCheck
     */
    select?: MaintenanceCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceCheckInclude<ExtArgs> | null
    where?: MaintenanceCheckWhereInput
    orderBy?: MaintenanceCheckOrderByWithRelationInput | MaintenanceCheckOrderByWithRelationInput[]
    cursor?: MaintenanceCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceCheckScalarFieldEnum | MaintenanceCheckScalarFieldEnum[]
  }

  /**
   * Check.dailyStats
   */
  export type Check$dailyStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckDailyStat
     */
    select?: CheckDailyStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckDailyStatInclude<ExtArgs> | null
    where?: CheckDailyStatWhereInput
    orderBy?: CheckDailyStatOrderByWithRelationInput | CheckDailyStatOrderByWithRelationInput[]
    cursor?: CheckDailyStatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CheckDailyStatScalarFieldEnum | CheckDailyStatScalarFieldEnum[]
  }

  /**
   * Check without action
   */
  export type CheckDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Check
     */
    select?: CheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInclude<ExtArgs> | null
  }


  /**
   * Model Ping
   */

  export type AggregatePing = {
    _count: PingCountAggregateOutputType | null
    _min: PingMinAggregateOutputType | null
    _max: PingMaxAggregateOutputType | null
  }

  export type PingMinAggregateOutputType = {
    id: string | null
    checkId: string | null
    type: $Enums.PingType | null
    body: string | null
    sourceIp: string | null
    createdAt: Date | null
  }

  export type PingMaxAggregateOutputType = {
    id: string | null
    checkId: string | null
    type: $Enums.PingType | null
    body: string | null
    sourceIp: string | null
    createdAt: Date | null
  }

  export type PingCountAggregateOutputType = {
    id: number
    checkId: number
    type: number
    body: number
    sourceIp: number
    createdAt: number
    _all: number
  }


  export type PingMinAggregateInputType = {
    id?: true
    checkId?: true
    type?: true
    body?: true
    sourceIp?: true
    createdAt?: true
  }

  export type PingMaxAggregateInputType = {
    id?: true
    checkId?: true
    type?: true
    body?: true
    sourceIp?: true
    createdAt?: true
  }

  export type PingCountAggregateInputType = {
    id?: true
    checkId?: true
    type?: true
    body?: true
    sourceIp?: true
    createdAt?: true
    _all?: true
  }

  export type PingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ping to aggregate.
     */
    where?: PingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pings to fetch.
     */
    orderBy?: PingOrderByWithRelationInput | PingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pings
    **/
    _count?: true | PingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PingMaxAggregateInputType
  }

  export type GetPingAggregateType<T extends PingAggregateArgs> = {
        [P in keyof T & keyof AggregatePing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePing[P]>
      : GetScalarType<T[P], AggregatePing[P]>
  }




  export type PingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PingWhereInput
    orderBy?: PingOrderByWithAggregationInput | PingOrderByWithAggregationInput[]
    by: PingScalarFieldEnum[] | PingScalarFieldEnum
    having?: PingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PingCountAggregateInputType | true
    _min?: PingMinAggregateInputType
    _max?: PingMaxAggregateInputType
  }

  export type PingGroupByOutputType = {
    id: string
    checkId: string
    type: $Enums.PingType
    body: string | null
    sourceIp: string
    createdAt: Date
    _count: PingCountAggregateOutputType | null
    _min: PingMinAggregateOutputType | null
    _max: PingMaxAggregateOutputType | null
  }

  type GetPingGroupByPayload<T extends PingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PingGroupByOutputType[P]>
            : GetScalarType<T[P], PingGroupByOutputType[P]>
        }
      >
    >


  export type PingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    checkId?: boolean
    type?: boolean
    body?: boolean
    sourceIp?: boolean
    createdAt?: boolean
    check?: boolean | CheckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ping"]>

  export type PingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    checkId?: boolean
    type?: boolean
    body?: boolean
    sourceIp?: boolean
    createdAt?: boolean
    check?: boolean | CheckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ping"]>

  export type PingSelectScalar = {
    id?: boolean
    checkId?: boolean
    type?: boolean
    body?: boolean
    sourceIp?: boolean
    createdAt?: boolean
  }

  export type PingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    check?: boolean | CheckDefaultArgs<ExtArgs>
  }
  export type PingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    check?: boolean | CheckDefaultArgs<ExtArgs>
  }

  export type $PingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ping"
    objects: {
      check: Prisma.$CheckPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      checkId: string
      type: $Enums.PingType
      body: string | null
      sourceIp: string
      createdAt: Date
    }, ExtArgs["result"]["ping"]>
    composites: {}
  }

  type PingGetPayload<S extends boolean | null | undefined | PingDefaultArgs> = $Result.GetResult<Prisma.$PingPayload, S>

  type PingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PingCountAggregateInputType | true
    }

  export interface PingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ping'], meta: { name: 'Ping' } }
    /**
     * Find zero or one Ping that matches the filter.
     * @param {PingFindUniqueArgs} args - Arguments to find a Ping
     * @example
     * // Get one Ping
     * const ping = await prisma.ping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PingFindUniqueArgs>(args: SelectSubset<T, PingFindUniqueArgs<ExtArgs>>): Prisma__PingClient<$Result.GetResult<Prisma.$PingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ping that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PingFindUniqueOrThrowArgs} args - Arguments to find a Ping
     * @example
     * // Get one Ping
     * const ping = await prisma.ping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PingFindUniqueOrThrowArgs>(args: SelectSubset<T, PingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PingClient<$Result.GetResult<Prisma.$PingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PingFindFirstArgs} args - Arguments to find a Ping
     * @example
     * // Get one Ping
     * const ping = await prisma.ping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PingFindFirstArgs>(args?: SelectSubset<T, PingFindFirstArgs<ExtArgs>>): Prisma__PingClient<$Result.GetResult<Prisma.$PingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PingFindFirstOrThrowArgs} args - Arguments to find a Ping
     * @example
     * // Get one Ping
     * const ping = await prisma.ping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PingFindFirstOrThrowArgs>(args?: SelectSubset<T, PingFindFirstOrThrowArgs<ExtArgs>>): Prisma__PingClient<$Result.GetResult<Prisma.$PingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pings
     * const pings = await prisma.ping.findMany()
     * 
     * // Get first 10 Pings
     * const pings = await prisma.ping.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pingWithIdOnly = await prisma.ping.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PingFindManyArgs>(args?: SelectSubset<T, PingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ping.
     * @param {PingCreateArgs} args - Arguments to create a Ping.
     * @example
     * // Create one Ping
     * const Ping = await prisma.ping.create({
     *   data: {
     *     // ... data to create a Ping
     *   }
     * })
     * 
     */
    create<T extends PingCreateArgs>(args: SelectSubset<T, PingCreateArgs<ExtArgs>>): Prisma__PingClient<$Result.GetResult<Prisma.$PingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pings.
     * @param {PingCreateManyArgs} args - Arguments to create many Pings.
     * @example
     * // Create many Pings
     * const ping = await prisma.ping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PingCreateManyArgs>(args?: SelectSubset<T, PingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pings and returns the data saved in the database.
     * @param {PingCreateManyAndReturnArgs} args - Arguments to create many Pings.
     * @example
     * // Create many Pings
     * const ping = await prisma.ping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pings and only return the `id`
     * const pingWithIdOnly = await prisma.ping.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PingCreateManyAndReturnArgs>(args?: SelectSubset<T, PingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Ping.
     * @param {PingDeleteArgs} args - Arguments to delete one Ping.
     * @example
     * // Delete one Ping
     * const Ping = await prisma.ping.delete({
     *   where: {
     *     // ... filter to delete one Ping
     *   }
     * })
     * 
     */
    delete<T extends PingDeleteArgs>(args: SelectSubset<T, PingDeleteArgs<ExtArgs>>): Prisma__PingClient<$Result.GetResult<Prisma.$PingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ping.
     * @param {PingUpdateArgs} args - Arguments to update one Ping.
     * @example
     * // Update one Ping
     * const ping = await prisma.ping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PingUpdateArgs>(args: SelectSubset<T, PingUpdateArgs<ExtArgs>>): Prisma__PingClient<$Result.GetResult<Prisma.$PingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pings.
     * @param {PingDeleteManyArgs} args - Arguments to filter Pings to delete.
     * @example
     * // Delete a few Pings
     * const { count } = await prisma.ping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PingDeleteManyArgs>(args?: SelectSubset<T, PingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pings
     * const ping = await prisma.ping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PingUpdateManyArgs>(args: SelectSubset<T, PingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ping.
     * @param {PingUpsertArgs} args - Arguments to update or create a Ping.
     * @example
     * // Update or create a Ping
     * const ping = await prisma.ping.upsert({
     *   create: {
     *     // ... data to create a Ping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ping we want to update
     *   }
     * })
     */
    upsert<T extends PingUpsertArgs>(args: SelectSubset<T, PingUpsertArgs<ExtArgs>>): Prisma__PingClient<$Result.GetResult<Prisma.$PingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PingCountArgs} args - Arguments to filter Pings to count.
     * @example
     * // Count the number of Pings
     * const count = await prisma.ping.count({
     *   where: {
     *     // ... the filter for the Pings we want to count
     *   }
     * })
    **/
    count<T extends PingCountArgs>(
      args?: Subset<T, PingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PingAggregateArgs>(args: Subset<T, PingAggregateArgs>): Prisma.PrismaPromise<GetPingAggregateType<T>>

    /**
     * Group by Ping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PingGroupByArgs['orderBy'] }
        : { orderBy?: PingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ping model
   */
  readonly fields: PingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    check<T extends CheckDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CheckDefaultArgs<ExtArgs>>): Prisma__CheckClient<$Result.GetResult<Prisma.$CheckPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ping model
   */ 
  interface PingFieldRefs {
    readonly id: FieldRef<"Ping", 'String'>
    readonly checkId: FieldRef<"Ping", 'String'>
    readonly type: FieldRef<"Ping", 'PingType'>
    readonly body: FieldRef<"Ping", 'String'>
    readonly sourceIp: FieldRef<"Ping", 'String'>
    readonly createdAt: FieldRef<"Ping", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ping findUnique
   */
  export type PingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ping
     */
    select?: PingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PingInclude<ExtArgs> | null
    /**
     * Filter, which Ping to fetch.
     */
    where: PingWhereUniqueInput
  }

  /**
   * Ping findUniqueOrThrow
   */
  export type PingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ping
     */
    select?: PingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PingInclude<ExtArgs> | null
    /**
     * Filter, which Ping to fetch.
     */
    where: PingWhereUniqueInput
  }

  /**
   * Ping findFirst
   */
  export type PingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ping
     */
    select?: PingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PingInclude<ExtArgs> | null
    /**
     * Filter, which Ping to fetch.
     */
    where?: PingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pings to fetch.
     */
    orderBy?: PingOrderByWithRelationInput | PingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pings.
     */
    cursor?: PingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pings.
     */
    distinct?: PingScalarFieldEnum | PingScalarFieldEnum[]
  }

  /**
   * Ping findFirstOrThrow
   */
  export type PingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ping
     */
    select?: PingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PingInclude<ExtArgs> | null
    /**
     * Filter, which Ping to fetch.
     */
    where?: PingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pings to fetch.
     */
    orderBy?: PingOrderByWithRelationInput | PingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pings.
     */
    cursor?: PingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pings.
     */
    distinct?: PingScalarFieldEnum | PingScalarFieldEnum[]
  }

  /**
   * Ping findMany
   */
  export type PingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ping
     */
    select?: PingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PingInclude<ExtArgs> | null
    /**
     * Filter, which Pings to fetch.
     */
    where?: PingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pings to fetch.
     */
    orderBy?: PingOrderByWithRelationInput | PingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pings.
     */
    cursor?: PingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pings.
     */
    skip?: number
    distinct?: PingScalarFieldEnum | PingScalarFieldEnum[]
  }

  /**
   * Ping create
   */
  export type PingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ping
     */
    select?: PingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PingInclude<ExtArgs> | null
    /**
     * The data needed to create a Ping.
     */
    data: XOR<PingCreateInput, PingUncheckedCreateInput>
  }

  /**
   * Ping createMany
   */
  export type PingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pings.
     */
    data: PingCreateManyInput | PingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ping createManyAndReturn
   */
  export type PingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ping
     */
    select?: PingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Pings.
     */
    data: PingCreateManyInput | PingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ping update
   */
  export type PingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ping
     */
    select?: PingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PingInclude<ExtArgs> | null
    /**
     * The data needed to update a Ping.
     */
    data: XOR<PingUpdateInput, PingUncheckedUpdateInput>
    /**
     * Choose, which Ping to update.
     */
    where: PingWhereUniqueInput
  }

  /**
   * Ping updateMany
   */
  export type PingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pings.
     */
    data: XOR<PingUpdateManyMutationInput, PingUncheckedUpdateManyInput>
    /**
     * Filter which Pings to update
     */
    where?: PingWhereInput
  }

  /**
   * Ping upsert
   */
  export type PingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ping
     */
    select?: PingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PingInclude<ExtArgs> | null
    /**
     * The filter to search for the Ping to update in case it exists.
     */
    where: PingWhereUniqueInput
    /**
     * In case the Ping found by the `where` argument doesn't exist, create a new Ping with this data.
     */
    create: XOR<PingCreateInput, PingUncheckedCreateInput>
    /**
     * In case the Ping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PingUpdateInput, PingUncheckedUpdateInput>
  }

  /**
   * Ping delete
   */
  export type PingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ping
     */
    select?: PingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PingInclude<ExtArgs> | null
    /**
     * Filter which Ping to delete.
     */
    where: PingWhereUniqueInput
  }

  /**
   * Ping deleteMany
   */
  export type PingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pings to delete
     */
    where?: PingWhereInput
  }

  /**
   * Ping without action
   */
  export type PingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ping
     */
    select?: PingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PingInclude<ExtArgs> | null
  }


  /**
   * Model CheckDailyStat
   */

  export type AggregateCheckDailyStat = {
    _count: CheckDailyStatCountAggregateOutputType | null
    _avg: CheckDailyStatAvgAggregateOutputType | null
    _sum: CheckDailyStatSumAggregateOutputType | null
    _min: CheckDailyStatMinAggregateOutputType | null
    _max: CheckDailyStatMaxAggregateOutputType | null
  }

  export type CheckDailyStatAvgAggregateOutputType = {
    upMinutes: number | null
    downMinutes: number | null
    totalPings: number | null
    upPercent: number | null
  }

  export type CheckDailyStatSumAggregateOutputType = {
    upMinutes: number | null
    downMinutes: number | null
    totalPings: number | null
    upPercent: number | null
  }

  export type CheckDailyStatMinAggregateOutputType = {
    id: string | null
    checkId: string | null
    date: Date | null
    upMinutes: number | null
    downMinutes: number | null
    totalPings: number | null
    upPercent: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CheckDailyStatMaxAggregateOutputType = {
    id: string | null
    checkId: string | null
    date: Date | null
    upMinutes: number | null
    downMinutes: number | null
    totalPings: number | null
    upPercent: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CheckDailyStatCountAggregateOutputType = {
    id: number
    checkId: number
    date: number
    upMinutes: number
    downMinutes: number
    totalPings: number
    upPercent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CheckDailyStatAvgAggregateInputType = {
    upMinutes?: true
    downMinutes?: true
    totalPings?: true
    upPercent?: true
  }

  export type CheckDailyStatSumAggregateInputType = {
    upMinutes?: true
    downMinutes?: true
    totalPings?: true
    upPercent?: true
  }

  export type CheckDailyStatMinAggregateInputType = {
    id?: true
    checkId?: true
    date?: true
    upMinutes?: true
    downMinutes?: true
    totalPings?: true
    upPercent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CheckDailyStatMaxAggregateInputType = {
    id?: true
    checkId?: true
    date?: true
    upMinutes?: true
    downMinutes?: true
    totalPings?: true
    upPercent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CheckDailyStatCountAggregateInputType = {
    id?: true
    checkId?: true
    date?: true
    upMinutes?: true
    downMinutes?: true
    totalPings?: true
    upPercent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CheckDailyStatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CheckDailyStat to aggregate.
     */
    where?: CheckDailyStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckDailyStats to fetch.
     */
    orderBy?: CheckDailyStatOrderByWithRelationInput | CheckDailyStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CheckDailyStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckDailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckDailyStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CheckDailyStats
    **/
    _count?: true | CheckDailyStatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CheckDailyStatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CheckDailyStatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CheckDailyStatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CheckDailyStatMaxAggregateInputType
  }

  export type GetCheckDailyStatAggregateType<T extends CheckDailyStatAggregateArgs> = {
        [P in keyof T & keyof AggregateCheckDailyStat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCheckDailyStat[P]>
      : GetScalarType<T[P], AggregateCheckDailyStat[P]>
  }




  export type CheckDailyStatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckDailyStatWhereInput
    orderBy?: CheckDailyStatOrderByWithAggregationInput | CheckDailyStatOrderByWithAggregationInput[]
    by: CheckDailyStatScalarFieldEnum[] | CheckDailyStatScalarFieldEnum
    having?: CheckDailyStatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CheckDailyStatCountAggregateInputType | true
    _avg?: CheckDailyStatAvgAggregateInputType
    _sum?: CheckDailyStatSumAggregateInputType
    _min?: CheckDailyStatMinAggregateInputType
    _max?: CheckDailyStatMaxAggregateInputType
  }

  export type CheckDailyStatGroupByOutputType = {
    id: string
    checkId: string
    date: Date
    upMinutes: number
    downMinutes: number
    totalPings: number
    upPercent: number
    createdAt: Date
    updatedAt: Date
    _count: CheckDailyStatCountAggregateOutputType | null
    _avg: CheckDailyStatAvgAggregateOutputType | null
    _sum: CheckDailyStatSumAggregateOutputType | null
    _min: CheckDailyStatMinAggregateOutputType | null
    _max: CheckDailyStatMaxAggregateOutputType | null
  }

  type GetCheckDailyStatGroupByPayload<T extends CheckDailyStatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CheckDailyStatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CheckDailyStatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CheckDailyStatGroupByOutputType[P]>
            : GetScalarType<T[P], CheckDailyStatGroupByOutputType[P]>
        }
      >
    >


  export type CheckDailyStatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    checkId?: boolean
    date?: boolean
    upMinutes?: boolean
    downMinutes?: boolean
    totalPings?: boolean
    upPercent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    check?: boolean | CheckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checkDailyStat"]>

  export type CheckDailyStatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    checkId?: boolean
    date?: boolean
    upMinutes?: boolean
    downMinutes?: boolean
    totalPings?: boolean
    upPercent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    check?: boolean | CheckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checkDailyStat"]>

  export type CheckDailyStatSelectScalar = {
    id?: boolean
    checkId?: boolean
    date?: boolean
    upMinutes?: boolean
    downMinutes?: boolean
    totalPings?: boolean
    upPercent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CheckDailyStatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    check?: boolean | CheckDefaultArgs<ExtArgs>
  }
  export type CheckDailyStatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    check?: boolean | CheckDefaultArgs<ExtArgs>
  }

  export type $CheckDailyStatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CheckDailyStat"
    objects: {
      check: Prisma.$CheckPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      checkId: string
      date: Date
      upMinutes: number
      downMinutes: number
      totalPings: number
      upPercent: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["checkDailyStat"]>
    composites: {}
  }

  type CheckDailyStatGetPayload<S extends boolean | null | undefined | CheckDailyStatDefaultArgs> = $Result.GetResult<Prisma.$CheckDailyStatPayload, S>

  type CheckDailyStatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CheckDailyStatFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CheckDailyStatCountAggregateInputType | true
    }

  export interface CheckDailyStatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CheckDailyStat'], meta: { name: 'CheckDailyStat' } }
    /**
     * Find zero or one CheckDailyStat that matches the filter.
     * @param {CheckDailyStatFindUniqueArgs} args - Arguments to find a CheckDailyStat
     * @example
     * // Get one CheckDailyStat
     * const checkDailyStat = await prisma.checkDailyStat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CheckDailyStatFindUniqueArgs>(args: SelectSubset<T, CheckDailyStatFindUniqueArgs<ExtArgs>>): Prisma__CheckDailyStatClient<$Result.GetResult<Prisma.$CheckDailyStatPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CheckDailyStat that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CheckDailyStatFindUniqueOrThrowArgs} args - Arguments to find a CheckDailyStat
     * @example
     * // Get one CheckDailyStat
     * const checkDailyStat = await prisma.checkDailyStat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CheckDailyStatFindUniqueOrThrowArgs>(args: SelectSubset<T, CheckDailyStatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CheckDailyStatClient<$Result.GetResult<Prisma.$CheckDailyStatPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CheckDailyStat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckDailyStatFindFirstArgs} args - Arguments to find a CheckDailyStat
     * @example
     * // Get one CheckDailyStat
     * const checkDailyStat = await prisma.checkDailyStat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CheckDailyStatFindFirstArgs>(args?: SelectSubset<T, CheckDailyStatFindFirstArgs<ExtArgs>>): Prisma__CheckDailyStatClient<$Result.GetResult<Prisma.$CheckDailyStatPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CheckDailyStat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckDailyStatFindFirstOrThrowArgs} args - Arguments to find a CheckDailyStat
     * @example
     * // Get one CheckDailyStat
     * const checkDailyStat = await prisma.checkDailyStat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CheckDailyStatFindFirstOrThrowArgs>(args?: SelectSubset<T, CheckDailyStatFindFirstOrThrowArgs<ExtArgs>>): Prisma__CheckDailyStatClient<$Result.GetResult<Prisma.$CheckDailyStatPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CheckDailyStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckDailyStatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CheckDailyStats
     * const checkDailyStats = await prisma.checkDailyStat.findMany()
     * 
     * // Get first 10 CheckDailyStats
     * const checkDailyStats = await prisma.checkDailyStat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const checkDailyStatWithIdOnly = await prisma.checkDailyStat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CheckDailyStatFindManyArgs>(args?: SelectSubset<T, CheckDailyStatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckDailyStatPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CheckDailyStat.
     * @param {CheckDailyStatCreateArgs} args - Arguments to create a CheckDailyStat.
     * @example
     * // Create one CheckDailyStat
     * const CheckDailyStat = await prisma.checkDailyStat.create({
     *   data: {
     *     // ... data to create a CheckDailyStat
     *   }
     * })
     * 
     */
    create<T extends CheckDailyStatCreateArgs>(args: SelectSubset<T, CheckDailyStatCreateArgs<ExtArgs>>): Prisma__CheckDailyStatClient<$Result.GetResult<Prisma.$CheckDailyStatPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CheckDailyStats.
     * @param {CheckDailyStatCreateManyArgs} args - Arguments to create many CheckDailyStats.
     * @example
     * // Create many CheckDailyStats
     * const checkDailyStat = await prisma.checkDailyStat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CheckDailyStatCreateManyArgs>(args?: SelectSubset<T, CheckDailyStatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CheckDailyStats and returns the data saved in the database.
     * @param {CheckDailyStatCreateManyAndReturnArgs} args - Arguments to create many CheckDailyStats.
     * @example
     * // Create many CheckDailyStats
     * const checkDailyStat = await prisma.checkDailyStat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CheckDailyStats and only return the `id`
     * const checkDailyStatWithIdOnly = await prisma.checkDailyStat.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CheckDailyStatCreateManyAndReturnArgs>(args?: SelectSubset<T, CheckDailyStatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckDailyStatPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CheckDailyStat.
     * @param {CheckDailyStatDeleteArgs} args - Arguments to delete one CheckDailyStat.
     * @example
     * // Delete one CheckDailyStat
     * const CheckDailyStat = await prisma.checkDailyStat.delete({
     *   where: {
     *     // ... filter to delete one CheckDailyStat
     *   }
     * })
     * 
     */
    delete<T extends CheckDailyStatDeleteArgs>(args: SelectSubset<T, CheckDailyStatDeleteArgs<ExtArgs>>): Prisma__CheckDailyStatClient<$Result.GetResult<Prisma.$CheckDailyStatPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CheckDailyStat.
     * @param {CheckDailyStatUpdateArgs} args - Arguments to update one CheckDailyStat.
     * @example
     * // Update one CheckDailyStat
     * const checkDailyStat = await prisma.checkDailyStat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CheckDailyStatUpdateArgs>(args: SelectSubset<T, CheckDailyStatUpdateArgs<ExtArgs>>): Prisma__CheckDailyStatClient<$Result.GetResult<Prisma.$CheckDailyStatPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CheckDailyStats.
     * @param {CheckDailyStatDeleteManyArgs} args - Arguments to filter CheckDailyStats to delete.
     * @example
     * // Delete a few CheckDailyStats
     * const { count } = await prisma.checkDailyStat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CheckDailyStatDeleteManyArgs>(args?: SelectSubset<T, CheckDailyStatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CheckDailyStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckDailyStatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CheckDailyStats
     * const checkDailyStat = await prisma.checkDailyStat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CheckDailyStatUpdateManyArgs>(args: SelectSubset<T, CheckDailyStatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CheckDailyStat.
     * @param {CheckDailyStatUpsertArgs} args - Arguments to update or create a CheckDailyStat.
     * @example
     * // Update or create a CheckDailyStat
     * const checkDailyStat = await prisma.checkDailyStat.upsert({
     *   create: {
     *     // ... data to create a CheckDailyStat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CheckDailyStat we want to update
     *   }
     * })
     */
    upsert<T extends CheckDailyStatUpsertArgs>(args: SelectSubset<T, CheckDailyStatUpsertArgs<ExtArgs>>): Prisma__CheckDailyStatClient<$Result.GetResult<Prisma.$CheckDailyStatPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CheckDailyStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckDailyStatCountArgs} args - Arguments to filter CheckDailyStats to count.
     * @example
     * // Count the number of CheckDailyStats
     * const count = await prisma.checkDailyStat.count({
     *   where: {
     *     // ... the filter for the CheckDailyStats we want to count
     *   }
     * })
    **/
    count<T extends CheckDailyStatCountArgs>(
      args?: Subset<T, CheckDailyStatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CheckDailyStatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CheckDailyStat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckDailyStatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CheckDailyStatAggregateArgs>(args: Subset<T, CheckDailyStatAggregateArgs>): Prisma.PrismaPromise<GetCheckDailyStatAggregateType<T>>

    /**
     * Group by CheckDailyStat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckDailyStatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CheckDailyStatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CheckDailyStatGroupByArgs['orderBy'] }
        : { orderBy?: CheckDailyStatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CheckDailyStatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCheckDailyStatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CheckDailyStat model
   */
  readonly fields: CheckDailyStatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CheckDailyStat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CheckDailyStatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    check<T extends CheckDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CheckDefaultArgs<ExtArgs>>): Prisma__CheckClient<$Result.GetResult<Prisma.$CheckPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CheckDailyStat model
   */ 
  interface CheckDailyStatFieldRefs {
    readonly id: FieldRef<"CheckDailyStat", 'String'>
    readonly checkId: FieldRef<"CheckDailyStat", 'String'>
    readonly date: FieldRef<"CheckDailyStat", 'DateTime'>
    readonly upMinutes: FieldRef<"CheckDailyStat", 'Int'>
    readonly downMinutes: FieldRef<"CheckDailyStat", 'Int'>
    readonly totalPings: FieldRef<"CheckDailyStat", 'Int'>
    readonly upPercent: FieldRef<"CheckDailyStat", 'Float'>
    readonly createdAt: FieldRef<"CheckDailyStat", 'DateTime'>
    readonly updatedAt: FieldRef<"CheckDailyStat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CheckDailyStat findUnique
   */
  export type CheckDailyStatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckDailyStat
     */
    select?: CheckDailyStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckDailyStatInclude<ExtArgs> | null
    /**
     * Filter, which CheckDailyStat to fetch.
     */
    where: CheckDailyStatWhereUniqueInput
  }

  /**
   * CheckDailyStat findUniqueOrThrow
   */
  export type CheckDailyStatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckDailyStat
     */
    select?: CheckDailyStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckDailyStatInclude<ExtArgs> | null
    /**
     * Filter, which CheckDailyStat to fetch.
     */
    where: CheckDailyStatWhereUniqueInput
  }

  /**
   * CheckDailyStat findFirst
   */
  export type CheckDailyStatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckDailyStat
     */
    select?: CheckDailyStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckDailyStatInclude<ExtArgs> | null
    /**
     * Filter, which CheckDailyStat to fetch.
     */
    where?: CheckDailyStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckDailyStats to fetch.
     */
    orderBy?: CheckDailyStatOrderByWithRelationInput | CheckDailyStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CheckDailyStats.
     */
    cursor?: CheckDailyStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckDailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckDailyStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CheckDailyStats.
     */
    distinct?: CheckDailyStatScalarFieldEnum | CheckDailyStatScalarFieldEnum[]
  }

  /**
   * CheckDailyStat findFirstOrThrow
   */
  export type CheckDailyStatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckDailyStat
     */
    select?: CheckDailyStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckDailyStatInclude<ExtArgs> | null
    /**
     * Filter, which CheckDailyStat to fetch.
     */
    where?: CheckDailyStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckDailyStats to fetch.
     */
    orderBy?: CheckDailyStatOrderByWithRelationInput | CheckDailyStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CheckDailyStats.
     */
    cursor?: CheckDailyStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckDailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckDailyStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CheckDailyStats.
     */
    distinct?: CheckDailyStatScalarFieldEnum | CheckDailyStatScalarFieldEnum[]
  }

  /**
   * CheckDailyStat findMany
   */
  export type CheckDailyStatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckDailyStat
     */
    select?: CheckDailyStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckDailyStatInclude<ExtArgs> | null
    /**
     * Filter, which CheckDailyStats to fetch.
     */
    where?: CheckDailyStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckDailyStats to fetch.
     */
    orderBy?: CheckDailyStatOrderByWithRelationInput | CheckDailyStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CheckDailyStats.
     */
    cursor?: CheckDailyStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckDailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckDailyStats.
     */
    skip?: number
    distinct?: CheckDailyStatScalarFieldEnum | CheckDailyStatScalarFieldEnum[]
  }

  /**
   * CheckDailyStat create
   */
  export type CheckDailyStatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckDailyStat
     */
    select?: CheckDailyStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckDailyStatInclude<ExtArgs> | null
    /**
     * The data needed to create a CheckDailyStat.
     */
    data: XOR<CheckDailyStatCreateInput, CheckDailyStatUncheckedCreateInput>
  }

  /**
   * CheckDailyStat createMany
   */
  export type CheckDailyStatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CheckDailyStats.
     */
    data: CheckDailyStatCreateManyInput | CheckDailyStatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CheckDailyStat createManyAndReturn
   */
  export type CheckDailyStatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckDailyStat
     */
    select?: CheckDailyStatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CheckDailyStats.
     */
    data: CheckDailyStatCreateManyInput | CheckDailyStatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckDailyStatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CheckDailyStat update
   */
  export type CheckDailyStatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckDailyStat
     */
    select?: CheckDailyStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckDailyStatInclude<ExtArgs> | null
    /**
     * The data needed to update a CheckDailyStat.
     */
    data: XOR<CheckDailyStatUpdateInput, CheckDailyStatUncheckedUpdateInput>
    /**
     * Choose, which CheckDailyStat to update.
     */
    where: CheckDailyStatWhereUniqueInput
  }

  /**
   * CheckDailyStat updateMany
   */
  export type CheckDailyStatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CheckDailyStats.
     */
    data: XOR<CheckDailyStatUpdateManyMutationInput, CheckDailyStatUncheckedUpdateManyInput>
    /**
     * Filter which CheckDailyStats to update
     */
    where?: CheckDailyStatWhereInput
  }

  /**
   * CheckDailyStat upsert
   */
  export type CheckDailyStatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckDailyStat
     */
    select?: CheckDailyStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckDailyStatInclude<ExtArgs> | null
    /**
     * The filter to search for the CheckDailyStat to update in case it exists.
     */
    where: CheckDailyStatWhereUniqueInput
    /**
     * In case the CheckDailyStat found by the `where` argument doesn't exist, create a new CheckDailyStat with this data.
     */
    create: XOR<CheckDailyStatCreateInput, CheckDailyStatUncheckedCreateInput>
    /**
     * In case the CheckDailyStat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CheckDailyStatUpdateInput, CheckDailyStatUncheckedUpdateInput>
  }

  /**
   * CheckDailyStat delete
   */
  export type CheckDailyStatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckDailyStat
     */
    select?: CheckDailyStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckDailyStatInclude<ExtArgs> | null
    /**
     * Filter which CheckDailyStat to delete.
     */
    where: CheckDailyStatWhereUniqueInput
  }

  /**
   * CheckDailyStat deleteMany
   */
  export type CheckDailyStatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CheckDailyStats to delete
     */
    where?: CheckDailyStatWhereInput
  }

  /**
   * CheckDailyStat without action
   */
  export type CheckDailyStatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckDailyStat
     */
    select?: CheckDailyStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckDailyStatInclude<ExtArgs> | null
  }


  /**
   * Model Channel
   */

  export type AggregateChannel = {
    _count: ChannelCountAggregateOutputType | null
    _min: ChannelMinAggregateOutputType | null
    _max: ChannelMaxAggregateOutputType | null
  }

  export type ChannelMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    type: $Enums.ChannelType | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChannelMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    type: $Enums.ChannelType | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChannelCountAggregateOutputType = {
    id: number
    projectId: number
    type: number
    name: number
    config: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChannelMinAggregateInputType = {
    id?: true
    projectId?: true
    type?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChannelMaxAggregateInputType = {
    id?: true
    projectId?: true
    type?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChannelCountAggregateInputType = {
    id?: true
    projectId?: true
    type?: true
    name?: true
    config?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChannelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Channel to aggregate.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Channels
    **/
    _count?: true | ChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelMaxAggregateInputType
  }

  export type GetChannelAggregateType<T extends ChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannel[P]>
      : GetScalarType<T[P], AggregateChannel[P]>
  }




  export type ChannelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelWhereInput
    orderBy?: ChannelOrderByWithAggregationInput | ChannelOrderByWithAggregationInput[]
    by: ChannelScalarFieldEnum[] | ChannelScalarFieldEnum
    having?: ChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelCountAggregateInputType | true
    _min?: ChannelMinAggregateInputType
    _max?: ChannelMaxAggregateInputType
  }

  export type ChannelGroupByOutputType = {
    id: string
    projectId: string
    type: $Enums.ChannelType
    name: string
    config: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: ChannelCountAggregateOutputType | null
    _min: ChannelMinAggregateOutputType | null
    _max: ChannelMaxAggregateOutputType | null
  }

  type GetChannelGroupByPayload<T extends ChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChannelGroupByOutputType[P]>
            : GetScalarType<T[P], ChannelGroupByOutputType[P]>
        }
      >
    >


  export type ChannelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    type?: boolean
    name?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    checkChannels?: boolean | Channel$checkChannelsArgs<ExtArgs>
    _count?: boolean | ChannelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channel"]>

  export type ChannelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    type?: boolean
    name?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channel"]>

  export type ChannelSelectScalar = {
    id?: boolean
    projectId?: boolean
    type?: boolean
    name?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChannelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    checkChannels?: boolean | Channel$checkChannelsArgs<ExtArgs>
    _count?: boolean | ChannelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChannelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ChannelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Channel"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      checkChannels: Prisma.$CheckChannelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      type: $Enums.ChannelType
      name: string
      config: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["channel"]>
    composites: {}
  }

  type ChannelGetPayload<S extends boolean | null | undefined | ChannelDefaultArgs> = $Result.GetResult<Prisma.$ChannelPayload, S>

  type ChannelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChannelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChannelCountAggregateInputType | true
    }

  export interface ChannelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Channel'], meta: { name: 'Channel' } }
    /**
     * Find zero or one Channel that matches the filter.
     * @param {ChannelFindUniqueArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChannelFindUniqueArgs>(args: SelectSubset<T, ChannelFindUniqueArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Channel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChannelFindUniqueOrThrowArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChannelFindUniqueOrThrowArgs>(args: SelectSubset<T, ChannelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Channel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindFirstArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChannelFindFirstArgs>(args?: SelectSubset<T, ChannelFindFirstArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Channel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindFirstOrThrowArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChannelFindFirstOrThrowArgs>(args?: SelectSubset<T, ChannelFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Channels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Channels
     * const channels = await prisma.channel.findMany()
     * 
     * // Get first 10 Channels
     * const channels = await prisma.channel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelWithIdOnly = await prisma.channel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChannelFindManyArgs>(args?: SelectSubset<T, ChannelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Channel.
     * @param {ChannelCreateArgs} args - Arguments to create a Channel.
     * @example
     * // Create one Channel
     * const Channel = await prisma.channel.create({
     *   data: {
     *     // ... data to create a Channel
     *   }
     * })
     * 
     */
    create<T extends ChannelCreateArgs>(args: SelectSubset<T, ChannelCreateArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Channels.
     * @param {ChannelCreateManyArgs} args - Arguments to create many Channels.
     * @example
     * // Create many Channels
     * const channel = await prisma.channel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChannelCreateManyArgs>(args?: SelectSubset<T, ChannelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Channels and returns the data saved in the database.
     * @param {ChannelCreateManyAndReturnArgs} args - Arguments to create many Channels.
     * @example
     * // Create many Channels
     * const channel = await prisma.channel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Channels and only return the `id`
     * const channelWithIdOnly = await prisma.channel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChannelCreateManyAndReturnArgs>(args?: SelectSubset<T, ChannelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Channel.
     * @param {ChannelDeleteArgs} args - Arguments to delete one Channel.
     * @example
     * // Delete one Channel
     * const Channel = await prisma.channel.delete({
     *   where: {
     *     // ... filter to delete one Channel
     *   }
     * })
     * 
     */
    delete<T extends ChannelDeleteArgs>(args: SelectSubset<T, ChannelDeleteArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Channel.
     * @param {ChannelUpdateArgs} args - Arguments to update one Channel.
     * @example
     * // Update one Channel
     * const channel = await prisma.channel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChannelUpdateArgs>(args: SelectSubset<T, ChannelUpdateArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Channels.
     * @param {ChannelDeleteManyArgs} args - Arguments to filter Channels to delete.
     * @example
     * // Delete a few Channels
     * const { count } = await prisma.channel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChannelDeleteManyArgs>(args?: SelectSubset<T, ChannelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Channels
     * const channel = await prisma.channel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChannelUpdateManyArgs>(args: SelectSubset<T, ChannelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Channel.
     * @param {ChannelUpsertArgs} args - Arguments to update or create a Channel.
     * @example
     * // Update or create a Channel
     * const channel = await prisma.channel.upsert({
     *   create: {
     *     // ... data to create a Channel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Channel we want to update
     *   }
     * })
     */
    upsert<T extends ChannelUpsertArgs>(args: SelectSubset<T, ChannelUpsertArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCountArgs} args - Arguments to filter Channels to count.
     * @example
     * // Count the number of Channels
     * const count = await prisma.channel.count({
     *   where: {
     *     // ... the filter for the Channels we want to count
     *   }
     * })
    **/
    count<T extends ChannelCountArgs>(
      args?: Subset<T, ChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Channel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelAggregateArgs>(args: Subset<T, ChannelAggregateArgs>): Prisma.PrismaPromise<GetChannelAggregateType<T>>

    /**
     * Group by Channel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChannelGroupByArgs['orderBy'] }
        : { orderBy?: ChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Channel model
   */
  readonly fields: ChannelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Channel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChannelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    checkChannels<T extends Channel$checkChannelsArgs<ExtArgs> = {}>(args?: Subset<T, Channel$checkChannelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckChannelPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Channel model
   */ 
  interface ChannelFieldRefs {
    readonly id: FieldRef<"Channel", 'String'>
    readonly projectId: FieldRef<"Channel", 'String'>
    readonly type: FieldRef<"Channel", 'ChannelType'>
    readonly name: FieldRef<"Channel", 'String'>
    readonly config: FieldRef<"Channel", 'Json'>
    readonly createdAt: FieldRef<"Channel", 'DateTime'>
    readonly updatedAt: FieldRef<"Channel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Channel findUnique
   */
  export type ChannelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel findUniqueOrThrow
   */
  export type ChannelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel findFirst
   */
  export type ChannelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Channels.
     */
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Channel findFirstOrThrow
   */
  export type ChannelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Channels.
     */
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Channel findMany
   */
  export type ChannelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channels to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Channel create
   */
  export type ChannelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * The data needed to create a Channel.
     */
    data: XOR<ChannelCreateInput, ChannelUncheckedCreateInput>
  }

  /**
   * Channel createMany
   */
  export type ChannelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Channels.
     */
    data: ChannelCreateManyInput | ChannelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Channel createManyAndReturn
   */
  export type ChannelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Channels.
     */
    data: ChannelCreateManyInput | ChannelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Channel update
   */
  export type ChannelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * The data needed to update a Channel.
     */
    data: XOR<ChannelUpdateInput, ChannelUncheckedUpdateInput>
    /**
     * Choose, which Channel to update.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel updateMany
   */
  export type ChannelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Channels.
     */
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyInput>
    /**
     * Filter which Channels to update
     */
    where?: ChannelWhereInput
  }

  /**
   * Channel upsert
   */
  export type ChannelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * The filter to search for the Channel to update in case it exists.
     */
    where: ChannelWhereUniqueInput
    /**
     * In case the Channel found by the `where` argument doesn't exist, create a new Channel with this data.
     */
    create: XOR<ChannelCreateInput, ChannelUncheckedCreateInput>
    /**
     * In case the Channel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChannelUpdateInput, ChannelUncheckedUpdateInput>
  }

  /**
   * Channel delete
   */
  export type ChannelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter which Channel to delete.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel deleteMany
   */
  export type ChannelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Channels to delete
     */
    where?: ChannelWhereInput
  }

  /**
   * Channel.checkChannels
   */
  export type Channel$checkChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckChannel
     */
    select?: CheckChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckChannelInclude<ExtArgs> | null
    where?: CheckChannelWhereInput
    orderBy?: CheckChannelOrderByWithRelationInput | CheckChannelOrderByWithRelationInput[]
    cursor?: CheckChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CheckChannelScalarFieldEnum | CheckChannelScalarFieldEnum[]
  }

  /**
   * Channel without action
   */
  export type ChannelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
  }


  /**
   * Model CheckChannel
   */

  export type AggregateCheckChannel = {
    _count: CheckChannelCountAggregateOutputType | null
    _min: CheckChannelMinAggregateOutputType | null
    _max: CheckChannelMaxAggregateOutputType | null
  }

  export type CheckChannelMinAggregateOutputType = {
    checkId: string | null
    channelId: string | null
  }

  export type CheckChannelMaxAggregateOutputType = {
    checkId: string | null
    channelId: string | null
  }

  export type CheckChannelCountAggregateOutputType = {
    checkId: number
    channelId: number
    _all: number
  }


  export type CheckChannelMinAggregateInputType = {
    checkId?: true
    channelId?: true
  }

  export type CheckChannelMaxAggregateInputType = {
    checkId?: true
    channelId?: true
  }

  export type CheckChannelCountAggregateInputType = {
    checkId?: true
    channelId?: true
    _all?: true
  }

  export type CheckChannelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CheckChannel to aggregate.
     */
    where?: CheckChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckChannels to fetch.
     */
    orderBy?: CheckChannelOrderByWithRelationInput | CheckChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CheckChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CheckChannels
    **/
    _count?: true | CheckChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CheckChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CheckChannelMaxAggregateInputType
  }

  export type GetCheckChannelAggregateType<T extends CheckChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateCheckChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCheckChannel[P]>
      : GetScalarType<T[P], AggregateCheckChannel[P]>
  }




  export type CheckChannelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckChannelWhereInput
    orderBy?: CheckChannelOrderByWithAggregationInput | CheckChannelOrderByWithAggregationInput[]
    by: CheckChannelScalarFieldEnum[] | CheckChannelScalarFieldEnum
    having?: CheckChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CheckChannelCountAggregateInputType | true
    _min?: CheckChannelMinAggregateInputType
    _max?: CheckChannelMaxAggregateInputType
  }

  export type CheckChannelGroupByOutputType = {
    checkId: string
    channelId: string
    _count: CheckChannelCountAggregateOutputType | null
    _min: CheckChannelMinAggregateOutputType | null
    _max: CheckChannelMaxAggregateOutputType | null
  }

  type GetCheckChannelGroupByPayload<T extends CheckChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CheckChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CheckChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CheckChannelGroupByOutputType[P]>
            : GetScalarType<T[P], CheckChannelGroupByOutputType[P]>
        }
      >
    >


  export type CheckChannelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    checkId?: boolean
    channelId?: boolean
    check?: boolean | CheckDefaultArgs<ExtArgs>
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checkChannel"]>

  export type CheckChannelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    checkId?: boolean
    channelId?: boolean
    check?: boolean | CheckDefaultArgs<ExtArgs>
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checkChannel"]>

  export type CheckChannelSelectScalar = {
    checkId?: boolean
    channelId?: boolean
  }

  export type CheckChannelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    check?: boolean | CheckDefaultArgs<ExtArgs>
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
  }
  export type CheckChannelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    check?: boolean | CheckDefaultArgs<ExtArgs>
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
  }

  export type $CheckChannelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CheckChannel"
    objects: {
      check: Prisma.$CheckPayload<ExtArgs>
      channel: Prisma.$ChannelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      checkId: string
      channelId: string
    }, ExtArgs["result"]["checkChannel"]>
    composites: {}
  }

  type CheckChannelGetPayload<S extends boolean | null | undefined | CheckChannelDefaultArgs> = $Result.GetResult<Prisma.$CheckChannelPayload, S>

  type CheckChannelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CheckChannelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CheckChannelCountAggregateInputType | true
    }

  export interface CheckChannelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CheckChannel'], meta: { name: 'CheckChannel' } }
    /**
     * Find zero or one CheckChannel that matches the filter.
     * @param {CheckChannelFindUniqueArgs} args - Arguments to find a CheckChannel
     * @example
     * // Get one CheckChannel
     * const checkChannel = await prisma.checkChannel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CheckChannelFindUniqueArgs>(args: SelectSubset<T, CheckChannelFindUniqueArgs<ExtArgs>>): Prisma__CheckChannelClient<$Result.GetResult<Prisma.$CheckChannelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CheckChannel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CheckChannelFindUniqueOrThrowArgs} args - Arguments to find a CheckChannel
     * @example
     * // Get one CheckChannel
     * const checkChannel = await prisma.checkChannel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CheckChannelFindUniqueOrThrowArgs>(args: SelectSubset<T, CheckChannelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CheckChannelClient<$Result.GetResult<Prisma.$CheckChannelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CheckChannel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckChannelFindFirstArgs} args - Arguments to find a CheckChannel
     * @example
     * // Get one CheckChannel
     * const checkChannel = await prisma.checkChannel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CheckChannelFindFirstArgs>(args?: SelectSubset<T, CheckChannelFindFirstArgs<ExtArgs>>): Prisma__CheckChannelClient<$Result.GetResult<Prisma.$CheckChannelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CheckChannel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckChannelFindFirstOrThrowArgs} args - Arguments to find a CheckChannel
     * @example
     * // Get one CheckChannel
     * const checkChannel = await prisma.checkChannel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CheckChannelFindFirstOrThrowArgs>(args?: SelectSubset<T, CheckChannelFindFirstOrThrowArgs<ExtArgs>>): Prisma__CheckChannelClient<$Result.GetResult<Prisma.$CheckChannelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CheckChannels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckChannelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CheckChannels
     * const checkChannels = await prisma.checkChannel.findMany()
     * 
     * // Get first 10 CheckChannels
     * const checkChannels = await prisma.checkChannel.findMany({ take: 10 })
     * 
     * // Only select the `checkId`
     * const checkChannelWithCheckIdOnly = await prisma.checkChannel.findMany({ select: { checkId: true } })
     * 
     */
    findMany<T extends CheckChannelFindManyArgs>(args?: SelectSubset<T, CheckChannelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckChannelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CheckChannel.
     * @param {CheckChannelCreateArgs} args - Arguments to create a CheckChannel.
     * @example
     * // Create one CheckChannel
     * const CheckChannel = await prisma.checkChannel.create({
     *   data: {
     *     // ... data to create a CheckChannel
     *   }
     * })
     * 
     */
    create<T extends CheckChannelCreateArgs>(args: SelectSubset<T, CheckChannelCreateArgs<ExtArgs>>): Prisma__CheckChannelClient<$Result.GetResult<Prisma.$CheckChannelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CheckChannels.
     * @param {CheckChannelCreateManyArgs} args - Arguments to create many CheckChannels.
     * @example
     * // Create many CheckChannels
     * const checkChannel = await prisma.checkChannel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CheckChannelCreateManyArgs>(args?: SelectSubset<T, CheckChannelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CheckChannels and returns the data saved in the database.
     * @param {CheckChannelCreateManyAndReturnArgs} args - Arguments to create many CheckChannels.
     * @example
     * // Create many CheckChannels
     * const checkChannel = await prisma.checkChannel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CheckChannels and only return the `checkId`
     * const checkChannelWithCheckIdOnly = await prisma.checkChannel.createManyAndReturn({ 
     *   select: { checkId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CheckChannelCreateManyAndReturnArgs>(args?: SelectSubset<T, CheckChannelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckChannelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CheckChannel.
     * @param {CheckChannelDeleteArgs} args - Arguments to delete one CheckChannel.
     * @example
     * // Delete one CheckChannel
     * const CheckChannel = await prisma.checkChannel.delete({
     *   where: {
     *     // ... filter to delete one CheckChannel
     *   }
     * })
     * 
     */
    delete<T extends CheckChannelDeleteArgs>(args: SelectSubset<T, CheckChannelDeleteArgs<ExtArgs>>): Prisma__CheckChannelClient<$Result.GetResult<Prisma.$CheckChannelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CheckChannel.
     * @param {CheckChannelUpdateArgs} args - Arguments to update one CheckChannel.
     * @example
     * // Update one CheckChannel
     * const checkChannel = await prisma.checkChannel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CheckChannelUpdateArgs>(args: SelectSubset<T, CheckChannelUpdateArgs<ExtArgs>>): Prisma__CheckChannelClient<$Result.GetResult<Prisma.$CheckChannelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CheckChannels.
     * @param {CheckChannelDeleteManyArgs} args - Arguments to filter CheckChannels to delete.
     * @example
     * // Delete a few CheckChannels
     * const { count } = await prisma.checkChannel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CheckChannelDeleteManyArgs>(args?: SelectSubset<T, CheckChannelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CheckChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CheckChannels
     * const checkChannel = await prisma.checkChannel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CheckChannelUpdateManyArgs>(args: SelectSubset<T, CheckChannelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CheckChannel.
     * @param {CheckChannelUpsertArgs} args - Arguments to update or create a CheckChannel.
     * @example
     * // Update or create a CheckChannel
     * const checkChannel = await prisma.checkChannel.upsert({
     *   create: {
     *     // ... data to create a CheckChannel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CheckChannel we want to update
     *   }
     * })
     */
    upsert<T extends CheckChannelUpsertArgs>(args: SelectSubset<T, CheckChannelUpsertArgs<ExtArgs>>): Prisma__CheckChannelClient<$Result.GetResult<Prisma.$CheckChannelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CheckChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckChannelCountArgs} args - Arguments to filter CheckChannels to count.
     * @example
     * // Count the number of CheckChannels
     * const count = await prisma.checkChannel.count({
     *   where: {
     *     // ... the filter for the CheckChannels we want to count
     *   }
     * })
    **/
    count<T extends CheckChannelCountArgs>(
      args?: Subset<T, CheckChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CheckChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CheckChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CheckChannelAggregateArgs>(args: Subset<T, CheckChannelAggregateArgs>): Prisma.PrismaPromise<GetCheckChannelAggregateType<T>>

    /**
     * Group by CheckChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CheckChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CheckChannelGroupByArgs['orderBy'] }
        : { orderBy?: CheckChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CheckChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCheckChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CheckChannel model
   */
  readonly fields: CheckChannelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CheckChannel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CheckChannelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    check<T extends CheckDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CheckDefaultArgs<ExtArgs>>): Prisma__CheckClient<$Result.GetResult<Prisma.$CheckPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    channel<T extends ChannelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChannelDefaultArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CheckChannel model
   */ 
  interface CheckChannelFieldRefs {
    readonly checkId: FieldRef<"CheckChannel", 'String'>
    readonly channelId: FieldRef<"CheckChannel", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CheckChannel findUnique
   */
  export type CheckChannelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckChannel
     */
    select?: CheckChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckChannelInclude<ExtArgs> | null
    /**
     * Filter, which CheckChannel to fetch.
     */
    where: CheckChannelWhereUniqueInput
  }

  /**
   * CheckChannel findUniqueOrThrow
   */
  export type CheckChannelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckChannel
     */
    select?: CheckChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckChannelInclude<ExtArgs> | null
    /**
     * Filter, which CheckChannel to fetch.
     */
    where: CheckChannelWhereUniqueInput
  }

  /**
   * CheckChannel findFirst
   */
  export type CheckChannelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckChannel
     */
    select?: CheckChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckChannelInclude<ExtArgs> | null
    /**
     * Filter, which CheckChannel to fetch.
     */
    where?: CheckChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckChannels to fetch.
     */
    orderBy?: CheckChannelOrderByWithRelationInput | CheckChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CheckChannels.
     */
    cursor?: CheckChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CheckChannels.
     */
    distinct?: CheckChannelScalarFieldEnum | CheckChannelScalarFieldEnum[]
  }

  /**
   * CheckChannel findFirstOrThrow
   */
  export type CheckChannelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckChannel
     */
    select?: CheckChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckChannelInclude<ExtArgs> | null
    /**
     * Filter, which CheckChannel to fetch.
     */
    where?: CheckChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckChannels to fetch.
     */
    orderBy?: CheckChannelOrderByWithRelationInput | CheckChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CheckChannels.
     */
    cursor?: CheckChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CheckChannels.
     */
    distinct?: CheckChannelScalarFieldEnum | CheckChannelScalarFieldEnum[]
  }

  /**
   * CheckChannel findMany
   */
  export type CheckChannelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckChannel
     */
    select?: CheckChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckChannelInclude<ExtArgs> | null
    /**
     * Filter, which CheckChannels to fetch.
     */
    where?: CheckChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckChannels to fetch.
     */
    orderBy?: CheckChannelOrderByWithRelationInput | CheckChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CheckChannels.
     */
    cursor?: CheckChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckChannels.
     */
    skip?: number
    distinct?: CheckChannelScalarFieldEnum | CheckChannelScalarFieldEnum[]
  }

  /**
   * CheckChannel create
   */
  export type CheckChannelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckChannel
     */
    select?: CheckChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckChannelInclude<ExtArgs> | null
    /**
     * The data needed to create a CheckChannel.
     */
    data: XOR<CheckChannelCreateInput, CheckChannelUncheckedCreateInput>
  }

  /**
   * CheckChannel createMany
   */
  export type CheckChannelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CheckChannels.
     */
    data: CheckChannelCreateManyInput | CheckChannelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CheckChannel createManyAndReturn
   */
  export type CheckChannelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckChannel
     */
    select?: CheckChannelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CheckChannels.
     */
    data: CheckChannelCreateManyInput | CheckChannelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckChannelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CheckChannel update
   */
  export type CheckChannelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckChannel
     */
    select?: CheckChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckChannelInclude<ExtArgs> | null
    /**
     * The data needed to update a CheckChannel.
     */
    data: XOR<CheckChannelUpdateInput, CheckChannelUncheckedUpdateInput>
    /**
     * Choose, which CheckChannel to update.
     */
    where: CheckChannelWhereUniqueInput
  }

  /**
   * CheckChannel updateMany
   */
  export type CheckChannelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CheckChannels.
     */
    data: XOR<CheckChannelUpdateManyMutationInput, CheckChannelUncheckedUpdateManyInput>
    /**
     * Filter which CheckChannels to update
     */
    where?: CheckChannelWhereInput
  }

  /**
   * CheckChannel upsert
   */
  export type CheckChannelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckChannel
     */
    select?: CheckChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckChannelInclude<ExtArgs> | null
    /**
     * The filter to search for the CheckChannel to update in case it exists.
     */
    where: CheckChannelWhereUniqueInput
    /**
     * In case the CheckChannel found by the `where` argument doesn't exist, create a new CheckChannel with this data.
     */
    create: XOR<CheckChannelCreateInput, CheckChannelUncheckedCreateInput>
    /**
     * In case the CheckChannel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CheckChannelUpdateInput, CheckChannelUncheckedUpdateInput>
  }

  /**
   * CheckChannel delete
   */
  export type CheckChannelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckChannel
     */
    select?: CheckChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckChannelInclude<ExtArgs> | null
    /**
     * Filter which CheckChannel to delete.
     */
    where: CheckChannelWhereUniqueInput
  }

  /**
   * CheckChannel deleteMany
   */
  export type CheckChannelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CheckChannels to delete
     */
    where?: CheckChannelWhereInput
  }

  /**
   * CheckChannel without action
   */
  export type CheckChannelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckChannel
     */
    select?: CheckChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckChannelInclude<ExtArgs> | null
  }


  /**
   * Model Alert
   */

  export type AggregateAlert = {
    _count: AlertCountAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  export type AlertMinAggregateOutputType = {
    id: string | null
    checkId: string | null
    event: string | null
    success: boolean | null
    error: string | null
    createdAt: Date | null
  }

  export type AlertMaxAggregateOutputType = {
    id: string | null
    checkId: string | null
    event: string | null
    success: boolean | null
    error: string | null
    createdAt: Date | null
  }

  export type AlertCountAggregateOutputType = {
    id: number
    checkId: number
    event: number
    channels: number
    success: number
    error: number
    createdAt: number
    _all: number
  }


  export type AlertMinAggregateInputType = {
    id?: true
    checkId?: true
    event?: true
    success?: true
    error?: true
    createdAt?: true
  }

  export type AlertMaxAggregateInputType = {
    id?: true
    checkId?: true
    event?: true
    success?: true
    error?: true
    createdAt?: true
  }

  export type AlertCountAggregateInputType = {
    id?: true
    checkId?: true
    event?: true
    channels?: true
    success?: true
    error?: true
    createdAt?: true
    _all?: true
  }

  export type AlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alert to aggregate.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alerts
    **/
    _count?: true | AlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertMaxAggregateInputType
  }

  export type GetAlertAggregateType<T extends AlertAggregateArgs> = {
        [P in keyof T & keyof AggregateAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlert[P]>
      : GetScalarType<T[P], AggregateAlert[P]>
  }




  export type AlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithAggregationInput | AlertOrderByWithAggregationInput[]
    by: AlertScalarFieldEnum[] | AlertScalarFieldEnum
    having?: AlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertCountAggregateInputType | true
    _min?: AlertMinAggregateInputType
    _max?: AlertMaxAggregateInputType
  }

  export type AlertGroupByOutputType = {
    id: string
    checkId: string
    event: string
    channels: JsonValue
    success: boolean
    error: string | null
    createdAt: Date
    _count: AlertCountAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  type GetAlertGroupByPayload<T extends AlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertGroupByOutputType[P]>
            : GetScalarType<T[P], AlertGroupByOutputType[P]>
        }
      >
    >


  export type AlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    checkId?: boolean
    event?: boolean
    channels?: boolean
    success?: boolean
    error?: boolean
    createdAt?: boolean
    check?: boolean | CheckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    checkId?: boolean
    event?: boolean
    channels?: boolean
    success?: boolean
    error?: boolean
    createdAt?: boolean
    check?: boolean | CheckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectScalar = {
    id?: boolean
    checkId?: boolean
    event?: boolean
    channels?: boolean
    success?: boolean
    error?: boolean
    createdAt?: boolean
  }

  export type AlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    check?: boolean | CheckDefaultArgs<ExtArgs>
  }
  export type AlertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    check?: boolean | CheckDefaultArgs<ExtArgs>
  }

  export type $AlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Alert"
    objects: {
      check: Prisma.$CheckPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      checkId: string
      event: string
      channels: Prisma.JsonValue
      success: boolean
      error: string | null
      createdAt: Date
    }, ExtArgs["result"]["alert"]>
    composites: {}
  }

  type AlertGetPayload<S extends boolean | null | undefined | AlertDefaultArgs> = $Result.GetResult<Prisma.$AlertPayload, S>

  type AlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AlertFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AlertCountAggregateInputType | true
    }

  export interface AlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alert'], meta: { name: 'Alert' } }
    /**
     * Find zero or one Alert that matches the filter.
     * @param {AlertFindUniqueArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlertFindUniqueArgs>(args: SelectSubset<T, AlertFindUniqueArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Alert that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AlertFindUniqueOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlertFindUniqueOrThrowArgs>(args: SelectSubset<T, AlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Alert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlertFindFirstArgs>(args?: SelectSubset<T, AlertFindFirstArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Alert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlertFindFirstOrThrowArgs>(args?: SelectSubset<T, AlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alerts
     * const alerts = await prisma.alert.findMany()
     * 
     * // Get first 10 Alerts
     * const alerts = await prisma.alert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertWithIdOnly = await prisma.alert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlertFindManyArgs>(args?: SelectSubset<T, AlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Alert.
     * @param {AlertCreateArgs} args - Arguments to create a Alert.
     * @example
     * // Create one Alert
     * const Alert = await prisma.alert.create({
     *   data: {
     *     // ... data to create a Alert
     *   }
     * })
     * 
     */
    create<T extends AlertCreateArgs>(args: SelectSubset<T, AlertCreateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Alerts.
     * @param {AlertCreateManyArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlertCreateManyArgs>(args?: SelectSubset<T, AlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Alerts and returns the data saved in the database.
     * @param {AlertCreateManyAndReturnArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Alerts and only return the `id`
     * const alertWithIdOnly = await prisma.alert.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlertCreateManyAndReturnArgs>(args?: SelectSubset<T, AlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Alert.
     * @param {AlertDeleteArgs} args - Arguments to delete one Alert.
     * @example
     * // Delete one Alert
     * const Alert = await prisma.alert.delete({
     *   where: {
     *     // ... filter to delete one Alert
     *   }
     * })
     * 
     */
    delete<T extends AlertDeleteArgs>(args: SelectSubset<T, AlertDeleteArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Alert.
     * @param {AlertUpdateArgs} args - Arguments to update one Alert.
     * @example
     * // Update one Alert
     * const alert = await prisma.alert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlertUpdateArgs>(args: SelectSubset<T, AlertUpdateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Alerts.
     * @param {AlertDeleteManyArgs} args - Arguments to filter Alerts to delete.
     * @example
     * // Delete a few Alerts
     * const { count } = await prisma.alert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlertDeleteManyArgs>(args?: SelectSubset<T, AlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alerts
     * const alert = await prisma.alert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlertUpdateManyArgs>(args: SelectSubset<T, AlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Alert.
     * @param {AlertUpsertArgs} args - Arguments to update or create a Alert.
     * @example
     * // Update or create a Alert
     * const alert = await prisma.alert.upsert({
     *   create: {
     *     // ... data to create a Alert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alert we want to update
     *   }
     * })
     */
    upsert<T extends AlertUpsertArgs>(args: SelectSubset<T, AlertUpsertArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertCountArgs} args - Arguments to filter Alerts to count.
     * @example
     * // Count the number of Alerts
     * const count = await prisma.alert.count({
     *   where: {
     *     // ... the filter for the Alerts we want to count
     *   }
     * })
    **/
    count<T extends AlertCountArgs>(
      args?: Subset<T, AlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertAggregateArgs>(args: Subset<T, AlertAggregateArgs>): Prisma.PrismaPromise<GetAlertAggregateType<T>>

    /**
     * Group by Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertGroupByArgs['orderBy'] }
        : { orderBy?: AlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Alert model
   */
  readonly fields: AlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Alert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    check<T extends CheckDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CheckDefaultArgs<ExtArgs>>): Prisma__CheckClient<$Result.GetResult<Prisma.$CheckPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Alert model
   */ 
  interface AlertFieldRefs {
    readonly id: FieldRef<"Alert", 'String'>
    readonly checkId: FieldRef<"Alert", 'String'>
    readonly event: FieldRef<"Alert", 'String'>
    readonly channels: FieldRef<"Alert", 'Json'>
    readonly success: FieldRef<"Alert", 'Boolean'>
    readonly error: FieldRef<"Alert", 'String'>
    readonly createdAt: FieldRef<"Alert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Alert findUnique
   */
  export type AlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findUniqueOrThrow
   */
  export type AlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findFirst
   */
  export type AlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findFirstOrThrow
   */
  export type AlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findMany
   */
  export type AlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alerts to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert create
   */
  export type AlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to create a Alert.
     */
    data: XOR<AlertCreateInput, AlertUncheckedCreateInput>
  }

  /**
   * Alert createMany
   */
  export type AlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alerts.
     */
    data: AlertCreateManyInput | AlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alert createManyAndReturn
   */
  export type AlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Alerts.
     */
    data: AlertCreateManyInput | AlertCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Alert update
   */
  export type AlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to update a Alert.
     */
    data: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
    /**
     * Choose, which Alert to update.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert updateMany
   */
  export type AlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alerts.
     */
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyInput>
    /**
     * Filter which Alerts to update
     */
    where?: AlertWhereInput
  }

  /**
   * Alert upsert
   */
  export type AlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The filter to search for the Alert to update in case it exists.
     */
    where: AlertWhereUniqueInput
    /**
     * In case the Alert found by the `where` argument doesn't exist, create a new Alert with this data.
     */
    create: XOR<AlertCreateInput, AlertUncheckedCreateInput>
    /**
     * In case the Alert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
  }

  /**
   * Alert delete
   */
  export type AlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter which Alert to delete.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert deleteMany
   */
  export type AlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alerts to delete
     */
    where?: AlertWhereInput
  }

  /**
   * Alert without action
   */
  export type AlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
  }


  /**
   * Model ApiKey
   */

  export type AggregateApiKey = {
    _count: ApiKeyCountAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  export type ApiKeyMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    keyHash: string | null
    keyPrefix: string | null
    lastUsedAt: Date | null
    createdAt: Date | null
  }

  export type ApiKeyMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    keyHash: string | null
    keyPrefix: string | null
    lastUsedAt: Date | null
    createdAt: Date | null
  }

  export type ApiKeyCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    keyHash: number
    keyPrefix: number
    lastUsedAt: number
    createdAt: number
    _all: number
  }


  export type ApiKeyMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    keyHash?: true
    keyPrefix?: true
    lastUsedAt?: true
    createdAt?: true
  }

  export type ApiKeyMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    keyHash?: true
    keyPrefix?: true
    lastUsedAt?: true
    createdAt?: true
  }

  export type ApiKeyCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    keyHash?: true
    keyPrefix?: true
    lastUsedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ApiKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKey to aggregate.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiKeys
    **/
    _count?: true | ApiKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiKeyMaxAggregateInputType
  }

  export type GetApiKeyAggregateType<T extends ApiKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateApiKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiKey[P]>
      : GetScalarType<T[P], AggregateApiKey[P]>
  }




  export type ApiKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithAggregationInput | ApiKeyOrderByWithAggregationInput[]
    by: ApiKeyScalarFieldEnum[] | ApiKeyScalarFieldEnum
    having?: ApiKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiKeyCountAggregateInputType | true
    _min?: ApiKeyMinAggregateInputType
    _max?: ApiKeyMaxAggregateInputType
  }

  export type ApiKeyGroupByOutputType = {
    id: string
    projectId: string
    name: string
    keyHash: string
    keyPrefix: string
    lastUsedAt: Date | null
    createdAt: Date
    _count: ApiKeyCountAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  type GetApiKeyGroupByPayload<T extends ApiKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
            : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
        }
      >
    >


  export type ApiKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    keyHash?: boolean
    keyPrefix?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    keyHash?: boolean
    keyPrefix?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    keyHash?: boolean
    keyPrefix?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
  }

  export type ApiKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ApiKeyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ApiKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiKey"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      name: string
      keyHash: string
      keyPrefix: string
      lastUsedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["apiKey"]>
    composites: {}
  }

  type ApiKeyGetPayload<S extends boolean | null | undefined | ApiKeyDefaultArgs> = $Result.GetResult<Prisma.$ApiKeyPayload, S>

  type ApiKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApiKeyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApiKeyCountAggregateInputType | true
    }

  export interface ApiKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiKey'], meta: { name: 'ApiKey' } }
    /**
     * Find zero or one ApiKey that matches the filter.
     * @param {ApiKeyFindUniqueArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiKeyFindUniqueArgs>(args: SelectSubset<T, ApiKeyFindUniqueArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApiKey that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApiKeyFindUniqueOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApiKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiKeyFindFirstArgs>(args?: SelectSubset<T, ApiKeyFindFirstArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApiKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApiKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiKeys
     * const apiKeys = await prisma.apiKey.findMany()
     * 
     * // Get first 10 ApiKeys
     * const apiKeys = await prisma.apiKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiKeyFindManyArgs>(args?: SelectSubset<T, ApiKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApiKey.
     * @param {ApiKeyCreateArgs} args - Arguments to create a ApiKey.
     * @example
     * // Create one ApiKey
     * const ApiKey = await prisma.apiKey.create({
     *   data: {
     *     // ... data to create a ApiKey
     *   }
     * })
     * 
     */
    create<T extends ApiKeyCreateArgs>(args: SelectSubset<T, ApiKeyCreateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApiKeys.
     * @param {ApiKeyCreateManyArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiKeyCreateManyArgs>(args?: SelectSubset<T, ApiKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiKeys and returns the data saved in the database.
     * @param {ApiKeyCreateManyAndReturnArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiKeys and only return the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiKeyCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiKeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ApiKey.
     * @param {ApiKeyDeleteArgs} args - Arguments to delete one ApiKey.
     * @example
     * // Delete one ApiKey
     * const ApiKey = await prisma.apiKey.delete({
     *   where: {
     *     // ... filter to delete one ApiKey
     *   }
     * })
     * 
     */
    delete<T extends ApiKeyDeleteArgs>(args: SelectSubset<T, ApiKeyDeleteArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApiKey.
     * @param {ApiKeyUpdateArgs} args - Arguments to update one ApiKey.
     * @example
     * // Update one ApiKey
     * const apiKey = await prisma.apiKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiKeyUpdateArgs>(args: SelectSubset<T, ApiKeyUpdateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApiKeys.
     * @param {ApiKeyDeleteManyArgs} args - Arguments to filter ApiKeys to delete.
     * @example
     * // Delete a few ApiKeys
     * const { count } = await prisma.apiKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiKeyDeleteManyArgs>(args?: SelectSubset<T, ApiKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiKeyUpdateManyArgs>(args: SelectSubset<T, ApiKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApiKey.
     * @param {ApiKeyUpsertArgs} args - Arguments to update or create a ApiKey.
     * @example
     * // Update or create a ApiKey
     * const apiKey = await prisma.apiKey.upsert({
     *   create: {
     *     // ... data to create a ApiKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiKey we want to update
     *   }
     * })
     */
    upsert<T extends ApiKeyUpsertArgs>(args: SelectSubset<T, ApiKeyUpsertArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyCountArgs} args - Arguments to filter ApiKeys to count.
     * @example
     * // Count the number of ApiKeys
     * const count = await prisma.apiKey.count({
     *   where: {
     *     // ... the filter for the ApiKeys we want to count
     *   }
     * })
    **/
    count<T extends ApiKeyCountArgs>(
      args?: Subset<T, ApiKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiKeyAggregateArgs>(args: Subset<T, ApiKeyAggregateArgs>): Prisma.PrismaPromise<GetApiKeyAggregateType<T>>

    /**
     * Group by ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiKeyGroupByArgs['orderBy'] }
        : { orderBy?: ApiKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiKey model
   */
  readonly fields: ApiKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiKey model
   */ 
  interface ApiKeyFieldRefs {
    readonly id: FieldRef<"ApiKey", 'String'>
    readonly projectId: FieldRef<"ApiKey", 'String'>
    readonly name: FieldRef<"ApiKey", 'String'>
    readonly keyHash: FieldRef<"ApiKey", 'String'>
    readonly keyPrefix: FieldRef<"ApiKey", 'String'>
    readonly lastUsedAt: FieldRef<"ApiKey", 'DateTime'>
    readonly createdAt: FieldRef<"ApiKey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiKey findUnique
   */
  export type ApiKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findUniqueOrThrow
   */
  export type ApiKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findFirst
   */
  export type ApiKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findFirstOrThrow
   */
  export type ApiKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findMany
   */
  export type ApiKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeys to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey create
   */
  export type ApiKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiKey.
     */
    data: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
  }

  /**
   * ApiKey createMany
   */
  export type ApiKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiKey createManyAndReturn
   */
  export type ApiKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiKey update
   */
  export type ApiKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiKey.
     */
    data: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
    /**
     * Choose, which ApiKey to update.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey updateMany
   */
  export type ApiKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput
  }

  /**
   * ApiKey upsert
   */
  export type ApiKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiKey to update in case it exists.
     */
    where: ApiKeyWhereUniqueInput
    /**
     * In case the ApiKey found by the `where` argument doesn't exist, create a new ApiKey with this data.
     */
    create: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
    /**
     * In case the ApiKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
  }

  /**
   * ApiKey delete
   */
  export type ApiKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter which ApiKey to delete.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey deleteMany
   */
  export type ApiKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeys to delete
     */
    where?: ApiKeyWhereInput
  }

  /**
   * ApiKey without action
   */
  export type ApiKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
  }


  /**
   * Model Incident
   */

  export type AggregateIncident = {
    _count: IncidentCountAggregateOutputType | null
    _min: IncidentMinAggregateOutputType | null
    _max: IncidentMaxAggregateOutputType | null
  }

  export type IncidentMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    title: string | null
    status: $Enums.IncidentStatus | null
    impact: $Enums.IncidentImpact | null
    autoCreated: boolean | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IncidentMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    title: string | null
    status: $Enums.IncidentStatus | null
    impact: $Enums.IncidentImpact | null
    autoCreated: boolean | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IncidentCountAggregateOutputType = {
    id: number
    projectId: number
    title: number
    status: number
    impact: number
    autoCreated: number
    resolvedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IncidentMinAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    status?: true
    impact?: true
    autoCreated?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IncidentMaxAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    status?: true
    impact?: true
    autoCreated?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IncidentCountAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    status?: true
    impact?: true
    autoCreated?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IncidentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Incident to aggregate.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Incidents
    **/
    _count?: true | IncidentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncidentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncidentMaxAggregateInputType
  }

  export type GetIncidentAggregateType<T extends IncidentAggregateArgs> = {
        [P in keyof T & keyof AggregateIncident]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncident[P]>
      : GetScalarType<T[P], AggregateIncident[P]>
  }




  export type IncidentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentWhereInput
    orderBy?: IncidentOrderByWithAggregationInput | IncidentOrderByWithAggregationInput[]
    by: IncidentScalarFieldEnum[] | IncidentScalarFieldEnum
    having?: IncidentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncidentCountAggregateInputType | true
    _min?: IncidentMinAggregateInputType
    _max?: IncidentMaxAggregateInputType
  }

  export type IncidentGroupByOutputType = {
    id: string
    projectId: string
    title: string
    status: $Enums.IncidentStatus
    impact: $Enums.IncidentImpact
    autoCreated: boolean
    resolvedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: IncidentCountAggregateOutputType | null
    _min: IncidentMinAggregateOutputType | null
    _max: IncidentMaxAggregateOutputType | null
  }

  type GetIncidentGroupByPayload<T extends IncidentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncidentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncidentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncidentGroupByOutputType[P]>
            : GetScalarType<T[P], IncidentGroupByOutputType[P]>
        }
      >
    >


  export type IncidentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    status?: boolean
    impact?: boolean
    autoCreated?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    updates?: boolean | Incident$updatesArgs<ExtArgs>
    checks?: boolean | Incident$checksArgs<ExtArgs>
    _count?: boolean | IncidentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incident"]>

  export type IncidentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    status?: boolean
    impact?: boolean
    autoCreated?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incident"]>

  export type IncidentSelectScalar = {
    id?: boolean
    projectId?: boolean
    title?: boolean
    status?: boolean
    impact?: boolean
    autoCreated?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IncidentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    updates?: boolean | Incident$updatesArgs<ExtArgs>
    checks?: boolean | Incident$checksArgs<ExtArgs>
    _count?: boolean | IncidentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IncidentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $IncidentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Incident"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      updates: Prisma.$IncidentUpdatePayload<ExtArgs>[]
      checks: Prisma.$IncidentCheckPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      title: string
      status: $Enums.IncidentStatus
      impact: $Enums.IncidentImpact
      autoCreated: boolean
      resolvedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["incident"]>
    composites: {}
  }

  type IncidentGetPayload<S extends boolean | null | undefined | IncidentDefaultArgs> = $Result.GetResult<Prisma.$IncidentPayload, S>

  type IncidentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IncidentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IncidentCountAggregateInputType | true
    }

  export interface IncidentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Incident'], meta: { name: 'Incident' } }
    /**
     * Find zero or one Incident that matches the filter.
     * @param {IncidentFindUniqueArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncidentFindUniqueArgs>(args: SelectSubset<T, IncidentFindUniqueArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Incident that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IncidentFindUniqueOrThrowArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncidentFindUniqueOrThrowArgs>(args: SelectSubset<T, IncidentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Incident that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindFirstArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncidentFindFirstArgs>(args?: SelectSubset<T, IncidentFindFirstArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Incident that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindFirstOrThrowArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncidentFindFirstOrThrowArgs>(args?: SelectSubset<T, IncidentFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Incidents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Incidents
     * const incidents = await prisma.incident.findMany()
     * 
     * // Get first 10 Incidents
     * const incidents = await prisma.incident.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incidentWithIdOnly = await prisma.incident.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IncidentFindManyArgs>(args?: SelectSubset<T, IncidentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Incident.
     * @param {IncidentCreateArgs} args - Arguments to create a Incident.
     * @example
     * // Create one Incident
     * const Incident = await prisma.incident.create({
     *   data: {
     *     // ... data to create a Incident
     *   }
     * })
     * 
     */
    create<T extends IncidentCreateArgs>(args: SelectSubset<T, IncidentCreateArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Incidents.
     * @param {IncidentCreateManyArgs} args - Arguments to create many Incidents.
     * @example
     * // Create many Incidents
     * const incident = await prisma.incident.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncidentCreateManyArgs>(args?: SelectSubset<T, IncidentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Incidents and returns the data saved in the database.
     * @param {IncidentCreateManyAndReturnArgs} args - Arguments to create many Incidents.
     * @example
     * // Create many Incidents
     * const incident = await prisma.incident.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Incidents and only return the `id`
     * const incidentWithIdOnly = await prisma.incident.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IncidentCreateManyAndReturnArgs>(args?: SelectSubset<T, IncidentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Incident.
     * @param {IncidentDeleteArgs} args - Arguments to delete one Incident.
     * @example
     * // Delete one Incident
     * const Incident = await prisma.incident.delete({
     *   where: {
     *     // ... filter to delete one Incident
     *   }
     * })
     * 
     */
    delete<T extends IncidentDeleteArgs>(args: SelectSubset<T, IncidentDeleteArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Incident.
     * @param {IncidentUpdateArgs} args - Arguments to update one Incident.
     * @example
     * // Update one Incident
     * const incident = await prisma.incident.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncidentUpdateArgs>(args: SelectSubset<T, IncidentUpdateArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Incidents.
     * @param {IncidentDeleteManyArgs} args - Arguments to filter Incidents to delete.
     * @example
     * // Delete a few Incidents
     * const { count } = await prisma.incident.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncidentDeleteManyArgs>(args?: SelectSubset<T, IncidentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Incidents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Incidents
     * const incident = await prisma.incident.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncidentUpdateManyArgs>(args: SelectSubset<T, IncidentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Incident.
     * @param {IncidentUpsertArgs} args - Arguments to update or create a Incident.
     * @example
     * // Update or create a Incident
     * const incident = await prisma.incident.upsert({
     *   create: {
     *     // ... data to create a Incident
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Incident we want to update
     *   }
     * })
     */
    upsert<T extends IncidentUpsertArgs>(args: SelectSubset<T, IncidentUpsertArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Incidents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentCountArgs} args - Arguments to filter Incidents to count.
     * @example
     * // Count the number of Incidents
     * const count = await prisma.incident.count({
     *   where: {
     *     // ... the filter for the Incidents we want to count
     *   }
     * })
    **/
    count<T extends IncidentCountArgs>(
      args?: Subset<T, IncidentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncidentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Incident.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncidentAggregateArgs>(args: Subset<T, IncidentAggregateArgs>): Prisma.PrismaPromise<GetIncidentAggregateType<T>>

    /**
     * Group by Incident.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncidentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncidentGroupByArgs['orderBy'] }
        : { orderBy?: IncidentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncidentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncidentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Incident model
   */
  readonly fields: IncidentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Incident.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncidentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    updates<T extends Incident$updatesArgs<ExtArgs> = {}>(args?: Subset<T, Incident$updatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentUpdatePayload<ExtArgs>, T, "findMany"> | Null>
    checks<T extends Incident$checksArgs<ExtArgs> = {}>(args?: Subset<T, Incident$checksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentCheckPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Incident model
   */ 
  interface IncidentFieldRefs {
    readonly id: FieldRef<"Incident", 'String'>
    readonly projectId: FieldRef<"Incident", 'String'>
    readonly title: FieldRef<"Incident", 'String'>
    readonly status: FieldRef<"Incident", 'IncidentStatus'>
    readonly impact: FieldRef<"Incident", 'IncidentImpact'>
    readonly autoCreated: FieldRef<"Incident", 'Boolean'>
    readonly resolvedAt: FieldRef<"Incident", 'DateTime'>
    readonly createdAt: FieldRef<"Incident", 'DateTime'>
    readonly updatedAt: FieldRef<"Incident", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Incident findUnique
   */
  export type IncidentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident findUniqueOrThrow
   */
  export type IncidentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident findFirst
   */
  export type IncidentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incidents.
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incidents.
     */
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Incident findFirstOrThrow
   */
  export type IncidentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incidents.
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incidents.
     */
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Incident findMany
   */
  export type IncidentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incidents to fetch.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Incidents.
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Incident create
   */
  export type IncidentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * The data needed to create a Incident.
     */
    data: XOR<IncidentCreateInput, IncidentUncheckedCreateInput>
  }

  /**
   * Incident createMany
   */
  export type IncidentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Incidents.
     */
    data: IncidentCreateManyInput | IncidentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Incident createManyAndReturn
   */
  export type IncidentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Incidents.
     */
    data: IncidentCreateManyInput | IncidentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Incident update
   */
  export type IncidentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * The data needed to update a Incident.
     */
    data: XOR<IncidentUpdateInput, IncidentUncheckedUpdateInput>
    /**
     * Choose, which Incident to update.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident updateMany
   */
  export type IncidentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Incidents.
     */
    data: XOR<IncidentUpdateManyMutationInput, IncidentUncheckedUpdateManyInput>
    /**
     * Filter which Incidents to update
     */
    where?: IncidentWhereInput
  }

  /**
   * Incident upsert
   */
  export type IncidentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * The filter to search for the Incident to update in case it exists.
     */
    where: IncidentWhereUniqueInput
    /**
     * In case the Incident found by the `where` argument doesn't exist, create a new Incident with this data.
     */
    create: XOR<IncidentCreateInput, IncidentUncheckedCreateInput>
    /**
     * In case the Incident was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncidentUpdateInput, IncidentUncheckedUpdateInput>
  }

  /**
   * Incident delete
   */
  export type IncidentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter which Incident to delete.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident deleteMany
   */
  export type IncidentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Incidents to delete
     */
    where?: IncidentWhereInput
  }

  /**
   * Incident.updates
   */
  export type Incident$updatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentUpdate
     */
    select?: IncidentUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentUpdateInclude<ExtArgs> | null
    where?: IncidentUpdateWhereInput
    orderBy?: IncidentUpdateOrderByWithRelationInput | IncidentUpdateOrderByWithRelationInput[]
    cursor?: IncidentUpdateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentUpdateScalarFieldEnum | IncidentUpdateScalarFieldEnum[]
  }

  /**
   * Incident.checks
   */
  export type Incident$checksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentCheck
     */
    select?: IncidentCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentCheckInclude<ExtArgs> | null
    where?: IncidentCheckWhereInput
    orderBy?: IncidentCheckOrderByWithRelationInput | IncidentCheckOrderByWithRelationInput[]
    cursor?: IncidentCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentCheckScalarFieldEnum | IncidentCheckScalarFieldEnum[]
  }

  /**
   * Incident without action
   */
  export type IncidentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
  }


  /**
   * Model IncidentUpdate
   */

  export type AggregateIncidentUpdate = {
    _count: IncidentUpdateCountAggregateOutputType | null
    _min: IncidentUpdateMinAggregateOutputType | null
    _max: IncidentUpdateMaxAggregateOutputType | null
  }

  export type IncidentUpdateMinAggregateOutputType = {
    id: string | null
    incidentId: string | null
    status: $Enums.IncidentStatus | null
    message: string | null
    createdAt: Date | null
  }

  export type IncidentUpdateMaxAggregateOutputType = {
    id: string | null
    incidentId: string | null
    status: $Enums.IncidentStatus | null
    message: string | null
    createdAt: Date | null
  }

  export type IncidentUpdateCountAggregateOutputType = {
    id: number
    incidentId: number
    status: number
    message: number
    createdAt: number
    _all: number
  }


  export type IncidentUpdateMinAggregateInputType = {
    id?: true
    incidentId?: true
    status?: true
    message?: true
    createdAt?: true
  }

  export type IncidentUpdateMaxAggregateInputType = {
    id?: true
    incidentId?: true
    status?: true
    message?: true
    createdAt?: true
  }

  export type IncidentUpdateCountAggregateInputType = {
    id?: true
    incidentId?: true
    status?: true
    message?: true
    createdAt?: true
    _all?: true
  }

  export type IncidentUpdateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncidentUpdate to aggregate.
     */
    where?: IncidentUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentUpdates to fetch.
     */
    orderBy?: IncidentUpdateOrderByWithRelationInput | IncidentUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncidentUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IncidentUpdates
    **/
    _count?: true | IncidentUpdateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncidentUpdateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncidentUpdateMaxAggregateInputType
  }

  export type GetIncidentUpdateAggregateType<T extends IncidentUpdateAggregateArgs> = {
        [P in keyof T & keyof AggregateIncidentUpdate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncidentUpdate[P]>
      : GetScalarType<T[P], AggregateIncidentUpdate[P]>
  }




  export type IncidentUpdateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentUpdateWhereInput
    orderBy?: IncidentUpdateOrderByWithAggregationInput | IncidentUpdateOrderByWithAggregationInput[]
    by: IncidentUpdateScalarFieldEnum[] | IncidentUpdateScalarFieldEnum
    having?: IncidentUpdateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncidentUpdateCountAggregateInputType | true
    _min?: IncidentUpdateMinAggregateInputType
    _max?: IncidentUpdateMaxAggregateInputType
  }

  export type IncidentUpdateGroupByOutputType = {
    id: string
    incidentId: string
    status: $Enums.IncidentStatus
    message: string
    createdAt: Date
    _count: IncidentUpdateCountAggregateOutputType | null
    _min: IncidentUpdateMinAggregateOutputType | null
    _max: IncidentUpdateMaxAggregateOutputType | null
  }

  type GetIncidentUpdateGroupByPayload<T extends IncidentUpdateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncidentUpdateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncidentUpdateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncidentUpdateGroupByOutputType[P]>
            : GetScalarType<T[P], IncidentUpdateGroupByOutputType[P]>
        }
      >
    >


  export type IncidentUpdateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    incidentId?: boolean
    status?: boolean
    message?: boolean
    createdAt?: boolean
    incident?: boolean | IncidentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incidentUpdate"]>

  export type IncidentUpdateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    incidentId?: boolean
    status?: boolean
    message?: boolean
    createdAt?: boolean
    incident?: boolean | IncidentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incidentUpdate"]>

  export type IncidentUpdateSelectScalar = {
    id?: boolean
    incidentId?: boolean
    status?: boolean
    message?: boolean
    createdAt?: boolean
  }

  export type IncidentUpdateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    incident?: boolean | IncidentDefaultArgs<ExtArgs>
  }
  export type IncidentUpdateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    incident?: boolean | IncidentDefaultArgs<ExtArgs>
  }

  export type $IncidentUpdatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IncidentUpdate"
    objects: {
      incident: Prisma.$IncidentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      incidentId: string
      status: $Enums.IncidentStatus
      message: string
      createdAt: Date
    }, ExtArgs["result"]["incidentUpdate"]>
    composites: {}
  }

  type IncidentUpdateGetPayload<S extends boolean | null | undefined | IncidentUpdateDefaultArgs> = $Result.GetResult<Prisma.$IncidentUpdatePayload, S>

  type IncidentUpdateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IncidentUpdateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IncidentUpdateCountAggregateInputType | true
    }

  export interface IncidentUpdateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IncidentUpdate'], meta: { name: 'IncidentUpdate' } }
    /**
     * Find zero or one IncidentUpdate that matches the filter.
     * @param {IncidentUpdateFindUniqueArgs} args - Arguments to find a IncidentUpdate
     * @example
     * // Get one IncidentUpdate
     * const incidentUpdate = await prisma.incidentUpdate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncidentUpdateFindUniqueArgs>(args: SelectSubset<T, IncidentUpdateFindUniqueArgs<ExtArgs>>): Prisma__IncidentUpdateClient<$Result.GetResult<Prisma.$IncidentUpdatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IncidentUpdate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IncidentUpdateFindUniqueOrThrowArgs} args - Arguments to find a IncidentUpdate
     * @example
     * // Get one IncidentUpdate
     * const incidentUpdate = await prisma.incidentUpdate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncidentUpdateFindUniqueOrThrowArgs>(args: SelectSubset<T, IncidentUpdateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncidentUpdateClient<$Result.GetResult<Prisma.$IncidentUpdatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IncidentUpdate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentUpdateFindFirstArgs} args - Arguments to find a IncidentUpdate
     * @example
     * // Get one IncidentUpdate
     * const incidentUpdate = await prisma.incidentUpdate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncidentUpdateFindFirstArgs>(args?: SelectSubset<T, IncidentUpdateFindFirstArgs<ExtArgs>>): Prisma__IncidentUpdateClient<$Result.GetResult<Prisma.$IncidentUpdatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IncidentUpdate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentUpdateFindFirstOrThrowArgs} args - Arguments to find a IncidentUpdate
     * @example
     * // Get one IncidentUpdate
     * const incidentUpdate = await prisma.incidentUpdate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncidentUpdateFindFirstOrThrowArgs>(args?: SelectSubset<T, IncidentUpdateFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncidentUpdateClient<$Result.GetResult<Prisma.$IncidentUpdatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IncidentUpdates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentUpdateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IncidentUpdates
     * const incidentUpdates = await prisma.incidentUpdate.findMany()
     * 
     * // Get first 10 IncidentUpdates
     * const incidentUpdates = await prisma.incidentUpdate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incidentUpdateWithIdOnly = await prisma.incidentUpdate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IncidentUpdateFindManyArgs>(args?: SelectSubset<T, IncidentUpdateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentUpdatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IncidentUpdate.
     * @param {IncidentUpdateCreateArgs} args - Arguments to create a IncidentUpdate.
     * @example
     * // Create one IncidentUpdate
     * const IncidentUpdate = await prisma.incidentUpdate.create({
     *   data: {
     *     // ... data to create a IncidentUpdate
     *   }
     * })
     * 
     */
    create<T extends IncidentUpdateCreateArgs>(args: SelectSubset<T, IncidentUpdateCreateArgs<ExtArgs>>): Prisma__IncidentUpdateClient<$Result.GetResult<Prisma.$IncidentUpdatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IncidentUpdates.
     * @param {IncidentUpdateCreateManyArgs} args - Arguments to create many IncidentUpdates.
     * @example
     * // Create many IncidentUpdates
     * const incidentUpdate = await prisma.incidentUpdate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncidentUpdateCreateManyArgs>(args?: SelectSubset<T, IncidentUpdateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IncidentUpdates and returns the data saved in the database.
     * @param {IncidentUpdateCreateManyAndReturnArgs} args - Arguments to create many IncidentUpdates.
     * @example
     * // Create many IncidentUpdates
     * const incidentUpdate = await prisma.incidentUpdate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IncidentUpdates and only return the `id`
     * const incidentUpdateWithIdOnly = await prisma.incidentUpdate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IncidentUpdateCreateManyAndReturnArgs>(args?: SelectSubset<T, IncidentUpdateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentUpdatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IncidentUpdate.
     * @param {IncidentUpdateDeleteArgs} args - Arguments to delete one IncidentUpdate.
     * @example
     * // Delete one IncidentUpdate
     * const IncidentUpdate = await prisma.incidentUpdate.delete({
     *   where: {
     *     // ... filter to delete one IncidentUpdate
     *   }
     * })
     * 
     */
    delete<T extends IncidentUpdateDeleteArgs>(args: SelectSubset<T, IncidentUpdateDeleteArgs<ExtArgs>>): Prisma__IncidentUpdateClient<$Result.GetResult<Prisma.$IncidentUpdatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IncidentUpdate.
     * @param {IncidentUpdateUpdateArgs} args - Arguments to update one IncidentUpdate.
     * @example
     * // Update one IncidentUpdate
     * const incidentUpdate = await prisma.incidentUpdate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncidentUpdateUpdateArgs>(args: SelectSubset<T, IncidentUpdateUpdateArgs<ExtArgs>>): Prisma__IncidentUpdateClient<$Result.GetResult<Prisma.$IncidentUpdatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IncidentUpdates.
     * @param {IncidentUpdateDeleteManyArgs} args - Arguments to filter IncidentUpdates to delete.
     * @example
     * // Delete a few IncidentUpdates
     * const { count } = await prisma.incidentUpdate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncidentUpdateDeleteManyArgs>(args?: SelectSubset<T, IncidentUpdateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IncidentUpdates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentUpdateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IncidentUpdates
     * const incidentUpdate = await prisma.incidentUpdate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncidentUpdateUpdateManyArgs>(args: SelectSubset<T, IncidentUpdateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IncidentUpdate.
     * @param {IncidentUpdateUpsertArgs} args - Arguments to update or create a IncidentUpdate.
     * @example
     * // Update or create a IncidentUpdate
     * const incidentUpdate = await prisma.incidentUpdate.upsert({
     *   create: {
     *     // ... data to create a IncidentUpdate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IncidentUpdate we want to update
     *   }
     * })
     */
    upsert<T extends IncidentUpdateUpsertArgs>(args: SelectSubset<T, IncidentUpdateUpsertArgs<ExtArgs>>): Prisma__IncidentUpdateClient<$Result.GetResult<Prisma.$IncidentUpdatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IncidentUpdates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentUpdateCountArgs} args - Arguments to filter IncidentUpdates to count.
     * @example
     * // Count the number of IncidentUpdates
     * const count = await prisma.incidentUpdate.count({
     *   where: {
     *     // ... the filter for the IncidentUpdates we want to count
     *   }
     * })
    **/
    count<T extends IncidentUpdateCountArgs>(
      args?: Subset<T, IncidentUpdateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncidentUpdateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IncidentUpdate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentUpdateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncidentUpdateAggregateArgs>(args: Subset<T, IncidentUpdateAggregateArgs>): Prisma.PrismaPromise<GetIncidentUpdateAggregateType<T>>

    /**
     * Group by IncidentUpdate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentUpdateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncidentUpdateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncidentUpdateGroupByArgs['orderBy'] }
        : { orderBy?: IncidentUpdateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncidentUpdateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncidentUpdateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IncidentUpdate model
   */
  readonly fields: IncidentUpdateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IncidentUpdate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncidentUpdateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    incident<T extends IncidentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IncidentDefaultArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IncidentUpdate model
   */ 
  interface IncidentUpdateFieldRefs {
    readonly id: FieldRef<"IncidentUpdate", 'String'>
    readonly incidentId: FieldRef<"IncidentUpdate", 'String'>
    readonly status: FieldRef<"IncidentUpdate", 'IncidentStatus'>
    readonly message: FieldRef<"IncidentUpdate", 'String'>
    readonly createdAt: FieldRef<"IncidentUpdate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IncidentUpdate findUnique
   */
  export type IncidentUpdateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentUpdate
     */
    select?: IncidentUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentUpdateInclude<ExtArgs> | null
    /**
     * Filter, which IncidentUpdate to fetch.
     */
    where: IncidentUpdateWhereUniqueInput
  }

  /**
   * IncidentUpdate findUniqueOrThrow
   */
  export type IncidentUpdateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentUpdate
     */
    select?: IncidentUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentUpdateInclude<ExtArgs> | null
    /**
     * Filter, which IncidentUpdate to fetch.
     */
    where: IncidentUpdateWhereUniqueInput
  }

  /**
   * IncidentUpdate findFirst
   */
  export type IncidentUpdateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentUpdate
     */
    select?: IncidentUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentUpdateInclude<ExtArgs> | null
    /**
     * Filter, which IncidentUpdate to fetch.
     */
    where?: IncidentUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentUpdates to fetch.
     */
    orderBy?: IncidentUpdateOrderByWithRelationInput | IncidentUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncidentUpdates.
     */
    cursor?: IncidentUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncidentUpdates.
     */
    distinct?: IncidentUpdateScalarFieldEnum | IncidentUpdateScalarFieldEnum[]
  }

  /**
   * IncidentUpdate findFirstOrThrow
   */
  export type IncidentUpdateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentUpdate
     */
    select?: IncidentUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentUpdateInclude<ExtArgs> | null
    /**
     * Filter, which IncidentUpdate to fetch.
     */
    where?: IncidentUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentUpdates to fetch.
     */
    orderBy?: IncidentUpdateOrderByWithRelationInput | IncidentUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncidentUpdates.
     */
    cursor?: IncidentUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncidentUpdates.
     */
    distinct?: IncidentUpdateScalarFieldEnum | IncidentUpdateScalarFieldEnum[]
  }

  /**
   * IncidentUpdate findMany
   */
  export type IncidentUpdateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentUpdate
     */
    select?: IncidentUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentUpdateInclude<ExtArgs> | null
    /**
     * Filter, which IncidentUpdates to fetch.
     */
    where?: IncidentUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentUpdates to fetch.
     */
    orderBy?: IncidentUpdateOrderByWithRelationInput | IncidentUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IncidentUpdates.
     */
    cursor?: IncidentUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentUpdates.
     */
    skip?: number
    distinct?: IncidentUpdateScalarFieldEnum | IncidentUpdateScalarFieldEnum[]
  }

  /**
   * IncidentUpdate create
   */
  export type IncidentUpdateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentUpdate
     */
    select?: IncidentUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentUpdateInclude<ExtArgs> | null
    /**
     * The data needed to create a IncidentUpdate.
     */
    data: XOR<IncidentUpdateCreateInput, IncidentUpdateUncheckedCreateInput>
  }

  /**
   * IncidentUpdate createMany
   */
  export type IncidentUpdateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IncidentUpdates.
     */
    data: IncidentUpdateCreateManyInput | IncidentUpdateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IncidentUpdate createManyAndReturn
   */
  export type IncidentUpdateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentUpdate
     */
    select?: IncidentUpdateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IncidentUpdates.
     */
    data: IncidentUpdateCreateManyInput | IncidentUpdateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentUpdateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IncidentUpdate update
   */
  export type IncidentUpdateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentUpdate
     */
    select?: IncidentUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentUpdateInclude<ExtArgs> | null
    /**
     * The data needed to update a IncidentUpdate.
     */
    data: XOR<IncidentUpdateUpdateInput, IncidentUpdateUncheckedUpdateInput>
    /**
     * Choose, which IncidentUpdate to update.
     */
    where: IncidentUpdateWhereUniqueInput
  }

  /**
   * IncidentUpdate updateMany
   */
  export type IncidentUpdateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IncidentUpdates.
     */
    data: XOR<IncidentUpdateUpdateManyMutationInput, IncidentUpdateUncheckedUpdateManyInput>
    /**
     * Filter which IncidentUpdates to update
     */
    where?: IncidentUpdateWhereInput
  }

  /**
   * IncidentUpdate upsert
   */
  export type IncidentUpdateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentUpdate
     */
    select?: IncidentUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentUpdateInclude<ExtArgs> | null
    /**
     * The filter to search for the IncidentUpdate to update in case it exists.
     */
    where: IncidentUpdateWhereUniqueInput
    /**
     * In case the IncidentUpdate found by the `where` argument doesn't exist, create a new IncidentUpdate with this data.
     */
    create: XOR<IncidentUpdateCreateInput, IncidentUpdateUncheckedCreateInput>
    /**
     * In case the IncidentUpdate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncidentUpdateUpdateInput, IncidentUpdateUncheckedUpdateInput>
  }

  /**
   * IncidentUpdate delete
   */
  export type IncidentUpdateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentUpdate
     */
    select?: IncidentUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentUpdateInclude<ExtArgs> | null
    /**
     * Filter which IncidentUpdate to delete.
     */
    where: IncidentUpdateWhereUniqueInput
  }

  /**
   * IncidentUpdate deleteMany
   */
  export type IncidentUpdateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncidentUpdates to delete
     */
    where?: IncidentUpdateWhereInput
  }

  /**
   * IncidentUpdate without action
   */
  export type IncidentUpdateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentUpdate
     */
    select?: IncidentUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentUpdateInclude<ExtArgs> | null
  }


  /**
   * Model IncidentCheck
   */

  export type AggregateIncidentCheck = {
    _count: IncidentCheckCountAggregateOutputType | null
    _min: IncidentCheckMinAggregateOutputType | null
    _max: IncidentCheckMaxAggregateOutputType | null
  }

  export type IncidentCheckMinAggregateOutputType = {
    incidentId: string | null
    checkId: string | null
  }

  export type IncidentCheckMaxAggregateOutputType = {
    incidentId: string | null
    checkId: string | null
  }

  export type IncidentCheckCountAggregateOutputType = {
    incidentId: number
    checkId: number
    _all: number
  }


  export type IncidentCheckMinAggregateInputType = {
    incidentId?: true
    checkId?: true
  }

  export type IncidentCheckMaxAggregateInputType = {
    incidentId?: true
    checkId?: true
  }

  export type IncidentCheckCountAggregateInputType = {
    incidentId?: true
    checkId?: true
    _all?: true
  }

  export type IncidentCheckAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncidentCheck to aggregate.
     */
    where?: IncidentCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentChecks to fetch.
     */
    orderBy?: IncidentCheckOrderByWithRelationInput | IncidentCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncidentCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IncidentChecks
    **/
    _count?: true | IncidentCheckCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncidentCheckMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncidentCheckMaxAggregateInputType
  }

  export type GetIncidentCheckAggregateType<T extends IncidentCheckAggregateArgs> = {
        [P in keyof T & keyof AggregateIncidentCheck]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncidentCheck[P]>
      : GetScalarType<T[P], AggregateIncidentCheck[P]>
  }




  export type IncidentCheckGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentCheckWhereInput
    orderBy?: IncidentCheckOrderByWithAggregationInput | IncidentCheckOrderByWithAggregationInput[]
    by: IncidentCheckScalarFieldEnum[] | IncidentCheckScalarFieldEnum
    having?: IncidentCheckScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncidentCheckCountAggregateInputType | true
    _min?: IncidentCheckMinAggregateInputType
    _max?: IncidentCheckMaxAggregateInputType
  }

  export type IncidentCheckGroupByOutputType = {
    incidentId: string
    checkId: string
    _count: IncidentCheckCountAggregateOutputType | null
    _min: IncidentCheckMinAggregateOutputType | null
    _max: IncidentCheckMaxAggregateOutputType | null
  }

  type GetIncidentCheckGroupByPayload<T extends IncidentCheckGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncidentCheckGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncidentCheckGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncidentCheckGroupByOutputType[P]>
            : GetScalarType<T[P], IncidentCheckGroupByOutputType[P]>
        }
      >
    >


  export type IncidentCheckSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    incidentId?: boolean
    checkId?: boolean
    incident?: boolean | IncidentDefaultArgs<ExtArgs>
    check?: boolean | CheckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incidentCheck"]>

  export type IncidentCheckSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    incidentId?: boolean
    checkId?: boolean
    incident?: boolean | IncidentDefaultArgs<ExtArgs>
    check?: boolean | CheckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incidentCheck"]>

  export type IncidentCheckSelectScalar = {
    incidentId?: boolean
    checkId?: boolean
  }

  export type IncidentCheckInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    incident?: boolean | IncidentDefaultArgs<ExtArgs>
    check?: boolean | CheckDefaultArgs<ExtArgs>
  }
  export type IncidentCheckIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    incident?: boolean | IncidentDefaultArgs<ExtArgs>
    check?: boolean | CheckDefaultArgs<ExtArgs>
  }

  export type $IncidentCheckPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IncidentCheck"
    objects: {
      incident: Prisma.$IncidentPayload<ExtArgs>
      check: Prisma.$CheckPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      incidentId: string
      checkId: string
    }, ExtArgs["result"]["incidentCheck"]>
    composites: {}
  }

  type IncidentCheckGetPayload<S extends boolean | null | undefined | IncidentCheckDefaultArgs> = $Result.GetResult<Prisma.$IncidentCheckPayload, S>

  type IncidentCheckCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IncidentCheckFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IncidentCheckCountAggregateInputType | true
    }

  export interface IncidentCheckDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IncidentCheck'], meta: { name: 'IncidentCheck' } }
    /**
     * Find zero or one IncidentCheck that matches the filter.
     * @param {IncidentCheckFindUniqueArgs} args - Arguments to find a IncidentCheck
     * @example
     * // Get one IncidentCheck
     * const incidentCheck = await prisma.incidentCheck.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncidentCheckFindUniqueArgs>(args: SelectSubset<T, IncidentCheckFindUniqueArgs<ExtArgs>>): Prisma__IncidentCheckClient<$Result.GetResult<Prisma.$IncidentCheckPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IncidentCheck that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IncidentCheckFindUniqueOrThrowArgs} args - Arguments to find a IncidentCheck
     * @example
     * // Get one IncidentCheck
     * const incidentCheck = await prisma.incidentCheck.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncidentCheckFindUniqueOrThrowArgs>(args: SelectSubset<T, IncidentCheckFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncidentCheckClient<$Result.GetResult<Prisma.$IncidentCheckPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IncidentCheck that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentCheckFindFirstArgs} args - Arguments to find a IncidentCheck
     * @example
     * // Get one IncidentCheck
     * const incidentCheck = await prisma.incidentCheck.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncidentCheckFindFirstArgs>(args?: SelectSubset<T, IncidentCheckFindFirstArgs<ExtArgs>>): Prisma__IncidentCheckClient<$Result.GetResult<Prisma.$IncidentCheckPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IncidentCheck that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentCheckFindFirstOrThrowArgs} args - Arguments to find a IncidentCheck
     * @example
     * // Get one IncidentCheck
     * const incidentCheck = await prisma.incidentCheck.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncidentCheckFindFirstOrThrowArgs>(args?: SelectSubset<T, IncidentCheckFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncidentCheckClient<$Result.GetResult<Prisma.$IncidentCheckPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IncidentChecks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentCheckFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IncidentChecks
     * const incidentChecks = await prisma.incidentCheck.findMany()
     * 
     * // Get first 10 IncidentChecks
     * const incidentChecks = await prisma.incidentCheck.findMany({ take: 10 })
     * 
     * // Only select the `incidentId`
     * const incidentCheckWithIncidentIdOnly = await prisma.incidentCheck.findMany({ select: { incidentId: true } })
     * 
     */
    findMany<T extends IncidentCheckFindManyArgs>(args?: SelectSubset<T, IncidentCheckFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentCheckPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IncidentCheck.
     * @param {IncidentCheckCreateArgs} args - Arguments to create a IncidentCheck.
     * @example
     * // Create one IncidentCheck
     * const IncidentCheck = await prisma.incidentCheck.create({
     *   data: {
     *     // ... data to create a IncidentCheck
     *   }
     * })
     * 
     */
    create<T extends IncidentCheckCreateArgs>(args: SelectSubset<T, IncidentCheckCreateArgs<ExtArgs>>): Prisma__IncidentCheckClient<$Result.GetResult<Prisma.$IncidentCheckPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IncidentChecks.
     * @param {IncidentCheckCreateManyArgs} args - Arguments to create many IncidentChecks.
     * @example
     * // Create many IncidentChecks
     * const incidentCheck = await prisma.incidentCheck.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncidentCheckCreateManyArgs>(args?: SelectSubset<T, IncidentCheckCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IncidentChecks and returns the data saved in the database.
     * @param {IncidentCheckCreateManyAndReturnArgs} args - Arguments to create many IncidentChecks.
     * @example
     * // Create many IncidentChecks
     * const incidentCheck = await prisma.incidentCheck.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IncidentChecks and only return the `incidentId`
     * const incidentCheckWithIncidentIdOnly = await prisma.incidentCheck.createManyAndReturn({ 
     *   select: { incidentId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IncidentCheckCreateManyAndReturnArgs>(args?: SelectSubset<T, IncidentCheckCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentCheckPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IncidentCheck.
     * @param {IncidentCheckDeleteArgs} args - Arguments to delete one IncidentCheck.
     * @example
     * // Delete one IncidentCheck
     * const IncidentCheck = await prisma.incidentCheck.delete({
     *   where: {
     *     // ... filter to delete one IncidentCheck
     *   }
     * })
     * 
     */
    delete<T extends IncidentCheckDeleteArgs>(args: SelectSubset<T, IncidentCheckDeleteArgs<ExtArgs>>): Prisma__IncidentCheckClient<$Result.GetResult<Prisma.$IncidentCheckPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IncidentCheck.
     * @param {IncidentCheckUpdateArgs} args - Arguments to update one IncidentCheck.
     * @example
     * // Update one IncidentCheck
     * const incidentCheck = await prisma.incidentCheck.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncidentCheckUpdateArgs>(args: SelectSubset<T, IncidentCheckUpdateArgs<ExtArgs>>): Prisma__IncidentCheckClient<$Result.GetResult<Prisma.$IncidentCheckPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IncidentChecks.
     * @param {IncidentCheckDeleteManyArgs} args - Arguments to filter IncidentChecks to delete.
     * @example
     * // Delete a few IncidentChecks
     * const { count } = await prisma.incidentCheck.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncidentCheckDeleteManyArgs>(args?: SelectSubset<T, IncidentCheckDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IncidentChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentCheckUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IncidentChecks
     * const incidentCheck = await prisma.incidentCheck.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncidentCheckUpdateManyArgs>(args: SelectSubset<T, IncidentCheckUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IncidentCheck.
     * @param {IncidentCheckUpsertArgs} args - Arguments to update or create a IncidentCheck.
     * @example
     * // Update or create a IncidentCheck
     * const incidentCheck = await prisma.incidentCheck.upsert({
     *   create: {
     *     // ... data to create a IncidentCheck
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IncidentCheck we want to update
     *   }
     * })
     */
    upsert<T extends IncidentCheckUpsertArgs>(args: SelectSubset<T, IncidentCheckUpsertArgs<ExtArgs>>): Prisma__IncidentCheckClient<$Result.GetResult<Prisma.$IncidentCheckPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IncidentChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentCheckCountArgs} args - Arguments to filter IncidentChecks to count.
     * @example
     * // Count the number of IncidentChecks
     * const count = await prisma.incidentCheck.count({
     *   where: {
     *     // ... the filter for the IncidentChecks we want to count
     *   }
     * })
    **/
    count<T extends IncidentCheckCountArgs>(
      args?: Subset<T, IncidentCheckCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncidentCheckCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IncidentCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentCheckAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncidentCheckAggregateArgs>(args: Subset<T, IncidentCheckAggregateArgs>): Prisma.PrismaPromise<GetIncidentCheckAggregateType<T>>

    /**
     * Group by IncidentCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentCheckGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncidentCheckGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncidentCheckGroupByArgs['orderBy'] }
        : { orderBy?: IncidentCheckGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncidentCheckGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncidentCheckGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IncidentCheck model
   */
  readonly fields: IncidentCheckFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IncidentCheck.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncidentCheckClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    incident<T extends IncidentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IncidentDefaultArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    check<T extends CheckDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CheckDefaultArgs<ExtArgs>>): Prisma__CheckClient<$Result.GetResult<Prisma.$CheckPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IncidentCheck model
   */ 
  interface IncidentCheckFieldRefs {
    readonly incidentId: FieldRef<"IncidentCheck", 'String'>
    readonly checkId: FieldRef<"IncidentCheck", 'String'>
  }
    

  // Custom InputTypes
  /**
   * IncidentCheck findUnique
   */
  export type IncidentCheckFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentCheck
     */
    select?: IncidentCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentCheckInclude<ExtArgs> | null
    /**
     * Filter, which IncidentCheck to fetch.
     */
    where: IncidentCheckWhereUniqueInput
  }

  /**
   * IncidentCheck findUniqueOrThrow
   */
  export type IncidentCheckFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentCheck
     */
    select?: IncidentCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentCheckInclude<ExtArgs> | null
    /**
     * Filter, which IncidentCheck to fetch.
     */
    where: IncidentCheckWhereUniqueInput
  }

  /**
   * IncidentCheck findFirst
   */
  export type IncidentCheckFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentCheck
     */
    select?: IncidentCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentCheckInclude<ExtArgs> | null
    /**
     * Filter, which IncidentCheck to fetch.
     */
    where?: IncidentCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentChecks to fetch.
     */
    orderBy?: IncidentCheckOrderByWithRelationInput | IncidentCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncidentChecks.
     */
    cursor?: IncidentCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncidentChecks.
     */
    distinct?: IncidentCheckScalarFieldEnum | IncidentCheckScalarFieldEnum[]
  }

  /**
   * IncidentCheck findFirstOrThrow
   */
  export type IncidentCheckFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentCheck
     */
    select?: IncidentCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentCheckInclude<ExtArgs> | null
    /**
     * Filter, which IncidentCheck to fetch.
     */
    where?: IncidentCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentChecks to fetch.
     */
    orderBy?: IncidentCheckOrderByWithRelationInput | IncidentCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncidentChecks.
     */
    cursor?: IncidentCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncidentChecks.
     */
    distinct?: IncidentCheckScalarFieldEnum | IncidentCheckScalarFieldEnum[]
  }

  /**
   * IncidentCheck findMany
   */
  export type IncidentCheckFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentCheck
     */
    select?: IncidentCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentCheckInclude<ExtArgs> | null
    /**
     * Filter, which IncidentChecks to fetch.
     */
    where?: IncidentCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentChecks to fetch.
     */
    orderBy?: IncidentCheckOrderByWithRelationInput | IncidentCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IncidentChecks.
     */
    cursor?: IncidentCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentChecks.
     */
    skip?: number
    distinct?: IncidentCheckScalarFieldEnum | IncidentCheckScalarFieldEnum[]
  }

  /**
   * IncidentCheck create
   */
  export type IncidentCheckCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentCheck
     */
    select?: IncidentCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentCheckInclude<ExtArgs> | null
    /**
     * The data needed to create a IncidentCheck.
     */
    data: XOR<IncidentCheckCreateInput, IncidentCheckUncheckedCreateInput>
  }

  /**
   * IncidentCheck createMany
   */
  export type IncidentCheckCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IncidentChecks.
     */
    data: IncidentCheckCreateManyInput | IncidentCheckCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IncidentCheck createManyAndReturn
   */
  export type IncidentCheckCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentCheck
     */
    select?: IncidentCheckSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IncidentChecks.
     */
    data: IncidentCheckCreateManyInput | IncidentCheckCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentCheckIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IncidentCheck update
   */
  export type IncidentCheckUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentCheck
     */
    select?: IncidentCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentCheckInclude<ExtArgs> | null
    /**
     * The data needed to update a IncidentCheck.
     */
    data: XOR<IncidentCheckUpdateInput, IncidentCheckUncheckedUpdateInput>
    /**
     * Choose, which IncidentCheck to update.
     */
    where: IncidentCheckWhereUniqueInput
  }

  /**
   * IncidentCheck updateMany
   */
  export type IncidentCheckUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IncidentChecks.
     */
    data: XOR<IncidentCheckUpdateManyMutationInput, IncidentCheckUncheckedUpdateManyInput>
    /**
     * Filter which IncidentChecks to update
     */
    where?: IncidentCheckWhereInput
  }

  /**
   * IncidentCheck upsert
   */
  export type IncidentCheckUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentCheck
     */
    select?: IncidentCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentCheckInclude<ExtArgs> | null
    /**
     * The filter to search for the IncidentCheck to update in case it exists.
     */
    where: IncidentCheckWhereUniqueInput
    /**
     * In case the IncidentCheck found by the `where` argument doesn't exist, create a new IncidentCheck with this data.
     */
    create: XOR<IncidentCheckCreateInput, IncidentCheckUncheckedCreateInput>
    /**
     * In case the IncidentCheck was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncidentCheckUpdateInput, IncidentCheckUncheckedUpdateInput>
  }

  /**
   * IncidentCheck delete
   */
  export type IncidentCheckDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentCheck
     */
    select?: IncidentCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentCheckInclude<ExtArgs> | null
    /**
     * Filter which IncidentCheck to delete.
     */
    where: IncidentCheckWhereUniqueInput
  }

  /**
   * IncidentCheck deleteMany
   */
  export type IncidentCheckDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncidentChecks to delete
     */
    where?: IncidentCheckWhereInput
  }

  /**
   * IncidentCheck without action
   */
  export type IncidentCheckDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentCheck
     */
    select?: IncidentCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentCheckInclude<ExtArgs> | null
  }


  /**
   * Model Maintenance
   */

  export type AggregateMaintenance = {
    _count: MaintenanceCountAggregateOutputType | null
    _min: MaintenanceMinAggregateOutputType | null
    _max: MaintenanceMaxAggregateOutputType | null
  }

  export type MaintenanceMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    title: string | null
    description: string | null
    startsAt: Date | null
    endsAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaintenanceMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    title: string | null
    description: string | null
    startsAt: Date | null
    endsAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaintenanceCountAggregateOutputType = {
    id: number
    projectId: number
    title: number
    description: number
    startsAt: number
    endsAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MaintenanceMinAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    description?: true
    startsAt?: true
    endsAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaintenanceMaxAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    description?: true
    startsAt?: true
    endsAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaintenanceCountAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    description?: true
    startsAt?: true
    endsAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MaintenanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Maintenance to aggregate.
     */
    where?: MaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintenances to fetch.
     */
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Maintenances
    **/
    _count?: true | MaintenanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaintenanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaintenanceMaxAggregateInputType
  }

  export type GetMaintenanceAggregateType<T extends MaintenanceAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintenance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintenance[P]>
      : GetScalarType<T[P], AggregateMaintenance[P]>
  }




  export type MaintenanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceWhereInput
    orderBy?: MaintenanceOrderByWithAggregationInput | MaintenanceOrderByWithAggregationInput[]
    by: MaintenanceScalarFieldEnum[] | MaintenanceScalarFieldEnum
    having?: MaintenanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaintenanceCountAggregateInputType | true
    _min?: MaintenanceMinAggregateInputType
    _max?: MaintenanceMaxAggregateInputType
  }

  export type MaintenanceGroupByOutputType = {
    id: string
    projectId: string
    title: string
    description: string | null
    startsAt: Date
    endsAt: Date
    createdAt: Date
    updatedAt: Date
    _count: MaintenanceCountAggregateOutputType | null
    _min: MaintenanceMinAggregateOutputType | null
    _max: MaintenanceMaxAggregateOutputType | null
  }

  type GetMaintenanceGroupByPayload<T extends MaintenanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaintenanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaintenanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaintenanceGroupByOutputType[P]>
            : GetScalarType<T[P], MaintenanceGroupByOutputType[P]>
        }
      >
    >


  export type MaintenanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    startsAt?: boolean
    endsAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    checks?: boolean | Maintenance$checksArgs<ExtArgs>
    _count?: boolean | MaintenanceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenance"]>

  export type MaintenanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    startsAt?: boolean
    endsAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenance"]>

  export type MaintenanceSelectScalar = {
    id?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    startsAt?: boolean
    endsAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MaintenanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    checks?: boolean | Maintenance$checksArgs<ExtArgs>
    _count?: boolean | MaintenanceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MaintenanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $MaintenancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Maintenance"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      checks: Prisma.$MaintenanceCheckPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      title: string
      description: string | null
      startsAt: Date
      endsAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["maintenance"]>
    composites: {}
  }

  type MaintenanceGetPayload<S extends boolean | null | undefined | MaintenanceDefaultArgs> = $Result.GetResult<Prisma.$MaintenancePayload, S>

  type MaintenanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaintenanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaintenanceCountAggregateInputType | true
    }

  export interface MaintenanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Maintenance'], meta: { name: 'Maintenance' } }
    /**
     * Find zero or one Maintenance that matches the filter.
     * @param {MaintenanceFindUniqueArgs} args - Arguments to find a Maintenance
     * @example
     * // Get one Maintenance
     * const maintenance = await prisma.maintenance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaintenanceFindUniqueArgs>(args: SelectSubset<T, MaintenanceFindUniqueArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Maintenance that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MaintenanceFindUniqueOrThrowArgs} args - Arguments to find a Maintenance
     * @example
     * // Get one Maintenance
     * const maintenance = await prisma.maintenance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaintenanceFindUniqueOrThrowArgs>(args: SelectSubset<T, MaintenanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Maintenance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceFindFirstArgs} args - Arguments to find a Maintenance
     * @example
     * // Get one Maintenance
     * const maintenance = await prisma.maintenance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaintenanceFindFirstArgs>(args?: SelectSubset<T, MaintenanceFindFirstArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Maintenance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceFindFirstOrThrowArgs} args - Arguments to find a Maintenance
     * @example
     * // Get one Maintenance
     * const maintenance = await prisma.maintenance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaintenanceFindFirstOrThrowArgs>(args?: SelectSubset<T, MaintenanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Maintenances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Maintenances
     * const maintenances = await prisma.maintenance.findMany()
     * 
     * // Get first 10 Maintenances
     * const maintenances = await prisma.maintenance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maintenanceWithIdOnly = await prisma.maintenance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaintenanceFindManyArgs>(args?: SelectSubset<T, MaintenanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Maintenance.
     * @param {MaintenanceCreateArgs} args - Arguments to create a Maintenance.
     * @example
     * // Create one Maintenance
     * const Maintenance = await prisma.maintenance.create({
     *   data: {
     *     // ... data to create a Maintenance
     *   }
     * })
     * 
     */
    create<T extends MaintenanceCreateArgs>(args: SelectSubset<T, MaintenanceCreateArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Maintenances.
     * @param {MaintenanceCreateManyArgs} args - Arguments to create many Maintenances.
     * @example
     * // Create many Maintenances
     * const maintenance = await prisma.maintenance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaintenanceCreateManyArgs>(args?: SelectSubset<T, MaintenanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Maintenances and returns the data saved in the database.
     * @param {MaintenanceCreateManyAndReturnArgs} args - Arguments to create many Maintenances.
     * @example
     * // Create many Maintenances
     * const maintenance = await prisma.maintenance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Maintenances and only return the `id`
     * const maintenanceWithIdOnly = await prisma.maintenance.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaintenanceCreateManyAndReturnArgs>(args?: SelectSubset<T, MaintenanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Maintenance.
     * @param {MaintenanceDeleteArgs} args - Arguments to delete one Maintenance.
     * @example
     * // Delete one Maintenance
     * const Maintenance = await prisma.maintenance.delete({
     *   where: {
     *     // ... filter to delete one Maintenance
     *   }
     * })
     * 
     */
    delete<T extends MaintenanceDeleteArgs>(args: SelectSubset<T, MaintenanceDeleteArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Maintenance.
     * @param {MaintenanceUpdateArgs} args - Arguments to update one Maintenance.
     * @example
     * // Update one Maintenance
     * const maintenance = await prisma.maintenance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaintenanceUpdateArgs>(args: SelectSubset<T, MaintenanceUpdateArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Maintenances.
     * @param {MaintenanceDeleteManyArgs} args - Arguments to filter Maintenances to delete.
     * @example
     * // Delete a few Maintenances
     * const { count } = await prisma.maintenance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaintenanceDeleteManyArgs>(args?: SelectSubset<T, MaintenanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maintenances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Maintenances
     * const maintenance = await prisma.maintenance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaintenanceUpdateManyArgs>(args: SelectSubset<T, MaintenanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Maintenance.
     * @param {MaintenanceUpsertArgs} args - Arguments to update or create a Maintenance.
     * @example
     * // Update or create a Maintenance
     * const maintenance = await prisma.maintenance.upsert({
     *   create: {
     *     // ... data to create a Maintenance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Maintenance we want to update
     *   }
     * })
     */
    upsert<T extends MaintenanceUpsertArgs>(args: SelectSubset<T, MaintenanceUpsertArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Maintenances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceCountArgs} args - Arguments to filter Maintenances to count.
     * @example
     * // Count the number of Maintenances
     * const count = await prisma.maintenance.count({
     *   where: {
     *     // ... the filter for the Maintenances we want to count
     *   }
     * })
    **/
    count<T extends MaintenanceCountArgs>(
      args?: Subset<T, MaintenanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaintenanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Maintenance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaintenanceAggregateArgs>(args: Subset<T, MaintenanceAggregateArgs>): Prisma.PrismaPromise<GetMaintenanceAggregateType<T>>

    /**
     * Group by Maintenance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaintenanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaintenanceGroupByArgs['orderBy'] }
        : { orderBy?: MaintenanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaintenanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintenanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Maintenance model
   */
  readonly fields: MaintenanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Maintenance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaintenanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    checks<T extends Maintenance$checksArgs<ExtArgs> = {}>(args?: Subset<T, Maintenance$checksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceCheckPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Maintenance model
   */ 
  interface MaintenanceFieldRefs {
    readonly id: FieldRef<"Maintenance", 'String'>
    readonly projectId: FieldRef<"Maintenance", 'String'>
    readonly title: FieldRef<"Maintenance", 'String'>
    readonly description: FieldRef<"Maintenance", 'String'>
    readonly startsAt: FieldRef<"Maintenance", 'DateTime'>
    readonly endsAt: FieldRef<"Maintenance", 'DateTime'>
    readonly createdAt: FieldRef<"Maintenance", 'DateTime'>
    readonly updatedAt: FieldRef<"Maintenance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Maintenance findUnique
   */
  export type MaintenanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which Maintenance to fetch.
     */
    where: MaintenanceWhereUniqueInput
  }

  /**
   * Maintenance findUniqueOrThrow
   */
  export type MaintenanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which Maintenance to fetch.
     */
    where: MaintenanceWhereUniqueInput
  }

  /**
   * Maintenance findFirst
   */
  export type MaintenanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which Maintenance to fetch.
     */
    where?: MaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintenances to fetch.
     */
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Maintenances.
     */
    cursor?: MaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Maintenances.
     */
    distinct?: MaintenanceScalarFieldEnum | MaintenanceScalarFieldEnum[]
  }

  /**
   * Maintenance findFirstOrThrow
   */
  export type MaintenanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which Maintenance to fetch.
     */
    where?: MaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintenances to fetch.
     */
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Maintenances.
     */
    cursor?: MaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Maintenances.
     */
    distinct?: MaintenanceScalarFieldEnum | MaintenanceScalarFieldEnum[]
  }

  /**
   * Maintenance findMany
   */
  export type MaintenanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which Maintenances to fetch.
     */
    where?: MaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintenances to fetch.
     */
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Maintenances.
     */
    cursor?: MaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintenances.
     */
    skip?: number
    distinct?: MaintenanceScalarFieldEnum | MaintenanceScalarFieldEnum[]
  }

  /**
   * Maintenance create
   */
  export type MaintenanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Maintenance.
     */
    data: XOR<MaintenanceCreateInput, MaintenanceUncheckedCreateInput>
  }

  /**
   * Maintenance createMany
   */
  export type MaintenanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Maintenances.
     */
    data: MaintenanceCreateManyInput | MaintenanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Maintenance createManyAndReturn
   */
  export type MaintenanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Maintenances.
     */
    data: MaintenanceCreateManyInput | MaintenanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Maintenance update
   */
  export type MaintenanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Maintenance.
     */
    data: XOR<MaintenanceUpdateInput, MaintenanceUncheckedUpdateInput>
    /**
     * Choose, which Maintenance to update.
     */
    where: MaintenanceWhereUniqueInput
  }

  /**
   * Maintenance updateMany
   */
  export type MaintenanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Maintenances.
     */
    data: XOR<MaintenanceUpdateManyMutationInput, MaintenanceUncheckedUpdateManyInput>
    /**
     * Filter which Maintenances to update
     */
    where?: MaintenanceWhereInput
  }

  /**
   * Maintenance upsert
   */
  export type MaintenanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Maintenance to update in case it exists.
     */
    where: MaintenanceWhereUniqueInput
    /**
     * In case the Maintenance found by the `where` argument doesn't exist, create a new Maintenance with this data.
     */
    create: XOR<MaintenanceCreateInput, MaintenanceUncheckedCreateInput>
    /**
     * In case the Maintenance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaintenanceUpdateInput, MaintenanceUncheckedUpdateInput>
  }

  /**
   * Maintenance delete
   */
  export type MaintenanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter which Maintenance to delete.
     */
    where: MaintenanceWhereUniqueInput
  }

  /**
   * Maintenance deleteMany
   */
  export type MaintenanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Maintenances to delete
     */
    where?: MaintenanceWhereInput
  }

  /**
   * Maintenance.checks
   */
  export type Maintenance$checksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceCheck
     */
    select?: MaintenanceCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceCheckInclude<ExtArgs> | null
    where?: MaintenanceCheckWhereInput
    orderBy?: MaintenanceCheckOrderByWithRelationInput | MaintenanceCheckOrderByWithRelationInput[]
    cursor?: MaintenanceCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceCheckScalarFieldEnum | MaintenanceCheckScalarFieldEnum[]
  }

  /**
   * Maintenance without action
   */
  export type MaintenanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
  }


  /**
   * Model MaintenanceCheck
   */

  export type AggregateMaintenanceCheck = {
    _count: MaintenanceCheckCountAggregateOutputType | null
    _min: MaintenanceCheckMinAggregateOutputType | null
    _max: MaintenanceCheckMaxAggregateOutputType | null
  }

  export type MaintenanceCheckMinAggregateOutputType = {
    maintenanceId: string | null
    checkId: string | null
  }

  export type MaintenanceCheckMaxAggregateOutputType = {
    maintenanceId: string | null
    checkId: string | null
  }

  export type MaintenanceCheckCountAggregateOutputType = {
    maintenanceId: number
    checkId: number
    _all: number
  }


  export type MaintenanceCheckMinAggregateInputType = {
    maintenanceId?: true
    checkId?: true
  }

  export type MaintenanceCheckMaxAggregateInputType = {
    maintenanceId?: true
    checkId?: true
  }

  export type MaintenanceCheckCountAggregateInputType = {
    maintenanceId?: true
    checkId?: true
    _all?: true
  }

  export type MaintenanceCheckAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceCheck to aggregate.
     */
    where?: MaintenanceCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceChecks to fetch.
     */
    orderBy?: MaintenanceCheckOrderByWithRelationInput | MaintenanceCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaintenanceCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaintenanceChecks
    **/
    _count?: true | MaintenanceCheckCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaintenanceCheckMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaintenanceCheckMaxAggregateInputType
  }

  export type GetMaintenanceCheckAggregateType<T extends MaintenanceCheckAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintenanceCheck]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintenanceCheck[P]>
      : GetScalarType<T[P], AggregateMaintenanceCheck[P]>
  }




  export type MaintenanceCheckGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceCheckWhereInput
    orderBy?: MaintenanceCheckOrderByWithAggregationInput | MaintenanceCheckOrderByWithAggregationInput[]
    by: MaintenanceCheckScalarFieldEnum[] | MaintenanceCheckScalarFieldEnum
    having?: MaintenanceCheckScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaintenanceCheckCountAggregateInputType | true
    _min?: MaintenanceCheckMinAggregateInputType
    _max?: MaintenanceCheckMaxAggregateInputType
  }

  export type MaintenanceCheckGroupByOutputType = {
    maintenanceId: string
    checkId: string
    _count: MaintenanceCheckCountAggregateOutputType | null
    _min: MaintenanceCheckMinAggregateOutputType | null
    _max: MaintenanceCheckMaxAggregateOutputType | null
  }

  type GetMaintenanceCheckGroupByPayload<T extends MaintenanceCheckGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaintenanceCheckGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaintenanceCheckGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaintenanceCheckGroupByOutputType[P]>
            : GetScalarType<T[P], MaintenanceCheckGroupByOutputType[P]>
        }
      >
    >


  export type MaintenanceCheckSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    maintenanceId?: boolean
    checkId?: boolean
    maintenance?: boolean | MaintenanceDefaultArgs<ExtArgs>
    check?: boolean | CheckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceCheck"]>

  export type MaintenanceCheckSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    maintenanceId?: boolean
    checkId?: boolean
    maintenance?: boolean | MaintenanceDefaultArgs<ExtArgs>
    check?: boolean | CheckDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceCheck"]>

  export type MaintenanceCheckSelectScalar = {
    maintenanceId?: boolean
    checkId?: boolean
  }

  export type MaintenanceCheckInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maintenance?: boolean | MaintenanceDefaultArgs<ExtArgs>
    check?: boolean | CheckDefaultArgs<ExtArgs>
  }
  export type MaintenanceCheckIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maintenance?: boolean | MaintenanceDefaultArgs<ExtArgs>
    check?: boolean | CheckDefaultArgs<ExtArgs>
  }

  export type $MaintenanceCheckPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaintenanceCheck"
    objects: {
      maintenance: Prisma.$MaintenancePayload<ExtArgs>
      check: Prisma.$CheckPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      maintenanceId: string
      checkId: string
    }, ExtArgs["result"]["maintenanceCheck"]>
    composites: {}
  }

  type MaintenanceCheckGetPayload<S extends boolean | null | undefined | MaintenanceCheckDefaultArgs> = $Result.GetResult<Prisma.$MaintenanceCheckPayload, S>

  type MaintenanceCheckCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaintenanceCheckFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaintenanceCheckCountAggregateInputType | true
    }

  export interface MaintenanceCheckDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaintenanceCheck'], meta: { name: 'MaintenanceCheck' } }
    /**
     * Find zero or one MaintenanceCheck that matches the filter.
     * @param {MaintenanceCheckFindUniqueArgs} args - Arguments to find a MaintenanceCheck
     * @example
     * // Get one MaintenanceCheck
     * const maintenanceCheck = await prisma.maintenanceCheck.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaintenanceCheckFindUniqueArgs>(args: SelectSubset<T, MaintenanceCheckFindUniqueArgs<ExtArgs>>): Prisma__MaintenanceCheckClient<$Result.GetResult<Prisma.$MaintenanceCheckPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MaintenanceCheck that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MaintenanceCheckFindUniqueOrThrowArgs} args - Arguments to find a MaintenanceCheck
     * @example
     * // Get one MaintenanceCheck
     * const maintenanceCheck = await prisma.maintenanceCheck.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaintenanceCheckFindUniqueOrThrowArgs>(args: SelectSubset<T, MaintenanceCheckFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaintenanceCheckClient<$Result.GetResult<Prisma.$MaintenanceCheckPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MaintenanceCheck that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceCheckFindFirstArgs} args - Arguments to find a MaintenanceCheck
     * @example
     * // Get one MaintenanceCheck
     * const maintenanceCheck = await prisma.maintenanceCheck.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaintenanceCheckFindFirstArgs>(args?: SelectSubset<T, MaintenanceCheckFindFirstArgs<ExtArgs>>): Prisma__MaintenanceCheckClient<$Result.GetResult<Prisma.$MaintenanceCheckPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MaintenanceCheck that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceCheckFindFirstOrThrowArgs} args - Arguments to find a MaintenanceCheck
     * @example
     * // Get one MaintenanceCheck
     * const maintenanceCheck = await prisma.maintenanceCheck.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaintenanceCheckFindFirstOrThrowArgs>(args?: SelectSubset<T, MaintenanceCheckFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaintenanceCheckClient<$Result.GetResult<Prisma.$MaintenanceCheckPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MaintenanceChecks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceCheckFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaintenanceChecks
     * const maintenanceChecks = await prisma.maintenanceCheck.findMany()
     * 
     * // Get first 10 MaintenanceChecks
     * const maintenanceChecks = await prisma.maintenanceCheck.findMany({ take: 10 })
     * 
     * // Only select the `maintenanceId`
     * const maintenanceCheckWithMaintenanceIdOnly = await prisma.maintenanceCheck.findMany({ select: { maintenanceId: true } })
     * 
     */
    findMany<T extends MaintenanceCheckFindManyArgs>(args?: SelectSubset<T, MaintenanceCheckFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceCheckPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MaintenanceCheck.
     * @param {MaintenanceCheckCreateArgs} args - Arguments to create a MaintenanceCheck.
     * @example
     * // Create one MaintenanceCheck
     * const MaintenanceCheck = await prisma.maintenanceCheck.create({
     *   data: {
     *     // ... data to create a MaintenanceCheck
     *   }
     * })
     * 
     */
    create<T extends MaintenanceCheckCreateArgs>(args: SelectSubset<T, MaintenanceCheckCreateArgs<ExtArgs>>): Prisma__MaintenanceCheckClient<$Result.GetResult<Prisma.$MaintenanceCheckPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MaintenanceChecks.
     * @param {MaintenanceCheckCreateManyArgs} args - Arguments to create many MaintenanceChecks.
     * @example
     * // Create many MaintenanceChecks
     * const maintenanceCheck = await prisma.maintenanceCheck.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaintenanceCheckCreateManyArgs>(args?: SelectSubset<T, MaintenanceCheckCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MaintenanceChecks and returns the data saved in the database.
     * @param {MaintenanceCheckCreateManyAndReturnArgs} args - Arguments to create many MaintenanceChecks.
     * @example
     * // Create many MaintenanceChecks
     * const maintenanceCheck = await prisma.maintenanceCheck.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MaintenanceChecks and only return the `maintenanceId`
     * const maintenanceCheckWithMaintenanceIdOnly = await prisma.maintenanceCheck.createManyAndReturn({ 
     *   select: { maintenanceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaintenanceCheckCreateManyAndReturnArgs>(args?: SelectSubset<T, MaintenanceCheckCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceCheckPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MaintenanceCheck.
     * @param {MaintenanceCheckDeleteArgs} args - Arguments to delete one MaintenanceCheck.
     * @example
     * // Delete one MaintenanceCheck
     * const MaintenanceCheck = await prisma.maintenanceCheck.delete({
     *   where: {
     *     // ... filter to delete one MaintenanceCheck
     *   }
     * })
     * 
     */
    delete<T extends MaintenanceCheckDeleteArgs>(args: SelectSubset<T, MaintenanceCheckDeleteArgs<ExtArgs>>): Prisma__MaintenanceCheckClient<$Result.GetResult<Prisma.$MaintenanceCheckPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MaintenanceCheck.
     * @param {MaintenanceCheckUpdateArgs} args - Arguments to update one MaintenanceCheck.
     * @example
     * // Update one MaintenanceCheck
     * const maintenanceCheck = await prisma.maintenanceCheck.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaintenanceCheckUpdateArgs>(args: SelectSubset<T, MaintenanceCheckUpdateArgs<ExtArgs>>): Prisma__MaintenanceCheckClient<$Result.GetResult<Prisma.$MaintenanceCheckPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MaintenanceChecks.
     * @param {MaintenanceCheckDeleteManyArgs} args - Arguments to filter MaintenanceChecks to delete.
     * @example
     * // Delete a few MaintenanceChecks
     * const { count } = await prisma.maintenanceCheck.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaintenanceCheckDeleteManyArgs>(args?: SelectSubset<T, MaintenanceCheckDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenanceChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceCheckUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaintenanceChecks
     * const maintenanceCheck = await prisma.maintenanceCheck.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaintenanceCheckUpdateManyArgs>(args: SelectSubset<T, MaintenanceCheckUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MaintenanceCheck.
     * @param {MaintenanceCheckUpsertArgs} args - Arguments to update or create a MaintenanceCheck.
     * @example
     * // Update or create a MaintenanceCheck
     * const maintenanceCheck = await prisma.maintenanceCheck.upsert({
     *   create: {
     *     // ... data to create a MaintenanceCheck
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaintenanceCheck we want to update
     *   }
     * })
     */
    upsert<T extends MaintenanceCheckUpsertArgs>(args: SelectSubset<T, MaintenanceCheckUpsertArgs<ExtArgs>>): Prisma__MaintenanceCheckClient<$Result.GetResult<Prisma.$MaintenanceCheckPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MaintenanceChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceCheckCountArgs} args - Arguments to filter MaintenanceChecks to count.
     * @example
     * // Count the number of MaintenanceChecks
     * const count = await prisma.maintenanceCheck.count({
     *   where: {
     *     // ... the filter for the MaintenanceChecks we want to count
     *   }
     * })
    **/
    count<T extends MaintenanceCheckCountArgs>(
      args?: Subset<T, MaintenanceCheckCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaintenanceCheckCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaintenanceCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceCheckAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaintenanceCheckAggregateArgs>(args: Subset<T, MaintenanceCheckAggregateArgs>): Prisma.PrismaPromise<GetMaintenanceCheckAggregateType<T>>

    /**
     * Group by MaintenanceCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceCheckGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaintenanceCheckGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaintenanceCheckGroupByArgs['orderBy'] }
        : { orderBy?: MaintenanceCheckGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaintenanceCheckGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintenanceCheckGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaintenanceCheck model
   */
  readonly fields: MaintenanceCheckFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaintenanceCheck.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaintenanceCheckClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    maintenance<T extends MaintenanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaintenanceDefaultArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    check<T extends CheckDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CheckDefaultArgs<ExtArgs>>): Prisma__CheckClient<$Result.GetResult<Prisma.$CheckPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaintenanceCheck model
   */ 
  interface MaintenanceCheckFieldRefs {
    readonly maintenanceId: FieldRef<"MaintenanceCheck", 'String'>
    readonly checkId: FieldRef<"MaintenanceCheck", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MaintenanceCheck findUnique
   */
  export type MaintenanceCheckFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceCheck
     */
    select?: MaintenanceCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceCheckInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceCheck to fetch.
     */
    where: MaintenanceCheckWhereUniqueInput
  }

  /**
   * MaintenanceCheck findUniqueOrThrow
   */
  export type MaintenanceCheckFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceCheck
     */
    select?: MaintenanceCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceCheckInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceCheck to fetch.
     */
    where: MaintenanceCheckWhereUniqueInput
  }

  /**
   * MaintenanceCheck findFirst
   */
  export type MaintenanceCheckFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceCheck
     */
    select?: MaintenanceCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceCheckInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceCheck to fetch.
     */
    where?: MaintenanceCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceChecks to fetch.
     */
    orderBy?: MaintenanceCheckOrderByWithRelationInput | MaintenanceCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceChecks.
     */
    cursor?: MaintenanceCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceChecks.
     */
    distinct?: MaintenanceCheckScalarFieldEnum | MaintenanceCheckScalarFieldEnum[]
  }

  /**
   * MaintenanceCheck findFirstOrThrow
   */
  export type MaintenanceCheckFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceCheck
     */
    select?: MaintenanceCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceCheckInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceCheck to fetch.
     */
    where?: MaintenanceCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceChecks to fetch.
     */
    orderBy?: MaintenanceCheckOrderByWithRelationInput | MaintenanceCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceChecks.
     */
    cursor?: MaintenanceCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceChecks.
     */
    distinct?: MaintenanceCheckScalarFieldEnum | MaintenanceCheckScalarFieldEnum[]
  }

  /**
   * MaintenanceCheck findMany
   */
  export type MaintenanceCheckFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceCheck
     */
    select?: MaintenanceCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceCheckInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceChecks to fetch.
     */
    where?: MaintenanceCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceChecks to fetch.
     */
    orderBy?: MaintenanceCheckOrderByWithRelationInput | MaintenanceCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaintenanceChecks.
     */
    cursor?: MaintenanceCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceChecks.
     */
    skip?: number
    distinct?: MaintenanceCheckScalarFieldEnum | MaintenanceCheckScalarFieldEnum[]
  }

  /**
   * MaintenanceCheck create
   */
  export type MaintenanceCheckCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceCheck
     */
    select?: MaintenanceCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceCheckInclude<ExtArgs> | null
    /**
     * The data needed to create a MaintenanceCheck.
     */
    data: XOR<MaintenanceCheckCreateInput, MaintenanceCheckUncheckedCreateInput>
  }

  /**
   * MaintenanceCheck createMany
   */
  export type MaintenanceCheckCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaintenanceChecks.
     */
    data: MaintenanceCheckCreateManyInput | MaintenanceCheckCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaintenanceCheck createManyAndReturn
   */
  export type MaintenanceCheckCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceCheck
     */
    select?: MaintenanceCheckSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MaintenanceChecks.
     */
    data: MaintenanceCheckCreateManyInput | MaintenanceCheckCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceCheckIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaintenanceCheck update
   */
  export type MaintenanceCheckUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceCheck
     */
    select?: MaintenanceCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceCheckInclude<ExtArgs> | null
    /**
     * The data needed to update a MaintenanceCheck.
     */
    data: XOR<MaintenanceCheckUpdateInput, MaintenanceCheckUncheckedUpdateInput>
    /**
     * Choose, which MaintenanceCheck to update.
     */
    where: MaintenanceCheckWhereUniqueInput
  }

  /**
   * MaintenanceCheck updateMany
   */
  export type MaintenanceCheckUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaintenanceChecks.
     */
    data: XOR<MaintenanceCheckUpdateManyMutationInput, MaintenanceCheckUncheckedUpdateManyInput>
    /**
     * Filter which MaintenanceChecks to update
     */
    where?: MaintenanceCheckWhereInput
  }

  /**
   * MaintenanceCheck upsert
   */
  export type MaintenanceCheckUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceCheck
     */
    select?: MaintenanceCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceCheckInclude<ExtArgs> | null
    /**
     * The filter to search for the MaintenanceCheck to update in case it exists.
     */
    where: MaintenanceCheckWhereUniqueInput
    /**
     * In case the MaintenanceCheck found by the `where` argument doesn't exist, create a new MaintenanceCheck with this data.
     */
    create: XOR<MaintenanceCheckCreateInput, MaintenanceCheckUncheckedCreateInput>
    /**
     * In case the MaintenanceCheck was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaintenanceCheckUpdateInput, MaintenanceCheckUncheckedUpdateInput>
  }

  /**
   * MaintenanceCheck delete
   */
  export type MaintenanceCheckDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceCheck
     */
    select?: MaintenanceCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceCheckInclude<ExtArgs> | null
    /**
     * Filter which MaintenanceCheck to delete.
     */
    where: MaintenanceCheckWhereUniqueInput
  }

  /**
   * MaintenanceCheck deleteMany
   */
  export type MaintenanceCheckDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceChecks to delete
     */
    where?: MaintenanceCheckWhereInput
  }

  /**
   * MaintenanceCheck without action
   */
  export type MaintenanceCheckDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceCheck
     */
    select?: MaintenanceCheckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceCheckInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    emailVerified: 'emailVerified',
    name: 'name',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    plan: 'plan',
    stripeCustomerId: 'stripeCustomerId',
    stripeSubscriptionId: 'stripeSubscriptionId',
    trialEndsAt: 'trialEndsAt',
    autoCreateIncidents: 'autoCreateIncidents',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const OrgMemberScalarFieldEnum: {
    id: 'id',
    role: 'role',
    userId: 'userId',
    orgId: 'orgId',
    createdAt: 'createdAt'
  };

  export type OrgMemberScalarFieldEnum = (typeof OrgMemberScalarFieldEnum)[keyof typeof OrgMemberScalarFieldEnum]


  export const InvitationScalarFieldEnum: {
    id: 'id',
    email: 'email',
    orgId: 'orgId',
    role: 'role',
    token: 'token',
    expiresAt: 'expiresAt',
    acceptedAt: 'acceptedAt',
    createdAt: 'createdAt'
  };

  export type InvitationScalarFieldEnum = (typeof InvitationScalarFieldEnum)[keyof typeof InvitationScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    accountId: 'accountId',
    providerId: 'providerId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    scope: 'scope',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    name: 'name',
    slug: 'slug',
    timezone: 'timezone',
    statusPageEnabled: 'statusPageEnabled',
    statusPageTitle: 'statusPageTitle',
    statusPageLogoUrl: 'statusPageLogoUrl',
    customDomain: 'customDomain',
    domainVerified: 'domainVerified',
    domainVerifyToken: 'domainVerifyToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const CheckScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    slug: 'slug',
    scheduleType: 'scheduleType',
    scheduleValue: 'scheduleValue',
    graceSeconds: 'graceSeconds',
    timezone: 'timezone',
    status: 'status',
    lastPingAt: 'lastPingAt',
    lastStartedAt: 'lastStartedAt',
    nextExpectedAt: 'nextExpectedAt',
    lastAlertAt: 'lastAlertAt',
    alertOnRecovery: 'alertOnRecovery',
    reminderIntervalHours: 'reminderIntervalHours',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CheckScalarFieldEnum = (typeof CheckScalarFieldEnum)[keyof typeof CheckScalarFieldEnum]


  export const PingScalarFieldEnum: {
    id: 'id',
    checkId: 'checkId',
    type: 'type',
    body: 'body',
    sourceIp: 'sourceIp',
    createdAt: 'createdAt'
  };

  export type PingScalarFieldEnum = (typeof PingScalarFieldEnum)[keyof typeof PingScalarFieldEnum]


  export const CheckDailyStatScalarFieldEnum: {
    id: 'id',
    checkId: 'checkId',
    date: 'date',
    upMinutes: 'upMinutes',
    downMinutes: 'downMinutes',
    totalPings: 'totalPings',
    upPercent: 'upPercent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CheckDailyStatScalarFieldEnum = (typeof CheckDailyStatScalarFieldEnum)[keyof typeof CheckDailyStatScalarFieldEnum]


  export const ChannelScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    type: 'type',
    name: 'name',
    config: 'config',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChannelScalarFieldEnum = (typeof ChannelScalarFieldEnum)[keyof typeof ChannelScalarFieldEnum]


  export const CheckChannelScalarFieldEnum: {
    checkId: 'checkId',
    channelId: 'channelId'
  };

  export type CheckChannelScalarFieldEnum = (typeof CheckChannelScalarFieldEnum)[keyof typeof CheckChannelScalarFieldEnum]


  export const AlertScalarFieldEnum: {
    id: 'id',
    checkId: 'checkId',
    event: 'event',
    channels: 'channels',
    success: 'success',
    error: 'error',
    createdAt: 'createdAt'
  };

  export type AlertScalarFieldEnum = (typeof AlertScalarFieldEnum)[keyof typeof AlertScalarFieldEnum]


  export const ApiKeyScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    keyHash: 'keyHash',
    keyPrefix: 'keyPrefix',
    lastUsedAt: 'lastUsedAt',
    createdAt: 'createdAt'
  };

  export type ApiKeyScalarFieldEnum = (typeof ApiKeyScalarFieldEnum)[keyof typeof ApiKeyScalarFieldEnum]


  export const IncidentScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    title: 'title',
    status: 'status',
    impact: 'impact',
    autoCreated: 'autoCreated',
    resolvedAt: 'resolvedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IncidentScalarFieldEnum = (typeof IncidentScalarFieldEnum)[keyof typeof IncidentScalarFieldEnum]


  export const IncidentUpdateScalarFieldEnum: {
    id: 'id',
    incidentId: 'incidentId',
    status: 'status',
    message: 'message',
    createdAt: 'createdAt'
  };

  export type IncidentUpdateScalarFieldEnum = (typeof IncidentUpdateScalarFieldEnum)[keyof typeof IncidentUpdateScalarFieldEnum]


  export const IncidentCheckScalarFieldEnum: {
    incidentId: 'incidentId',
    checkId: 'checkId'
  };

  export type IncidentCheckScalarFieldEnum = (typeof IncidentCheckScalarFieldEnum)[keyof typeof IncidentCheckScalarFieldEnum]


  export const MaintenanceScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    title: 'title',
    description: 'description',
    startsAt: 'startsAt',
    endsAt: 'endsAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MaintenanceScalarFieldEnum = (typeof MaintenanceScalarFieldEnum)[keyof typeof MaintenanceScalarFieldEnum]


  export const MaintenanceCheckScalarFieldEnum: {
    maintenanceId: 'maintenanceId',
    checkId: 'checkId'
  };

  export type MaintenanceCheckScalarFieldEnum = (typeof MaintenanceCheckScalarFieldEnum)[keyof typeof MaintenanceCheckScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'ScheduleType'
   */
  export type EnumScheduleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduleType'>
    


  /**
   * Reference to a field of type 'ScheduleType[]'
   */
  export type ListEnumScheduleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduleType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'CheckStatus'
   */
  export type EnumCheckStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CheckStatus'>
    


  /**
   * Reference to a field of type 'CheckStatus[]'
   */
  export type ListEnumCheckStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CheckStatus[]'>
    


  /**
   * Reference to a field of type 'PingType'
   */
  export type EnumPingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PingType'>
    


  /**
   * Reference to a field of type 'PingType[]'
   */
  export type ListEnumPingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PingType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ChannelType'
   */
  export type EnumChannelTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChannelType'>
    


  /**
   * Reference to a field of type 'ChannelType[]'
   */
  export type ListEnumChannelTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChannelType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'IncidentStatus'
   */
  export type EnumIncidentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentStatus'>
    


  /**
   * Reference to a field of type 'IncidentStatus[]'
   */
  export type ListEnumIncidentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentStatus[]'>
    


  /**
   * Reference to a field of type 'IncidentImpact'
   */
  export type EnumIncidentImpactFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentImpact'>
    


  /**
   * Reference to a field of type 'IncidentImpact[]'
   */
  export type ListEnumIncidentImpactFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentImpact[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    name?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    memberships?: OrgMemberListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    name?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    memberships?: OrgMemberOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    emailVerified?: BoolFilter<"User"> | boolean
    name?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    memberships?: OrgMemberListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    name?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: StringFilter<"Organization"> | string
    name?: StringFilter<"Organization"> | string
    slug?: StringFilter<"Organization"> | string
    plan?: StringFilter<"Organization"> | string
    stripeCustomerId?: StringNullableFilter<"Organization"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"Organization"> | string | null
    trialEndsAt?: DateTimeNullableFilter<"Organization"> | Date | string | null
    autoCreateIncidents?: BoolFilter<"Organization"> | boolean
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    members?: OrgMemberListRelationFilter
    projects?: ProjectListRelationFilter
    invitations?: InvitationListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    plan?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    trialEndsAt?: SortOrderInput | SortOrder
    autoCreateIncidents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    members?: OrgMemberOrderByRelationAggregateInput
    projects?: ProjectOrderByRelationAggregateInput
    invitations?: InvitationOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    stripeCustomerId?: string
    stripeSubscriptionId?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    name?: StringFilter<"Organization"> | string
    plan?: StringFilter<"Organization"> | string
    trialEndsAt?: DateTimeNullableFilter<"Organization"> | Date | string | null
    autoCreateIncidents?: BoolFilter<"Organization"> | boolean
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    members?: OrgMemberListRelationFilter
    projects?: ProjectListRelationFilter
    invitations?: InvitationListRelationFilter
  }, "id" | "slug" | "stripeCustomerId" | "stripeSubscriptionId">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    plan?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    trialEndsAt?: SortOrderInput | SortOrder
    autoCreateIncidents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organization"> | string
    name?: StringWithAggregatesFilter<"Organization"> | string
    slug?: StringWithAggregatesFilter<"Organization"> | string
    plan?: StringWithAggregatesFilter<"Organization"> | string
    stripeCustomerId?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    trialEndsAt?: DateTimeNullableWithAggregatesFilter<"Organization"> | Date | string | null
    autoCreateIncidents?: BoolWithAggregatesFilter<"Organization"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
  }

  export type OrgMemberWhereInput = {
    AND?: OrgMemberWhereInput | OrgMemberWhereInput[]
    OR?: OrgMemberWhereInput[]
    NOT?: OrgMemberWhereInput | OrgMemberWhereInput[]
    id?: StringFilter<"OrgMember"> | string
    role?: StringFilter<"OrgMember"> | string
    userId?: StringFilter<"OrgMember"> | string
    orgId?: StringFilter<"OrgMember"> | string
    createdAt?: DateTimeFilter<"OrgMember"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    org?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type OrgMemberOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    org?: OrganizationOrderByWithRelationInput
  }

  export type OrgMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_orgId?: OrgMemberUserIdOrgIdCompoundUniqueInput
    AND?: OrgMemberWhereInput | OrgMemberWhereInput[]
    OR?: OrgMemberWhereInput[]
    NOT?: OrgMemberWhereInput | OrgMemberWhereInput[]
    role?: StringFilter<"OrgMember"> | string
    userId?: StringFilter<"OrgMember"> | string
    orgId?: StringFilter<"OrgMember"> | string
    createdAt?: DateTimeFilter<"OrgMember"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    org?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id" | "userId_orgId">

  export type OrgMemberOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
    _count?: OrgMemberCountOrderByAggregateInput
    _max?: OrgMemberMaxOrderByAggregateInput
    _min?: OrgMemberMinOrderByAggregateInput
  }

  export type OrgMemberScalarWhereWithAggregatesInput = {
    AND?: OrgMemberScalarWhereWithAggregatesInput | OrgMemberScalarWhereWithAggregatesInput[]
    OR?: OrgMemberScalarWhereWithAggregatesInput[]
    NOT?: OrgMemberScalarWhereWithAggregatesInput | OrgMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrgMember"> | string
    role?: StringWithAggregatesFilter<"OrgMember"> | string
    userId?: StringWithAggregatesFilter<"OrgMember"> | string
    orgId?: StringWithAggregatesFilter<"OrgMember"> | string
    createdAt?: DateTimeWithAggregatesFilter<"OrgMember"> | Date | string
  }

  export type InvitationWhereInput = {
    AND?: InvitationWhereInput | InvitationWhereInput[]
    OR?: InvitationWhereInput[]
    NOT?: InvitationWhereInput | InvitationWhereInput[]
    id?: StringFilter<"Invitation"> | string
    email?: StringFilter<"Invitation"> | string
    orgId?: StringFilter<"Invitation"> | string
    role?: StringFilter<"Invitation"> | string
    token?: StringFilter<"Invitation"> | string
    expiresAt?: DateTimeFilter<"Invitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"Invitation"> | Date | string | null
    createdAt?: DateTimeFilter<"Invitation"> | Date | string
    org?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type InvitationOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    orgId?: SortOrder
    role?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    org?: OrganizationOrderByWithRelationInput
  }

  export type InvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: InvitationWhereInput | InvitationWhereInput[]
    OR?: InvitationWhereInput[]
    NOT?: InvitationWhereInput | InvitationWhereInput[]
    email?: StringFilter<"Invitation"> | string
    orgId?: StringFilter<"Invitation"> | string
    role?: StringFilter<"Invitation"> | string
    expiresAt?: DateTimeFilter<"Invitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"Invitation"> | Date | string | null
    createdAt?: DateTimeFilter<"Invitation"> | Date | string
    org?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id" | "token">

  export type InvitationOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    orgId?: SortOrder
    role?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InvitationCountOrderByAggregateInput
    _max?: InvitationMaxOrderByAggregateInput
    _min?: InvitationMinOrderByAggregateInput
  }

  export type InvitationScalarWhereWithAggregatesInput = {
    AND?: InvitationScalarWhereWithAggregatesInput | InvitationScalarWhereWithAggregatesInput[]
    OR?: InvitationScalarWhereWithAggregatesInput[]
    NOT?: InvitationScalarWhereWithAggregatesInput | InvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invitation"> | string
    email?: StringWithAggregatesFilter<"Invitation"> | string
    orgId?: StringWithAggregatesFilter<"Invitation"> | string
    role?: StringWithAggregatesFilter<"Invitation"> | string
    token?: StringWithAggregatesFilter<"Invitation"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Invitation"> | Date | string
    acceptedAt?: DateTimeNullableWithAggregatesFilter<"Invitation"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invitation"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    token?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    providerId_accountId?: AccountProviderIdAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "providerId_accountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    accountId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }, "id">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    orgId?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    slug?: StringFilter<"Project"> | string
    timezone?: StringFilter<"Project"> | string
    statusPageEnabled?: BoolFilter<"Project"> | boolean
    statusPageTitle?: StringNullableFilter<"Project"> | string | null
    statusPageLogoUrl?: StringNullableFilter<"Project"> | string | null
    customDomain?: StringNullableFilter<"Project"> | string | null
    domainVerified?: BoolFilter<"Project"> | boolean
    domainVerifyToken?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    org?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    checks?: CheckListRelationFilter
    channels?: ChannelListRelationFilter
    apiKeys?: ApiKeyListRelationFilter
    incidents?: IncidentListRelationFilter
    maintenance?: MaintenanceListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    timezone?: SortOrder
    statusPageEnabled?: SortOrder
    statusPageTitle?: SortOrderInput | SortOrder
    statusPageLogoUrl?: SortOrderInput | SortOrder
    customDomain?: SortOrderInput | SortOrder
    domainVerified?: SortOrder
    domainVerifyToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    org?: OrganizationOrderByWithRelationInput
    checks?: CheckOrderByRelationAggregateInput
    channels?: ChannelOrderByRelationAggregateInput
    apiKeys?: ApiKeyOrderByRelationAggregateInput
    incidents?: IncidentOrderByRelationAggregateInput
    maintenance?: MaintenanceOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    customDomain?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    orgId?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    timezone?: StringFilter<"Project"> | string
    statusPageEnabled?: BoolFilter<"Project"> | boolean
    statusPageTitle?: StringNullableFilter<"Project"> | string | null
    statusPageLogoUrl?: StringNullableFilter<"Project"> | string | null
    domainVerified?: BoolFilter<"Project"> | boolean
    domainVerifyToken?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    org?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    checks?: CheckListRelationFilter
    channels?: ChannelListRelationFilter
    apiKeys?: ApiKeyListRelationFilter
    incidents?: IncidentListRelationFilter
    maintenance?: MaintenanceListRelationFilter
  }, "id" | "slug" | "customDomain">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    timezone?: SortOrder
    statusPageEnabled?: SortOrder
    statusPageTitle?: SortOrderInput | SortOrder
    statusPageLogoUrl?: SortOrderInput | SortOrder
    customDomain?: SortOrderInput | SortOrder
    domainVerified?: SortOrder
    domainVerifyToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    orgId?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    slug?: StringWithAggregatesFilter<"Project"> | string
    timezone?: StringWithAggregatesFilter<"Project"> | string
    statusPageEnabled?: BoolWithAggregatesFilter<"Project"> | boolean
    statusPageTitle?: StringNullableWithAggregatesFilter<"Project"> | string | null
    statusPageLogoUrl?: StringNullableWithAggregatesFilter<"Project"> | string | null
    customDomain?: StringNullableWithAggregatesFilter<"Project"> | string | null
    domainVerified?: BoolWithAggregatesFilter<"Project"> | boolean
    domainVerifyToken?: StringNullableWithAggregatesFilter<"Project"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
  }

  export type CheckWhereInput = {
    AND?: CheckWhereInput | CheckWhereInput[]
    OR?: CheckWhereInput[]
    NOT?: CheckWhereInput | CheckWhereInput[]
    id?: StringFilter<"Check"> | string
    projectId?: StringFilter<"Check"> | string
    name?: StringFilter<"Check"> | string
    slug?: StringNullableFilter<"Check"> | string | null
    scheduleType?: EnumScheduleTypeFilter<"Check"> | $Enums.ScheduleType
    scheduleValue?: StringFilter<"Check"> | string
    graceSeconds?: IntFilter<"Check"> | number
    timezone?: StringNullableFilter<"Check"> | string | null
    status?: EnumCheckStatusFilter<"Check"> | $Enums.CheckStatus
    lastPingAt?: DateTimeNullableFilter<"Check"> | Date | string | null
    lastStartedAt?: DateTimeNullableFilter<"Check"> | Date | string | null
    nextExpectedAt?: DateTimeNullableFilter<"Check"> | Date | string | null
    lastAlertAt?: DateTimeNullableFilter<"Check"> | Date | string | null
    alertOnRecovery?: BoolFilter<"Check"> | boolean
    reminderIntervalHours?: IntNullableFilter<"Check"> | number | null
    createdAt?: DateTimeFilter<"Check"> | Date | string
    updatedAt?: DateTimeFilter<"Check"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    pings?: PingListRelationFilter
    checkChannels?: CheckChannelListRelationFilter
    alerts?: AlertListRelationFilter
    incidentChecks?: IncidentCheckListRelationFilter
    maintenanceChecks?: MaintenanceCheckListRelationFilter
    dailyStats?: CheckDailyStatListRelationFilter
  }

  export type CheckOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    scheduleType?: SortOrder
    scheduleValue?: SortOrder
    graceSeconds?: SortOrder
    timezone?: SortOrderInput | SortOrder
    status?: SortOrder
    lastPingAt?: SortOrderInput | SortOrder
    lastStartedAt?: SortOrderInput | SortOrder
    nextExpectedAt?: SortOrderInput | SortOrder
    lastAlertAt?: SortOrderInput | SortOrder
    alertOnRecovery?: SortOrder
    reminderIntervalHours?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    pings?: PingOrderByRelationAggregateInput
    checkChannels?: CheckChannelOrderByRelationAggregateInput
    alerts?: AlertOrderByRelationAggregateInput
    incidentChecks?: IncidentCheckOrderByRelationAggregateInput
    maintenanceChecks?: MaintenanceCheckOrderByRelationAggregateInput
    dailyStats?: CheckDailyStatOrderByRelationAggregateInput
  }

  export type CheckWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_slug?: CheckProjectIdSlugCompoundUniqueInput
    AND?: CheckWhereInput | CheckWhereInput[]
    OR?: CheckWhereInput[]
    NOT?: CheckWhereInput | CheckWhereInput[]
    projectId?: StringFilter<"Check"> | string
    name?: StringFilter<"Check"> | string
    slug?: StringNullableFilter<"Check"> | string | null
    scheduleType?: EnumScheduleTypeFilter<"Check"> | $Enums.ScheduleType
    scheduleValue?: StringFilter<"Check"> | string
    graceSeconds?: IntFilter<"Check"> | number
    timezone?: StringNullableFilter<"Check"> | string | null
    status?: EnumCheckStatusFilter<"Check"> | $Enums.CheckStatus
    lastPingAt?: DateTimeNullableFilter<"Check"> | Date | string | null
    lastStartedAt?: DateTimeNullableFilter<"Check"> | Date | string | null
    nextExpectedAt?: DateTimeNullableFilter<"Check"> | Date | string | null
    lastAlertAt?: DateTimeNullableFilter<"Check"> | Date | string | null
    alertOnRecovery?: BoolFilter<"Check"> | boolean
    reminderIntervalHours?: IntNullableFilter<"Check"> | number | null
    createdAt?: DateTimeFilter<"Check"> | Date | string
    updatedAt?: DateTimeFilter<"Check"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    pings?: PingListRelationFilter
    checkChannels?: CheckChannelListRelationFilter
    alerts?: AlertListRelationFilter
    incidentChecks?: IncidentCheckListRelationFilter
    maintenanceChecks?: MaintenanceCheckListRelationFilter
    dailyStats?: CheckDailyStatListRelationFilter
  }, "id" | "projectId_slug">

  export type CheckOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    scheduleType?: SortOrder
    scheduleValue?: SortOrder
    graceSeconds?: SortOrder
    timezone?: SortOrderInput | SortOrder
    status?: SortOrder
    lastPingAt?: SortOrderInput | SortOrder
    lastStartedAt?: SortOrderInput | SortOrder
    nextExpectedAt?: SortOrderInput | SortOrder
    lastAlertAt?: SortOrderInput | SortOrder
    alertOnRecovery?: SortOrder
    reminderIntervalHours?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CheckCountOrderByAggregateInput
    _avg?: CheckAvgOrderByAggregateInput
    _max?: CheckMaxOrderByAggregateInput
    _min?: CheckMinOrderByAggregateInput
    _sum?: CheckSumOrderByAggregateInput
  }

  export type CheckScalarWhereWithAggregatesInput = {
    AND?: CheckScalarWhereWithAggregatesInput | CheckScalarWhereWithAggregatesInput[]
    OR?: CheckScalarWhereWithAggregatesInput[]
    NOT?: CheckScalarWhereWithAggregatesInput | CheckScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Check"> | string
    projectId?: StringWithAggregatesFilter<"Check"> | string
    name?: StringWithAggregatesFilter<"Check"> | string
    slug?: StringNullableWithAggregatesFilter<"Check"> | string | null
    scheduleType?: EnumScheduleTypeWithAggregatesFilter<"Check"> | $Enums.ScheduleType
    scheduleValue?: StringWithAggregatesFilter<"Check"> | string
    graceSeconds?: IntWithAggregatesFilter<"Check"> | number
    timezone?: StringNullableWithAggregatesFilter<"Check"> | string | null
    status?: EnumCheckStatusWithAggregatesFilter<"Check"> | $Enums.CheckStatus
    lastPingAt?: DateTimeNullableWithAggregatesFilter<"Check"> | Date | string | null
    lastStartedAt?: DateTimeNullableWithAggregatesFilter<"Check"> | Date | string | null
    nextExpectedAt?: DateTimeNullableWithAggregatesFilter<"Check"> | Date | string | null
    lastAlertAt?: DateTimeNullableWithAggregatesFilter<"Check"> | Date | string | null
    alertOnRecovery?: BoolWithAggregatesFilter<"Check"> | boolean
    reminderIntervalHours?: IntNullableWithAggregatesFilter<"Check"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Check"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Check"> | Date | string
  }

  export type PingWhereInput = {
    AND?: PingWhereInput | PingWhereInput[]
    OR?: PingWhereInput[]
    NOT?: PingWhereInput | PingWhereInput[]
    id?: StringFilter<"Ping"> | string
    checkId?: StringFilter<"Ping"> | string
    type?: EnumPingTypeFilter<"Ping"> | $Enums.PingType
    body?: StringNullableFilter<"Ping"> | string | null
    sourceIp?: StringFilter<"Ping"> | string
    createdAt?: DateTimeFilter<"Ping"> | Date | string
    check?: XOR<CheckScalarRelationFilter, CheckWhereInput>
  }

  export type PingOrderByWithRelationInput = {
    id?: SortOrder
    checkId?: SortOrder
    type?: SortOrder
    body?: SortOrderInput | SortOrder
    sourceIp?: SortOrder
    createdAt?: SortOrder
    check?: CheckOrderByWithRelationInput
  }

  export type PingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PingWhereInput | PingWhereInput[]
    OR?: PingWhereInput[]
    NOT?: PingWhereInput | PingWhereInput[]
    checkId?: StringFilter<"Ping"> | string
    type?: EnumPingTypeFilter<"Ping"> | $Enums.PingType
    body?: StringNullableFilter<"Ping"> | string | null
    sourceIp?: StringFilter<"Ping"> | string
    createdAt?: DateTimeFilter<"Ping"> | Date | string
    check?: XOR<CheckScalarRelationFilter, CheckWhereInput>
  }, "id">

  export type PingOrderByWithAggregationInput = {
    id?: SortOrder
    checkId?: SortOrder
    type?: SortOrder
    body?: SortOrderInput | SortOrder
    sourceIp?: SortOrder
    createdAt?: SortOrder
    _count?: PingCountOrderByAggregateInput
    _max?: PingMaxOrderByAggregateInput
    _min?: PingMinOrderByAggregateInput
  }

  export type PingScalarWhereWithAggregatesInput = {
    AND?: PingScalarWhereWithAggregatesInput | PingScalarWhereWithAggregatesInput[]
    OR?: PingScalarWhereWithAggregatesInput[]
    NOT?: PingScalarWhereWithAggregatesInput | PingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ping"> | string
    checkId?: StringWithAggregatesFilter<"Ping"> | string
    type?: EnumPingTypeWithAggregatesFilter<"Ping"> | $Enums.PingType
    body?: StringNullableWithAggregatesFilter<"Ping"> | string | null
    sourceIp?: StringWithAggregatesFilter<"Ping"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Ping"> | Date | string
  }

  export type CheckDailyStatWhereInput = {
    AND?: CheckDailyStatWhereInput | CheckDailyStatWhereInput[]
    OR?: CheckDailyStatWhereInput[]
    NOT?: CheckDailyStatWhereInput | CheckDailyStatWhereInput[]
    id?: StringFilter<"CheckDailyStat"> | string
    checkId?: StringFilter<"CheckDailyStat"> | string
    date?: DateTimeFilter<"CheckDailyStat"> | Date | string
    upMinutes?: IntFilter<"CheckDailyStat"> | number
    downMinutes?: IntFilter<"CheckDailyStat"> | number
    totalPings?: IntFilter<"CheckDailyStat"> | number
    upPercent?: FloatFilter<"CheckDailyStat"> | number
    createdAt?: DateTimeFilter<"CheckDailyStat"> | Date | string
    updatedAt?: DateTimeFilter<"CheckDailyStat"> | Date | string
    check?: XOR<CheckScalarRelationFilter, CheckWhereInput>
  }

  export type CheckDailyStatOrderByWithRelationInput = {
    id?: SortOrder
    checkId?: SortOrder
    date?: SortOrder
    upMinutes?: SortOrder
    downMinutes?: SortOrder
    totalPings?: SortOrder
    upPercent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    check?: CheckOrderByWithRelationInput
  }

  export type CheckDailyStatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    checkId_date?: CheckDailyStatCheckIdDateCompoundUniqueInput
    AND?: CheckDailyStatWhereInput | CheckDailyStatWhereInput[]
    OR?: CheckDailyStatWhereInput[]
    NOT?: CheckDailyStatWhereInput | CheckDailyStatWhereInput[]
    checkId?: StringFilter<"CheckDailyStat"> | string
    date?: DateTimeFilter<"CheckDailyStat"> | Date | string
    upMinutes?: IntFilter<"CheckDailyStat"> | number
    downMinutes?: IntFilter<"CheckDailyStat"> | number
    totalPings?: IntFilter<"CheckDailyStat"> | number
    upPercent?: FloatFilter<"CheckDailyStat"> | number
    createdAt?: DateTimeFilter<"CheckDailyStat"> | Date | string
    updatedAt?: DateTimeFilter<"CheckDailyStat"> | Date | string
    check?: XOR<CheckScalarRelationFilter, CheckWhereInput>
  }, "id" | "checkId_date">

  export type CheckDailyStatOrderByWithAggregationInput = {
    id?: SortOrder
    checkId?: SortOrder
    date?: SortOrder
    upMinutes?: SortOrder
    downMinutes?: SortOrder
    totalPings?: SortOrder
    upPercent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CheckDailyStatCountOrderByAggregateInput
    _avg?: CheckDailyStatAvgOrderByAggregateInput
    _max?: CheckDailyStatMaxOrderByAggregateInput
    _min?: CheckDailyStatMinOrderByAggregateInput
    _sum?: CheckDailyStatSumOrderByAggregateInput
  }

  export type CheckDailyStatScalarWhereWithAggregatesInput = {
    AND?: CheckDailyStatScalarWhereWithAggregatesInput | CheckDailyStatScalarWhereWithAggregatesInput[]
    OR?: CheckDailyStatScalarWhereWithAggregatesInput[]
    NOT?: CheckDailyStatScalarWhereWithAggregatesInput | CheckDailyStatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CheckDailyStat"> | string
    checkId?: StringWithAggregatesFilter<"CheckDailyStat"> | string
    date?: DateTimeWithAggregatesFilter<"CheckDailyStat"> | Date | string
    upMinutes?: IntWithAggregatesFilter<"CheckDailyStat"> | number
    downMinutes?: IntWithAggregatesFilter<"CheckDailyStat"> | number
    totalPings?: IntWithAggregatesFilter<"CheckDailyStat"> | number
    upPercent?: FloatWithAggregatesFilter<"CheckDailyStat"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CheckDailyStat"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CheckDailyStat"> | Date | string
  }

  export type ChannelWhereInput = {
    AND?: ChannelWhereInput | ChannelWhereInput[]
    OR?: ChannelWhereInput[]
    NOT?: ChannelWhereInput | ChannelWhereInput[]
    id?: StringFilter<"Channel"> | string
    projectId?: StringFilter<"Channel"> | string
    type?: EnumChannelTypeFilter<"Channel"> | $Enums.ChannelType
    name?: StringFilter<"Channel"> | string
    config?: JsonFilter<"Channel">
    createdAt?: DateTimeFilter<"Channel"> | Date | string
    updatedAt?: DateTimeFilter<"Channel"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    checkChannels?: CheckChannelListRelationFilter
  }

  export type ChannelOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    checkChannels?: CheckChannelOrderByRelationAggregateInput
  }

  export type ChannelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChannelWhereInput | ChannelWhereInput[]
    OR?: ChannelWhereInput[]
    NOT?: ChannelWhereInput | ChannelWhereInput[]
    projectId?: StringFilter<"Channel"> | string
    type?: EnumChannelTypeFilter<"Channel"> | $Enums.ChannelType
    name?: StringFilter<"Channel"> | string
    config?: JsonFilter<"Channel">
    createdAt?: DateTimeFilter<"Channel"> | Date | string
    updatedAt?: DateTimeFilter<"Channel"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    checkChannels?: CheckChannelListRelationFilter
  }, "id">

  export type ChannelOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChannelCountOrderByAggregateInput
    _max?: ChannelMaxOrderByAggregateInput
    _min?: ChannelMinOrderByAggregateInput
  }

  export type ChannelScalarWhereWithAggregatesInput = {
    AND?: ChannelScalarWhereWithAggregatesInput | ChannelScalarWhereWithAggregatesInput[]
    OR?: ChannelScalarWhereWithAggregatesInput[]
    NOT?: ChannelScalarWhereWithAggregatesInput | ChannelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Channel"> | string
    projectId?: StringWithAggregatesFilter<"Channel"> | string
    type?: EnumChannelTypeWithAggregatesFilter<"Channel"> | $Enums.ChannelType
    name?: StringWithAggregatesFilter<"Channel"> | string
    config?: JsonWithAggregatesFilter<"Channel">
    createdAt?: DateTimeWithAggregatesFilter<"Channel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Channel"> | Date | string
  }

  export type CheckChannelWhereInput = {
    AND?: CheckChannelWhereInput | CheckChannelWhereInput[]
    OR?: CheckChannelWhereInput[]
    NOT?: CheckChannelWhereInput | CheckChannelWhereInput[]
    checkId?: StringFilter<"CheckChannel"> | string
    channelId?: StringFilter<"CheckChannel"> | string
    check?: XOR<CheckScalarRelationFilter, CheckWhereInput>
    channel?: XOR<ChannelScalarRelationFilter, ChannelWhereInput>
  }

  export type CheckChannelOrderByWithRelationInput = {
    checkId?: SortOrder
    channelId?: SortOrder
    check?: CheckOrderByWithRelationInput
    channel?: ChannelOrderByWithRelationInput
  }

  export type CheckChannelWhereUniqueInput = Prisma.AtLeast<{
    checkId_channelId?: CheckChannelCheckIdChannelIdCompoundUniqueInput
    AND?: CheckChannelWhereInput | CheckChannelWhereInput[]
    OR?: CheckChannelWhereInput[]
    NOT?: CheckChannelWhereInput | CheckChannelWhereInput[]
    checkId?: StringFilter<"CheckChannel"> | string
    channelId?: StringFilter<"CheckChannel"> | string
    check?: XOR<CheckScalarRelationFilter, CheckWhereInput>
    channel?: XOR<ChannelScalarRelationFilter, ChannelWhereInput>
  }, "checkId_channelId">

  export type CheckChannelOrderByWithAggregationInput = {
    checkId?: SortOrder
    channelId?: SortOrder
    _count?: CheckChannelCountOrderByAggregateInput
    _max?: CheckChannelMaxOrderByAggregateInput
    _min?: CheckChannelMinOrderByAggregateInput
  }

  export type CheckChannelScalarWhereWithAggregatesInput = {
    AND?: CheckChannelScalarWhereWithAggregatesInput | CheckChannelScalarWhereWithAggregatesInput[]
    OR?: CheckChannelScalarWhereWithAggregatesInput[]
    NOT?: CheckChannelScalarWhereWithAggregatesInput | CheckChannelScalarWhereWithAggregatesInput[]
    checkId?: StringWithAggregatesFilter<"CheckChannel"> | string
    channelId?: StringWithAggregatesFilter<"CheckChannel"> | string
  }

  export type AlertWhereInput = {
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    id?: StringFilter<"Alert"> | string
    checkId?: StringFilter<"Alert"> | string
    event?: StringFilter<"Alert"> | string
    channels?: JsonFilter<"Alert">
    success?: BoolFilter<"Alert"> | boolean
    error?: StringNullableFilter<"Alert"> | string | null
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    check?: XOR<CheckScalarRelationFilter, CheckWhereInput>
  }

  export type AlertOrderByWithRelationInput = {
    id?: SortOrder
    checkId?: SortOrder
    event?: SortOrder
    channels?: SortOrder
    success?: SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    check?: CheckOrderByWithRelationInput
  }

  export type AlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    checkId?: StringFilter<"Alert"> | string
    event?: StringFilter<"Alert"> | string
    channels?: JsonFilter<"Alert">
    success?: BoolFilter<"Alert"> | boolean
    error?: StringNullableFilter<"Alert"> | string | null
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    check?: XOR<CheckScalarRelationFilter, CheckWhereInput>
  }, "id">

  export type AlertOrderByWithAggregationInput = {
    id?: SortOrder
    checkId?: SortOrder
    event?: SortOrder
    channels?: SortOrder
    success?: SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AlertCountOrderByAggregateInput
    _max?: AlertMaxOrderByAggregateInput
    _min?: AlertMinOrderByAggregateInput
  }

  export type AlertScalarWhereWithAggregatesInput = {
    AND?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    OR?: AlertScalarWhereWithAggregatesInput[]
    NOT?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Alert"> | string
    checkId?: StringWithAggregatesFilter<"Alert"> | string
    event?: StringWithAggregatesFilter<"Alert"> | string
    channels?: JsonWithAggregatesFilter<"Alert">
    success?: BoolWithAggregatesFilter<"Alert"> | boolean
    error?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Alert"> | Date | string
  }

  export type ApiKeyWhereInput = {
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    projectId?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    keyHash?: StringFilter<"ApiKey"> | string
    keyPrefix?: StringFilter<"ApiKey"> | string
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type ApiKeyOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    keyHash?: SortOrder
    keyPrefix?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type ApiKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    keyHash?: string
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    projectId?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    keyPrefix?: StringFilter<"ApiKey"> | string
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id" | "keyHash">

  export type ApiKeyOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    keyHash?: SortOrder
    keyPrefix?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ApiKeyCountOrderByAggregateInput
    _max?: ApiKeyMaxOrderByAggregateInput
    _min?: ApiKeyMinOrderByAggregateInput
  }

  export type ApiKeyScalarWhereWithAggregatesInput = {
    AND?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    OR?: ApiKeyScalarWhereWithAggregatesInput[]
    NOT?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiKey"> | string
    projectId?: StringWithAggregatesFilter<"ApiKey"> | string
    name?: StringWithAggregatesFilter<"ApiKey"> | string
    keyHash?: StringWithAggregatesFilter<"ApiKey"> | string
    keyPrefix?: StringWithAggregatesFilter<"ApiKey"> | string
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
  }

  export type IncidentWhereInput = {
    AND?: IncidentWhereInput | IncidentWhereInput[]
    OR?: IncidentWhereInput[]
    NOT?: IncidentWhereInput | IncidentWhereInput[]
    id?: StringFilter<"Incident"> | string
    projectId?: StringFilter<"Incident"> | string
    title?: StringFilter<"Incident"> | string
    status?: EnumIncidentStatusFilter<"Incident"> | $Enums.IncidentStatus
    impact?: EnumIncidentImpactFilter<"Incident"> | $Enums.IncidentImpact
    autoCreated?: BoolFilter<"Incident"> | boolean
    resolvedAt?: DateTimeNullableFilter<"Incident"> | Date | string | null
    createdAt?: DateTimeFilter<"Incident"> | Date | string
    updatedAt?: DateTimeFilter<"Incident"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    updates?: IncidentUpdateListRelationFilter
    checks?: IncidentCheckListRelationFilter
  }

  export type IncidentOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    status?: SortOrder
    impact?: SortOrder
    autoCreated?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    updates?: IncidentUpdateOrderByRelationAggregateInput
    checks?: IncidentCheckOrderByRelationAggregateInput
  }

  export type IncidentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IncidentWhereInput | IncidentWhereInput[]
    OR?: IncidentWhereInput[]
    NOT?: IncidentWhereInput | IncidentWhereInput[]
    projectId?: StringFilter<"Incident"> | string
    title?: StringFilter<"Incident"> | string
    status?: EnumIncidentStatusFilter<"Incident"> | $Enums.IncidentStatus
    impact?: EnumIncidentImpactFilter<"Incident"> | $Enums.IncidentImpact
    autoCreated?: BoolFilter<"Incident"> | boolean
    resolvedAt?: DateTimeNullableFilter<"Incident"> | Date | string | null
    createdAt?: DateTimeFilter<"Incident"> | Date | string
    updatedAt?: DateTimeFilter<"Incident"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    updates?: IncidentUpdateListRelationFilter
    checks?: IncidentCheckListRelationFilter
  }, "id">

  export type IncidentOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    status?: SortOrder
    impact?: SortOrder
    autoCreated?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IncidentCountOrderByAggregateInput
    _max?: IncidentMaxOrderByAggregateInput
    _min?: IncidentMinOrderByAggregateInput
  }

  export type IncidentScalarWhereWithAggregatesInput = {
    AND?: IncidentScalarWhereWithAggregatesInput | IncidentScalarWhereWithAggregatesInput[]
    OR?: IncidentScalarWhereWithAggregatesInput[]
    NOT?: IncidentScalarWhereWithAggregatesInput | IncidentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Incident"> | string
    projectId?: StringWithAggregatesFilter<"Incident"> | string
    title?: StringWithAggregatesFilter<"Incident"> | string
    status?: EnumIncidentStatusWithAggregatesFilter<"Incident"> | $Enums.IncidentStatus
    impact?: EnumIncidentImpactWithAggregatesFilter<"Incident"> | $Enums.IncidentImpact
    autoCreated?: BoolWithAggregatesFilter<"Incident"> | boolean
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"Incident"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Incident"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Incident"> | Date | string
  }

  export type IncidentUpdateWhereInput = {
    AND?: IncidentUpdateWhereInput | IncidentUpdateWhereInput[]
    OR?: IncidentUpdateWhereInput[]
    NOT?: IncidentUpdateWhereInput | IncidentUpdateWhereInput[]
    id?: StringFilter<"IncidentUpdate"> | string
    incidentId?: StringFilter<"IncidentUpdate"> | string
    status?: EnumIncidentStatusFilter<"IncidentUpdate"> | $Enums.IncidentStatus
    message?: StringFilter<"IncidentUpdate"> | string
    createdAt?: DateTimeFilter<"IncidentUpdate"> | Date | string
    incident?: XOR<IncidentScalarRelationFilter, IncidentWhereInput>
  }

  export type IncidentUpdateOrderByWithRelationInput = {
    id?: SortOrder
    incidentId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    incident?: IncidentOrderByWithRelationInput
  }

  export type IncidentUpdateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IncidentUpdateWhereInput | IncidentUpdateWhereInput[]
    OR?: IncidentUpdateWhereInput[]
    NOT?: IncidentUpdateWhereInput | IncidentUpdateWhereInput[]
    incidentId?: StringFilter<"IncidentUpdate"> | string
    status?: EnumIncidentStatusFilter<"IncidentUpdate"> | $Enums.IncidentStatus
    message?: StringFilter<"IncidentUpdate"> | string
    createdAt?: DateTimeFilter<"IncidentUpdate"> | Date | string
    incident?: XOR<IncidentScalarRelationFilter, IncidentWhereInput>
  }, "id">

  export type IncidentUpdateOrderByWithAggregationInput = {
    id?: SortOrder
    incidentId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    _count?: IncidentUpdateCountOrderByAggregateInput
    _max?: IncidentUpdateMaxOrderByAggregateInput
    _min?: IncidentUpdateMinOrderByAggregateInput
  }

  export type IncidentUpdateScalarWhereWithAggregatesInput = {
    AND?: IncidentUpdateScalarWhereWithAggregatesInput | IncidentUpdateScalarWhereWithAggregatesInput[]
    OR?: IncidentUpdateScalarWhereWithAggregatesInput[]
    NOT?: IncidentUpdateScalarWhereWithAggregatesInput | IncidentUpdateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IncidentUpdate"> | string
    incidentId?: StringWithAggregatesFilter<"IncidentUpdate"> | string
    status?: EnumIncidentStatusWithAggregatesFilter<"IncidentUpdate"> | $Enums.IncidentStatus
    message?: StringWithAggregatesFilter<"IncidentUpdate"> | string
    createdAt?: DateTimeWithAggregatesFilter<"IncidentUpdate"> | Date | string
  }

  export type IncidentCheckWhereInput = {
    AND?: IncidentCheckWhereInput | IncidentCheckWhereInput[]
    OR?: IncidentCheckWhereInput[]
    NOT?: IncidentCheckWhereInput | IncidentCheckWhereInput[]
    incidentId?: StringFilter<"IncidentCheck"> | string
    checkId?: StringFilter<"IncidentCheck"> | string
    incident?: XOR<IncidentScalarRelationFilter, IncidentWhereInput>
    check?: XOR<CheckScalarRelationFilter, CheckWhereInput>
  }

  export type IncidentCheckOrderByWithRelationInput = {
    incidentId?: SortOrder
    checkId?: SortOrder
    incident?: IncidentOrderByWithRelationInput
    check?: CheckOrderByWithRelationInput
  }

  export type IncidentCheckWhereUniqueInput = Prisma.AtLeast<{
    incidentId_checkId?: IncidentCheckIncidentIdCheckIdCompoundUniqueInput
    AND?: IncidentCheckWhereInput | IncidentCheckWhereInput[]
    OR?: IncidentCheckWhereInput[]
    NOT?: IncidentCheckWhereInput | IncidentCheckWhereInput[]
    incidentId?: StringFilter<"IncidentCheck"> | string
    checkId?: StringFilter<"IncidentCheck"> | string
    incident?: XOR<IncidentScalarRelationFilter, IncidentWhereInput>
    check?: XOR<CheckScalarRelationFilter, CheckWhereInput>
  }, "incidentId_checkId">

  export type IncidentCheckOrderByWithAggregationInput = {
    incidentId?: SortOrder
    checkId?: SortOrder
    _count?: IncidentCheckCountOrderByAggregateInput
    _max?: IncidentCheckMaxOrderByAggregateInput
    _min?: IncidentCheckMinOrderByAggregateInput
  }

  export type IncidentCheckScalarWhereWithAggregatesInput = {
    AND?: IncidentCheckScalarWhereWithAggregatesInput | IncidentCheckScalarWhereWithAggregatesInput[]
    OR?: IncidentCheckScalarWhereWithAggregatesInput[]
    NOT?: IncidentCheckScalarWhereWithAggregatesInput | IncidentCheckScalarWhereWithAggregatesInput[]
    incidentId?: StringWithAggregatesFilter<"IncidentCheck"> | string
    checkId?: StringWithAggregatesFilter<"IncidentCheck"> | string
  }

  export type MaintenanceWhereInput = {
    AND?: MaintenanceWhereInput | MaintenanceWhereInput[]
    OR?: MaintenanceWhereInput[]
    NOT?: MaintenanceWhereInput | MaintenanceWhereInput[]
    id?: StringFilter<"Maintenance"> | string
    projectId?: StringFilter<"Maintenance"> | string
    title?: StringFilter<"Maintenance"> | string
    description?: StringNullableFilter<"Maintenance"> | string | null
    startsAt?: DateTimeFilter<"Maintenance"> | Date | string
    endsAt?: DateTimeFilter<"Maintenance"> | Date | string
    createdAt?: DateTimeFilter<"Maintenance"> | Date | string
    updatedAt?: DateTimeFilter<"Maintenance"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    checks?: MaintenanceCheckListRelationFilter
  }

  export type MaintenanceOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    checks?: MaintenanceCheckOrderByRelationAggregateInput
  }

  export type MaintenanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MaintenanceWhereInput | MaintenanceWhereInput[]
    OR?: MaintenanceWhereInput[]
    NOT?: MaintenanceWhereInput | MaintenanceWhereInput[]
    projectId?: StringFilter<"Maintenance"> | string
    title?: StringFilter<"Maintenance"> | string
    description?: StringNullableFilter<"Maintenance"> | string | null
    startsAt?: DateTimeFilter<"Maintenance"> | Date | string
    endsAt?: DateTimeFilter<"Maintenance"> | Date | string
    createdAt?: DateTimeFilter<"Maintenance"> | Date | string
    updatedAt?: DateTimeFilter<"Maintenance"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    checks?: MaintenanceCheckListRelationFilter
  }, "id">

  export type MaintenanceOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MaintenanceCountOrderByAggregateInput
    _max?: MaintenanceMaxOrderByAggregateInput
    _min?: MaintenanceMinOrderByAggregateInput
  }

  export type MaintenanceScalarWhereWithAggregatesInput = {
    AND?: MaintenanceScalarWhereWithAggregatesInput | MaintenanceScalarWhereWithAggregatesInput[]
    OR?: MaintenanceScalarWhereWithAggregatesInput[]
    NOT?: MaintenanceScalarWhereWithAggregatesInput | MaintenanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Maintenance"> | string
    projectId?: StringWithAggregatesFilter<"Maintenance"> | string
    title?: StringWithAggregatesFilter<"Maintenance"> | string
    description?: StringNullableWithAggregatesFilter<"Maintenance"> | string | null
    startsAt?: DateTimeWithAggregatesFilter<"Maintenance"> | Date | string
    endsAt?: DateTimeWithAggregatesFilter<"Maintenance"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Maintenance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Maintenance"> | Date | string
  }

  export type MaintenanceCheckWhereInput = {
    AND?: MaintenanceCheckWhereInput | MaintenanceCheckWhereInput[]
    OR?: MaintenanceCheckWhereInput[]
    NOT?: MaintenanceCheckWhereInput | MaintenanceCheckWhereInput[]
    maintenanceId?: StringFilter<"MaintenanceCheck"> | string
    checkId?: StringFilter<"MaintenanceCheck"> | string
    maintenance?: XOR<MaintenanceScalarRelationFilter, MaintenanceWhereInput>
    check?: XOR<CheckScalarRelationFilter, CheckWhereInput>
  }

  export type MaintenanceCheckOrderByWithRelationInput = {
    maintenanceId?: SortOrder
    checkId?: SortOrder
    maintenance?: MaintenanceOrderByWithRelationInput
    check?: CheckOrderByWithRelationInput
  }

  export type MaintenanceCheckWhereUniqueInput = Prisma.AtLeast<{
    maintenanceId_checkId?: MaintenanceCheckMaintenanceIdCheckIdCompoundUniqueInput
    AND?: MaintenanceCheckWhereInput | MaintenanceCheckWhereInput[]
    OR?: MaintenanceCheckWhereInput[]
    NOT?: MaintenanceCheckWhereInput | MaintenanceCheckWhereInput[]
    maintenanceId?: StringFilter<"MaintenanceCheck"> | string
    checkId?: StringFilter<"MaintenanceCheck"> | string
    maintenance?: XOR<MaintenanceScalarRelationFilter, MaintenanceWhereInput>
    check?: XOR<CheckScalarRelationFilter, CheckWhereInput>
  }, "maintenanceId_checkId">

  export type MaintenanceCheckOrderByWithAggregationInput = {
    maintenanceId?: SortOrder
    checkId?: SortOrder
    _count?: MaintenanceCheckCountOrderByAggregateInput
    _max?: MaintenanceCheckMaxOrderByAggregateInput
    _min?: MaintenanceCheckMinOrderByAggregateInput
  }

  export type MaintenanceCheckScalarWhereWithAggregatesInput = {
    AND?: MaintenanceCheckScalarWhereWithAggregatesInput | MaintenanceCheckScalarWhereWithAggregatesInput[]
    OR?: MaintenanceCheckScalarWhereWithAggregatesInput[]
    NOT?: MaintenanceCheckScalarWhereWithAggregatesInput | MaintenanceCheckScalarWhereWithAggregatesInput[]
    maintenanceId?: StringWithAggregatesFilter<"MaintenanceCheck"> | string
    checkId?: StringWithAggregatesFilter<"MaintenanceCheck"> | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    memberships?: OrgMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    memberships?: OrgMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    memberships?: OrgMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    memberships?: OrgMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateInput = {
    id?: string
    name: string
    slug: string
    plan?: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    trialEndsAt?: Date | string | null
    autoCreateIncidents?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: OrgMemberCreateNestedManyWithoutOrgInput
    projects?: ProjectCreateNestedManyWithoutOrgInput
    invitations?: InvitationCreateNestedManyWithoutOrgInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    plan?: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    trialEndsAt?: Date | string | null
    autoCreateIncidents?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: OrgMemberUncheckedCreateNestedManyWithoutOrgInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrgInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoCreateIncidents?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: OrgMemberUpdateManyWithoutOrgNestedInput
    projects?: ProjectUpdateManyWithoutOrgNestedInput
    invitations?: InvitationUpdateManyWithoutOrgNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoCreateIncidents?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: OrgMemberUncheckedUpdateManyWithoutOrgNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrgNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: string
    name: string
    slug: string
    plan?: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    trialEndsAt?: Date | string | null
    autoCreateIncidents?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoCreateIncidents?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoCreateIncidents?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrgMemberCreateInput = {
    id?: string
    role?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMembershipsInput
    org: OrganizationCreateNestedOneWithoutMembersInput
  }

  export type OrgMemberUncheckedCreateInput = {
    id?: string
    role?: string
    userId: string
    orgId: string
    createdAt?: Date | string
  }

  export type OrgMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
    org?: OrganizationUpdateOneRequiredWithoutMembersNestedInput
  }

  export type OrgMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrgMemberCreateManyInput = {
    id?: string
    role?: string
    userId: string
    orgId: string
    createdAt?: Date | string
  }

  export type OrgMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrgMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationCreateInput = {
    id?: string
    email: string
    role?: string
    token: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
    org: OrganizationCreateNestedOneWithoutInvitationsInput
  }

  export type InvitationUncheckedCreateInput = {
    id?: string
    email: string
    orgId: string
    role?: string
    token: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type InvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrganizationUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type InvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationCreateManyInput = {
    id?: string
    email: string
    orgId: string
    role?: string
    token: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type InvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUncheckedCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateManyInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    slug: string
    timezone?: string
    statusPageEnabled?: boolean
    statusPageTitle?: string | null
    statusPageLogoUrl?: string | null
    customDomain?: string | null
    domainVerified?: boolean
    domainVerifyToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    org: OrganizationCreateNestedOneWithoutProjectsInput
    checks?: CheckCreateNestedManyWithoutProjectInput
    channels?: ChannelCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyCreateNestedManyWithoutProjectInput
    incidents?: IncidentCreateNestedManyWithoutProjectInput
    maintenance?: MaintenanceCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    orgId: string
    name: string
    slug: string
    timezone?: string
    statusPageEnabled?: boolean
    statusPageTitle?: string | null
    statusPageLogoUrl?: string | null
    customDomain?: string | null
    domainVerified?: boolean
    domainVerifyToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    checks?: CheckUncheckedCreateNestedManyWithoutProjectInput
    channels?: ChannelUncheckedCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutProjectInput
    maintenance?: MaintenanceUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    statusPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    statusPageTitle?: NullableStringFieldUpdateOperationsInput | string | null
    statusPageLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    domainVerified?: BoolFieldUpdateOperationsInput | boolean
    domainVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    checks?: CheckUpdateManyWithoutProjectNestedInput
    channels?: ChannelUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutProjectNestedInput
    incidents?: IncidentUpdateManyWithoutProjectNestedInput
    maintenance?: MaintenanceUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    statusPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    statusPageTitle?: NullableStringFieldUpdateOperationsInput | string | null
    statusPageLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    domainVerified?: BoolFieldUpdateOperationsInput | boolean
    domainVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checks?: CheckUncheckedUpdateManyWithoutProjectNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutProjectNestedInput
    maintenance?: MaintenanceUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    orgId: string
    name: string
    slug: string
    timezone?: string
    statusPageEnabled?: boolean
    statusPageTitle?: string | null
    statusPageLogoUrl?: string | null
    customDomain?: string | null
    domainVerified?: boolean
    domainVerifyToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    statusPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    statusPageTitle?: NullableStringFieldUpdateOperationsInput | string | null
    statusPageLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    domainVerified?: BoolFieldUpdateOperationsInput | boolean
    domainVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    statusPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    statusPageTitle?: NullableStringFieldUpdateOperationsInput | string | null
    statusPageLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    domainVerified?: BoolFieldUpdateOperationsInput | boolean
    domainVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckCreateInput = {
    id?: string
    name: string
    slug?: string | null
    scheduleType: $Enums.ScheduleType
    scheduleValue: string
    graceSeconds?: number
    timezone?: string | null
    status?: $Enums.CheckStatus
    lastPingAt?: Date | string | null
    lastStartedAt?: Date | string | null
    nextExpectedAt?: Date | string | null
    lastAlertAt?: Date | string | null
    alertOnRecovery?: boolean
    reminderIntervalHours?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutChecksInput
    pings?: PingCreateNestedManyWithoutCheckInput
    checkChannels?: CheckChannelCreateNestedManyWithoutCheckInput
    alerts?: AlertCreateNestedManyWithoutCheckInput
    incidentChecks?: IncidentCheckCreateNestedManyWithoutCheckInput
    maintenanceChecks?: MaintenanceCheckCreateNestedManyWithoutCheckInput
    dailyStats?: CheckDailyStatCreateNestedManyWithoutCheckInput
  }

  export type CheckUncheckedCreateInput = {
    id?: string
    projectId: string
    name: string
    slug?: string | null
    scheduleType: $Enums.ScheduleType
    scheduleValue: string
    graceSeconds?: number
    timezone?: string | null
    status?: $Enums.CheckStatus
    lastPingAt?: Date | string | null
    lastStartedAt?: Date | string | null
    nextExpectedAt?: Date | string | null
    lastAlertAt?: Date | string | null
    alertOnRecovery?: boolean
    reminderIntervalHours?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pings?: PingUncheckedCreateNestedManyWithoutCheckInput
    checkChannels?: CheckChannelUncheckedCreateNestedManyWithoutCheckInput
    alerts?: AlertUncheckedCreateNestedManyWithoutCheckInput
    incidentChecks?: IncidentCheckUncheckedCreateNestedManyWithoutCheckInput
    maintenanceChecks?: MaintenanceCheckUncheckedCreateNestedManyWithoutCheckInput
    dailyStats?: CheckDailyStatUncheckedCreateNestedManyWithoutCheckInput
  }

  export type CheckUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumScheduleTypeFieldUpdateOperationsInput | $Enums.ScheduleType
    scheduleValue?: StringFieldUpdateOperationsInput | string
    graceSeconds?: IntFieldUpdateOperationsInput | number
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCheckStatusFieldUpdateOperationsInput | $Enums.CheckStatus
    lastPingAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExpectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertOnRecovery?: BoolFieldUpdateOperationsInput | boolean
    reminderIntervalHours?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutChecksNestedInput
    pings?: PingUpdateManyWithoutCheckNestedInput
    checkChannels?: CheckChannelUpdateManyWithoutCheckNestedInput
    alerts?: AlertUpdateManyWithoutCheckNestedInput
    incidentChecks?: IncidentCheckUpdateManyWithoutCheckNestedInput
    maintenanceChecks?: MaintenanceCheckUpdateManyWithoutCheckNestedInput
    dailyStats?: CheckDailyStatUpdateManyWithoutCheckNestedInput
  }

  export type CheckUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumScheduleTypeFieldUpdateOperationsInput | $Enums.ScheduleType
    scheduleValue?: StringFieldUpdateOperationsInput | string
    graceSeconds?: IntFieldUpdateOperationsInput | number
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCheckStatusFieldUpdateOperationsInput | $Enums.CheckStatus
    lastPingAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExpectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertOnRecovery?: BoolFieldUpdateOperationsInput | boolean
    reminderIntervalHours?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pings?: PingUncheckedUpdateManyWithoutCheckNestedInput
    checkChannels?: CheckChannelUncheckedUpdateManyWithoutCheckNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutCheckNestedInput
    incidentChecks?: IncidentCheckUncheckedUpdateManyWithoutCheckNestedInput
    maintenanceChecks?: MaintenanceCheckUncheckedUpdateManyWithoutCheckNestedInput
    dailyStats?: CheckDailyStatUncheckedUpdateManyWithoutCheckNestedInput
  }

  export type CheckCreateManyInput = {
    id?: string
    projectId: string
    name: string
    slug?: string | null
    scheduleType: $Enums.ScheduleType
    scheduleValue: string
    graceSeconds?: number
    timezone?: string | null
    status?: $Enums.CheckStatus
    lastPingAt?: Date | string | null
    lastStartedAt?: Date | string | null
    nextExpectedAt?: Date | string | null
    lastAlertAt?: Date | string | null
    alertOnRecovery?: boolean
    reminderIntervalHours?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CheckUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumScheduleTypeFieldUpdateOperationsInput | $Enums.ScheduleType
    scheduleValue?: StringFieldUpdateOperationsInput | string
    graceSeconds?: IntFieldUpdateOperationsInput | number
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCheckStatusFieldUpdateOperationsInput | $Enums.CheckStatus
    lastPingAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExpectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertOnRecovery?: BoolFieldUpdateOperationsInput | boolean
    reminderIntervalHours?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumScheduleTypeFieldUpdateOperationsInput | $Enums.ScheduleType
    scheduleValue?: StringFieldUpdateOperationsInput | string
    graceSeconds?: IntFieldUpdateOperationsInput | number
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCheckStatusFieldUpdateOperationsInput | $Enums.CheckStatus
    lastPingAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExpectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertOnRecovery?: BoolFieldUpdateOperationsInput | boolean
    reminderIntervalHours?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PingCreateInput = {
    id?: string
    type: $Enums.PingType
    body?: string | null
    sourceIp: string
    createdAt?: Date | string
    check: CheckCreateNestedOneWithoutPingsInput
  }

  export type PingUncheckedCreateInput = {
    id?: string
    checkId: string
    type: $Enums.PingType
    body?: string | null
    sourceIp: string
    createdAt?: Date | string
  }

  export type PingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPingTypeFieldUpdateOperationsInput | $Enums.PingType
    body?: NullableStringFieldUpdateOperationsInput | string | null
    sourceIp?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    check?: CheckUpdateOneRequiredWithoutPingsNestedInput
  }

  export type PingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkId?: StringFieldUpdateOperationsInput | string
    type?: EnumPingTypeFieldUpdateOperationsInput | $Enums.PingType
    body?: NullableStringFieldUpdateOperationsInput | string | null
    sourceIp?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PingCreateManyInput = {
    id?: string
    checkId: string
    type: $Enums.PingType
    body?: string | null
    sourceIp: string
    createdAt?: Date | string
  }

  export type PingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPingTypeFieldUpdateOperationsInput | $Enums.PingType
    body?: NullableStringFieldUpdateOperationsInput | string | null
    sourceIp?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkId?: StringFieldUpdateOperationsInput | string
    type?: EnumPingTypeFieldUpdateOperationsInput | $Enums.PingType
    body?: NullableStringFieldUpdateOperationsInput | string | null
    sourceIp?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckDailyStatCreateInput = {
    id?: string
    date: Date | string
    upMinutes?: number
    downMinutes?: number
    totalPings?: number
    upPercent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    check: CheckCreateNestedOneWithoutDailyStatsInput
  }

  export type CheckDailyStatUncheckedCreateInput = {
    id?: string
    checkId: string
    date: Date | string
    upMinutes?: number
    downMinutes?: number
    totalPings?: number
    upPercent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CheckDailyStatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    upMinutes?: IntFieldUpdateOperationsInput | number
    downMinutes?: IntFieldUpdateOperationsInput | number
    totalPings?: IntFieldUpdateOperationsInput | number
    upPercent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    check?: CheckUpdateOneRequiredWithoutDailyStatsNestedInput
  }

  export type CheckDailyStatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    upMinutes?: IntFieldUpdateOperationsInput | number
    downMinutes?: IntFieldUpdateOperationsInput | number
    totalPings?: IntFieldUpdateOperationsInput | number
    upPercent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckDailyStatCreateManyInput = {
    id?: string
    checkId: string
    date: Date | string
    upMinutes?: number
    downMinutes?: number
    totalPings?: number
    upPercent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CheckDailyStatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    upMinutes?: IntFieldUpdateOperationsInput | number
    downMinutes?: IntFieldUpdateOperationsInput | number
    totalPings?: IntFieldUpdateOperationsInput | number
    upPercent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckDailyStatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    upMinutes?: IntFieldUpdateOperationsInput | number
    downMinutes?: IntFieldUpdateOperationsInput | number
    totalPings?: IntFieldUpdateOperationsInput | number
    upPercent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelCreateInput = {
    id?: string
    type: $Enums.ChannelType
    name: string
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutChannelsInput
    checkChannels?: CheckChannelCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateInput = {
    id?: string
    projectId: string
    type: $Enums.ChannelType
    name: string
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    checkChannels?: CheckChannelUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChannelTypeFieldUpdateOperationsInput | $Enums.ChannelType
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutChannelsNestedInput
    checkChannels?: CheckChannelUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    type?: EnumChannelTypeFieldUpdateOperationsInput | $Enums.ChannelType
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkChannels?: CheckChannelUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type ChannelCreateManyInput = {
    id?: string
    projectId: string
    type: $Enums.ChannelType
    name: string
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChannelTypeFieldUpdateOperationsInput | $Enums.ChannelType
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    type?: EnumChannelTypeFieldUpdateOperationsInput | $Enums.ChannelType
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckChannelCreateInput = {
    check: CheckCreateNestedOneWithoutCheckChannelsInput
    channel: ChannelCreateNestedOneWithoutCheckChannelsInput
  }

  export type CheckChannelUncheckedCreateInput = {
    checkId: string
    channelId: string
  }

  export type CheckChannelUpdateInput = {
    check?: CheckUpdateOneRequiredWithoutCheckChannelsNestedInput
    channel?: ChannelUpdateOneRequiredWithoutCheckChannelsNestedInput
  }

  export type CheckChannelUncheckedUpdateInput = {
    checkId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
  }

  export type CheckChannelCreateManyInput = {
    checkId: string
    channelId: string
  }

  export type CheckChannelUpdateManyMutationInput = {

  }

  export type CheckChannelUncheckedUpdateManyInput = {
    checkId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
  }

  export type AlertCreateInput = {
    id?: string
    event: string
    channels: JsonNullValueInput | InputJsonValue
    success: boolean
    error?: string | null
    createdAt?: Date | string
    check: CheckCreateNestedOneWithoutAlertsInput
  }

  export type AlertUncheckedCreateInput = {
    id?: string
    checkId: string
    event: string
    channels: JsonNullValueInput | InputJsonValue
    success: boolean
    error?: string | null
    createdAt?: Date | string
  }

  export type AlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    channels?: JsonNullValueInput | InputJsonValue
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    check?: CheckUpdateOneRequiredWithoutAlertsNestedInput
  }

  export type AlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkId?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    channels?: JsonNullValueInput | InputJsonValue
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertCreateManyInput = {
    id?: string
    checkId: string
    event: string
    channels: JsonNullValueInput | InputJsonValue
    success: boolean
    error?: string | null
    createdAt?: Date | string
  }

  export type AlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    channels?: JsonNullValueInput | InputJsonValue
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkId?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    channels?: JsonNullValueInput | InputJsonValue
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyCreateInput = {
    id?: string
    name: string
    keyHash: string
    keyPrefix: string
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutApiKeysInput
  }

  export type ApiKeyUncheckedCreateInput = {
    id?: string
    projectId: string
    name: string
    keyHash: string
    keyPrefix: string
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ApiKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutApiKeysNestedInput
  }

  export type ApiKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyCreateManyInput = {
    id?: string
    projectId: string
    name: string
    keyHash: string
    keyPrefix: string
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ApiKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentCreateInput = {
    id?: string
    title: string
    status?: $Enums.IncidentStatus
    impact?: $Enums.IncidentImpact
    autoCreated?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutIncidentsInput
    updates?: IncidentUpdateCreateNestedManyWithoutIncidentInput
    checks?: IncidentCheckCreateNestedManyWithoutIncidentInput
  }

  export type IncidentUncheckedCreateInput = {
    id?: string
    projectId: string
    title: string
    status?: $Enums.IncidentStatus
    impact?: $Enums.IncidentImpact
    autoCreated?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updates?: IncidentUpdateUncheckedCreateNestedManyWithoutIncidentInput
    checks?: IncidentCheckUncheckedCreateNestedManyWithoutIncidentInput
  }

  export type IncidentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    impact?: EnumIncidentImpactFieldUpdateOperationsInput | $Enums.IncidentImpact
    autoCreated?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutIncidentsNestedInput
    updates?: IncidentUpdateUpdateManyWithoutIncidentNestedInput
    checks?: IncidentCheckUpdateManyWithoutIncidentNestedInput
  }

  export type IncidentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    impact?: EnumIncidentImpactFieldUpdateOperationsInput | $Enums.IncidentImpact
    autoCreated?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updates?: IncidentUpdateUncheckedUpdateManyWithoutIncidentNestedInput
    checks?: IncidentCheckUncheckedUpdateManyWithoutIncidentNestedInput
  }

  export type IncidentCreateManyInput = {
    id?: string
    projectId: string
    title: string
    status?: $Enums.IncidentStatus
    impact?: $Enums.IncidentImpact
    autoCreated?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    impact?: EnumIncidentImpactFieldUpdateOperationsInput | $Enums.IncidentImpact
    autoCreated?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    impact?: EnumIncidentImpactFieldUpdateOperationsInput | $Enums.IncidentImpact
    autoCreated?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUpdateCreateInput = {
    id?: string
    status: $Enums.IncidentStatus
    message: string
    createdAt?: Date | string
    incident: IncidentCreateNestedOneWithoutUpdatesInput
  }

  export type IncidentUpdateUncheckedCreateInput = {
    id?: string
    incidentId: string
    status: $Enums.IncidentStatus
    message: string
    createdAt?: Date | string
  }

  export type IncidentUpdateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    incident?: IncidentUpdateOneRequiredWithoutUpdatesNestedInput
  }

  export type IncidentUpdateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUpdateCreateManyInput = {
    id?: string
    incidentId: string
    status: $Enums.IncidentStatus
    message: string
    createdAt?: Date | string
  }

  export type IncidentUpdateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUpdateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentId?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentCheckCreateInput = {
    incident: IncidentCreateNestedOneWithoutChecksInput
    check: CheckCreateNestedOneWithoutIncidentChecksInput
  }

  export type IncidentCheckUncheckedCreateInput = {
    incidentId: string
    checkId: string
  }

  export type IncidentCheckUpdateInput = {
    incident?: IncidentUpdateOneRequiredWithoutChecksNestedInput
    check?: CheckUpdateOneRequiredWithoutIncidentChecksNestedInput
  }

  export type IncidentCheckUncheckedUpdateInput = {
    incidentId?: StringFieldUpdateOperationsInput | string
    checkId?: StringFieldUpdateOperationsInput | string
  }

  export type IncidentCheckCreateManyInput = {
    incidentId: string
    checkId: string
  }

  export type IncidentCheckUpdateManyMutationInput = {

  }

  export type IncidentCheckUncheckedUpdateManyInput = {
    incidentId?: StringFieldUpdateOperationsInput | string
    checkId?: StringFieldUpdateOperationsInput | string
  }

  export type MaintenanceCreateInput = {
    id?: string
    title: string
    description?: string | null
    startsAt: Date | string
    endsAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMaintenanceInput
    checks?: MaintenanceCheckCreateNestedManyWithoutMaintenanceInput
  }

  export type MaintenanceUncheckedCreateInput = {
    id?: string
    projectId: string
    title: string
    description?: string | null
    startsAt: Date | string
    endsAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    checks?: MaintenanceCheckUncheckedCreateNestedManyWithoutMaintenanceInput
  }

  export type MaintenanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMaintenanceNestedInput
    checks?: MaintenanceCheckUpdateManyWithoutMaintenanceNestedInput
  }

  export type MaintenanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checks?: MaintenanceCheckUncheckedUpdateManyWithoutMaintenanceNestedInput
  }

  export type MaintenanceCreateManyInput = {
    id?: string
    projectId: string
    title: string
    description?: string | null
    startsAt: Date | string
    endsAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceCheckCreateInput = {
    maintenance: MaintenanceCreateNestedOneWithoutChecksInput
    check: CheckCreateNestedOneWithoutMaintenanceChecksInput
  }

  export type MaintenanceCheckUncheckedCreateInput = {
    maintenanceId: string
    checkId: string
  }

  export type MaintenanceCheckUpdateInput = {
    maintenance?: MaintenanceUpdateOneRequiredWithoutChecksNestedInput
    check?: CheckUpdateOneRequiredWithoutMaintenanceChecksNestedInput
  }

  export type MaintenanceCheckUncheckedUpdateInput = {
    maintenanceId?: StringFieldUpdateOperationsInput | string
    checkId?: StringFieldUpdateOperationsInput | string
  }

  export type MaintenanceCheckCreateManyInput = {
    maintenanceId: string
    checkId: string
  }

  export type MaintenanceCheckUpdateManyMutationInput = {

  }

  export type MaintenanceCheckUncheckedUpdateManyInput = {
    maintenanceId?: StringFieldUpdateOperationsInput | string
    checkId?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type OrgMemberListRelationFilter = {
    every?: OrgMemberWhereInput
    some?: OrgMemberWhereInput
    none?: OrgMemberWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrgMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    name?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    name?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    name?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type InvitationListRelationFilter = {
    every?: InvitationWhereInput
    some?: InvitationWhereInput
    none?: InvitationWhereInput
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    plan?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    trialEndsAt?: SortOrder
    autoCreateIncidents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    plan?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    trialEndsAt?: SortOrder
    autoCreateIncidents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    plan?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    trialEndsAt?: SortOrder
    autoCreateIncidents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type OrganizationScalarRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type OrgMemberUserIdOrgIdCompoundUniqueInput = {
    userId: string
    orgId: string
  }

  export type OrgMemberCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
  }

  export type OrgMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
  }

  export type OrgMemberMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    userId?: SortOrder
    orgId?: SortOrder
    createdAt?: SortOrder
  }

  export type InvitationCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    orgId?: SortOrder
    role?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type InvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    orgId?: SortOrder
    role?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type InvitationMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    orgId?: SortOrder
    role?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type AccountProviderIdAccountIdCompoundUniqueInput = {
    providerId: string
    accountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CheckListRelationFilter = {
    every?: CheckWhereInput
    some?: CheckWhereInput
    none?: CheckWhereInput
  }

  export type ChannelListRelationFilter = {
    every?: ChannelWhereInput
    some?: ChannelWhereInput
    none?: ChannelWhereInput
  }

  export type ApiKeyListRelationFilter = {
    every?: ApiKeyWhereInput
    some?: ApiKeyWhereInput
    none?: ApiKeyWhereInput
  }

  export type IncidentListRelationFilter = {
    every?: IncidentWhereInput
    some?: IncidentWhereInput
    none?: IncidentWhereInput
  }

  export type MaintenanceListRelationFilter = {
    every?: MaintenanceWhereInput
    some?: MaintenanceWhereInput
    none?: MaintenanceWhereInput
  }

  export type CheckOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChannelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IncidentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaintenanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    timezone?: SortOrder
    statusPageEnabled?: SortOrder
    statusPageTitle?: SortOrder
    statusPageLogoUrl?: SortOrder
    customDomain?: SortOrder
    domainVerified?: SortOrder
    domainVerifyToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    timezone?: SortOrder
    statusPageEnabled?: SortOrder
    statusPageTitle?: SortOrder
    statusPageLogoUrl?: SortOrder
    customDomain?: SortOrder
    domainVerified?: SortOrder
    domainVerifyToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    timezone?: SortOrder
    statusPageEnabled?: SortOrder
    statusPageTitle?: SortOrder
    statusPageLogoUrl?: SortOrder
    customDomain?: SortOrder
    domainVerified?: SortOrder
    domainVerifyToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumScheduleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleType | EnumScheduleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleType[] | ListEnumScheduleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleType[] | ListEnumScheduleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleTypeFilter<$PrismaModel> | $Enums.ScheduleType
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumCheckStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CheckStatus | EnumCheckStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CheckStatus[] | ListEnumCheckStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CheckStatus[] | ListEnumCheckStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCheckStatusFilter<$PrismaModel> | $Enums.CheckStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type PingListRelationFilter = {
    every?: PingWhereInput
    some?: PingWhereInput
    none?: PingWhereInput
  }

  export type CheckChannelListRelationFilter = {
    every?: CheckChannelWhereInput
    some?: CheckChannelWhereInput
    none?: CheckChannelWhereInput
  }

  export type AlertListRelationFilter = {
    every?: AlertWhereInput
    some?: AlertWhereInput
    none?: AlertWhereInput
  }

  export type IncidentCheckListRelationFilter = {
    every?: IncidentCheckWhereInput
    some?: IncidentCheckWhereInput
    none?: IncidentCheckWhereInput
  }

  export type MaintenanceCheckListRelationFilter = {
    every?: MaintenanceCheckWhereInput
    some?: MaintenanceCheckWhereInput
    none?: MaintenanceCheckWhereInput
  }

  export type CheckDailyStatListRelationFilter = {
    every?: CheckDailyStatWhereInput
    some?: CheckDailyStatWhereInput
    none?: CheckDailyStatWhereInput
  }

  export type PingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CheckChannelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IncidentCheckOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaintenanceCheckOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CheckDailyStatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CheckProjectIdSlugCompoundUniqueInput = {
    projectId: string
    slug: string
  }

  export type CheckCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    scheduleType?: SortOrder
    scheduleValue?: SortOrder
    graceSeconds?: SortOrder
    timezone?: SortOrder
    status?: SortOrder
    lastPingAt?: SortOrder
    lastStartedAt?: SortOrder
    nextExpectedAt?: SortOrder
    lastAlertAt?: SortOrder
    alertOnRecovery?: SortOrder
    reminderIntervalHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CheckAvgOrderByAggregateInput = {
    graceSeconds?: SortOrder
    reminderIntervalHours?: SortOrder
  }

  export type CheckMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    scheduleType?: SortOrder
    scheduleValue?: SortOrder
    graceSeconds?: SortOrder
    timezone?: SortOrder
    status?: SortOrder
    lastPingAt?: SortOrder
    lastStartedAt?: SortOrder
    nextExpectedAt?: SortOrder
    lastAlertAt?: SortOrder
    alertOnRecovery?: SortOrder
    reminderIntervalHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CheckMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    scheduleType?: SortOrder
    scheduleValue?: SortOrder
    graceSeconds?: SortOrder
    timezone?: SortOrder
    status?: SortOrder
    lastPingAt?: SortOrder
    lastStartedAt?: SortOrder
    nextExpectedAt?: SortOrder
    lastAlertAt?: SortOrder
    alertOnRecovery?: SortOrder
    reminderIntervalHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CheckSumOrderByAggregateInput = {
    graceSeconds?: SortOrder
    reminderIntervalHours?: SortOrder
  }

  export type EnumScheduleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleType | EnumScheduleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleType[] | ListEnumScheduleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleType[] | ListEnumScheduleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleTypeWithAggregatesFilter<$PrismaModel> | $Enums.ScheduleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScheduleTypeFilter<$PrismaModel>
    _max?: NestedEnumScheduleTypeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumCheckStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CheckStatus | EnumCheckStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CheckStatus[] | ListEnumCheckStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CheckStatus[] | ListEnumCheckStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCheckStatusWithAggregatesFilter<$PrismaModel> | $Enums.CheckStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCheckStatusFilter<$PrismaModel>
    _max?: NestedEnumCheckStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumPingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PingType | EnumPingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PingType[] | ListEnumPingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PingType[] | ListEnumPingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPingTypeFilter<$PrismaModel> | $Enums.PingType
  }

  export type CheckScalarRelationFilter = {
    is?: CheckWhereInput
    isNot?: CheckWhereInput
  }

  export type PingCountOrderByAggregateInput = {
    id?: SortOrder
    checkId?: SortOrder
    type?: SortOrder
    body?: SortOrder
    sourceIp?: SortOrder
    createdAt?: SortOrder
  }

  export type PingMaxOrderByAggregateInput = {
    id?: SortOrder
    checkId?: SortOrder
    type?: SortOrder
    body?: SortOrder
    sourceIp?: SortOrder
    createdAt?: SortOrder
  }

  export type PingMinOrderByAggregateInput = {
    id?: SortOrder
    checkId?: SortOrder
    type?: SortOrder
    body?: SortOrder
    sourceIp?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumPingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PingType | EnumPingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PingType[] | ListEnumPingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PingType[] | ListEnumPingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPingTypeWithAggregatesFilter<$PrismaModel> | $Enums.PingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPingTypeFilter<$PrismaModel>
    _max?: NestedEnumPingTypeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type CheckDailyStatCheckIdDateCompoundUniqueInput = {
    checkId: string
    date: Date | string
  }

  export type CheckDailyStatCountOrderByAggregateInput = {
    id?: SortOrder
    checkId?: SortOrder
    date?: SortOrder
    upMinutes?: SortOrder
    downMinutes?: SortOrder
    totalPings?: SortOrder
    upPercent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CheckDailyStatAvgOrderByAggregateInput = {
    upMinutes?: SortOrder
    downMinutes?: SortOrder
    totalPings?: SortOrder
    upPercent?: SortOrder
  }

  export type CheckDailyStatMaxOrderByAggregateInput = {
    id?: SortOrder
    checkId?: SortOrder
    date?: SortOrder
    upMinutes?: SortOrder
    downMinutes?: SortOrder
    totalPings?: SortOrder
    upPercent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CheckDailyStatMinOrderByAggregateInput = {
    id?: SortOrder
    checkId?: SortOrder
    date?: SortOrder
    upMinutes?: SortOrder
    downMinutes?: SortOrder
    totalPings?: SortOrder
    upPercent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CheckDailyStatSumOrderByAggregateInput = {
    upMinutes?: SortOrder
    downMinutes?: SortOrder
    totalPings?: SortOrder
    upPercent?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumChannelTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChannelType | EnumChannelTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChannelType[] | ListEnumChannelTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChannelType[] | ListEnumChannelTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChannelTypeFilter<$PrismaModel> | $Enums.ChannelType
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ChannelCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChannelMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChannelMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumChannelTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChannelType | EnumChannelTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChannelType[] | ListEnumChannelTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChannelType[] | ListEnumChannelTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChannelTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChannelType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChannelTypeFilter<$PrismaModel>
    _max?: NestedEnumChannelTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type ChannelScalarRelationFilter = {
    is?: ChannelWhereInput
    isNot?: ChannelWhereInput
  }

  export type CheckChannelCheckIdChannelIdCompoundUniqueInput = {
    checkId: string
    channelId: string
  }

  export type CheckChannelCountOrderByAggregateInput = {
    checkId?: SortOrder
    channelId?: SortOrder
  }

  export type CheckChannelMaxOrderByAggregateInput = {
    checkId?: SortOrder
    channelId?: SortOrder
  }

  export type CheckChannelMinOrderByAggregateInput = {
    checkId?: SortOrder
    channelId?: SortOrder
  }

  export type AlertCountOrderByAggregateInput = {
    id?: SortOrder
    checkId?: SortOrder
    event?: SortOrder
    channels?: SortOrder
    success?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type AlertMaxOrderByAggregateInput = {
    id?: SortOrder
    checkId?: SortOrder
    event?: SortOrder
    success?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type AlertMinOrderByAggregateInput = {
    id?: SortOrder
    checkId?: SortOrder
    event?: SortOrder
    success?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiKeyCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    keyHash?: SortOrder
    keyPrefix?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    keyHash?: SortOrder
    keyPrefix?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiKeyMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    keyHash?: SortOrder
    keyPrefix?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumIncidentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentStatusFilter<$PrismaModel> | $Enums.IncidentStatus
  }

  export type EnumIncidentImpactFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentImpact | EnumIncidentImpactFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentImpact[] | ListEnumIncidentImpactFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentImpact[] | ListEnumIncidentImpactFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentImpactFilter<$PrismaModel> | $Enums.IncidentImpact
  }

  export type IncidentUpdateListRelationFilter = {
    every?: IncidentUpdateWhereInput
    some?: IncidentUpdateWhereInput
    none?: IncidentUpdateWhereInput
  }

  export type IncidentUpdateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IncidentCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    status?: SortOrder
    impact?: SortOrder
    autoCreated?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncidentMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    status?: SortOrder
    impact?: SortOrder
    autoCreated?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncidentMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    status?: SortOrder
    impact?: SortOrder
    autoCreated?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumIncidentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentStatusWithAggregatesFilter<$PrismaModel> | $Enums.IncidentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentStatusFilter<$PrismaModel>
    _max?: NestedEnumIncidentStatusFilter<$PrismaModel>
  }

  export type EnumIncidentImpactWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentImpact | EnumIncidentImpactFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentImpact[] | ListEnumIncidentImpactFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentImpact[] | ListEnumIncidentImpactFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentImpactWithAggregatesFilter<$PrismaModel> | $Enums.IncidentImpact
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentImpactFilter<$PrismaModel>
    _max?: NestedEnumIncidentImpactFilter<$PrismaModel>
  }

  export type IncidentScalarRelationFilter = {
    is?: IncidentWhereInput
    isNot?: IncidentWhereInput
  }

  export type IncidentUpdateCountOrderByAggregateInput = {
    id?: SortOrder
    incidentId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type IncidentUpdateMaxOrderByAggregateInput = {
    id?: SortOrder
    incidentId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type IncidentUpdateMinOrderByAggregateInput = {
    id?: SortOrder
    incidentId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type IncidentCheckIncidentIdCheckIdCompoundUniqueInput = {
    incidentId: string
    checkId: string
  }

  export type IncidentCheckCountOrderByAggregateInput = {
    incidentId?: SortOrder
    checkId?: SortOrder
  }

  export type IncidentCheckMaxOrderByAggregateInput = {
    incidentId?: SortOrder
    checkId?: SortOrder
  }

  export type IncidentCheckMinOrderByAggregateInput = {
    incidentId?: SortOrder
    checkId?: SortOrder
  }

  export type MaintenanceCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaintenanceMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaintenanceMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaintenanceScalarRelationFilter = {
    is?: MaintenanceWhereInput
    isNot?: MaintenanceWhereInput
  }

  export type MaintenanceCheckMaintenanceIdCheckIdCompoundUniqueInput = {
    maintenanceId: string
    checkId: string
  }

  export type MaintenanceCheckCountOrderByAggregateInput = {
    maintenanceId?: SortOrder
    checkId?: SortOrder
  }

  export type MaintenanceCheckMaxOrderByAggregateInput = {
    maintenanceId?: SortOrder
    checkId?: SortOrder
  }

  export type MaintenanceCheckMinOrderByAggregateInput = {
    maintenanceId?: SortOrder
    checkId?: SortOrder
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type OrgMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<OrgMemberCreateWithoutUserInput, OrgMemberUncheckedCreateWithoutUserInput> | OrgMemberCreateWithoutUserInput[] | OrgMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrgMemberCreateOrConnectWithoutUserInput | OrgMemberCreateOrConnectWithoutUserInput[]
    createMany?: OrgMemberCreateManyUserInputEnvelope
    connect?: OrgMemberWhereUniqueInput | OrgMemberWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type OrgMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrgMemberCreateWithoutUserInput, OrgMemberUncheckedCreateWithoutUserInput> | OrgMemberCreateWithoutUserInput[] | OrgMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrgMemberCreateOrConnectWithoutUserInput | OrgMemberCreateOrConnectWithoutUserInput[]
    createMany?: OrgMemberCreateManyUserInputEnvelope
    connect?: OrgMemberWhereUniqueInput | OrgMemberWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type OrgMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrgMemberCreateWithoutUserInput, OrgMemberUncheckedCreateWithoutUserInput> | OrgMemberCreateWithoutUserInput[] | OrgMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrgMemberCreateOrConnectWithoutUserInput | OrgMemberCreateOrConnectWithoutUserInput[]
    upsert?: OrgMemberUpsertWithWhereUniqueWithoutUserInput | OrgMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrgMemberCreateManyUserInputEnvelope
    set?: OrgMemberWhereUniqueInput | OrgMemberWhereUniqueInput[]
    disconnect?: OrgMemberWhereUniqueInput | OrgMemberWhereUniqueInput[]
    delete?: OrgMemberWhereUniqueInput | OrgMemberWhereUniqueInput[]
    connect?: OrgMemberWhereUniqueInput | OrgMemberWhereUniqueInput[]
    update?: OrgMemberUpdateWithWhereUniqueWithoutUserInput | OrgMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrgMemberUpdateManyWithWhereWithoutUserInput | OrgMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrgMemberScalarWhereInput | OrgMemberScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type OrgMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrgMemberCreateWithoutUserInput, OrgMemberUncheckedCreateWithoutUserInput> | OrgMemberCreateWithoutUserInput[] | OrgMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrgMemberCreateOrConnectWithoutUserInput | OrgMemberCreateOrConnectWithoutUserInput[]
    upsert?: OrgMemberUpsertWithWhereUniqueWithoutUserInput | OrgMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrgMemberCreateManyUserInputEnvelope
    set?: OrgMemberWhereUniqueInput | OrgMemberWhereUniqueInput[]
    disconnect?: OrgMemberWhereUniqueInput | OrgMemberWhereUniqueInput[]
    delete?: OrgMemberWhereUniqueInput | OrgMemberWhereUniqueInput[]
    connect?: OrgMemberWhereUniqueInput | OrgMemberWhereUniqueInput[]
    update?: OrgMemberUpdateWithWhereUniqueWithoutUserInput | OrgMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrgMemberUpdateManyWithWhereWithoutUserInput | OrgMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrgMemberScalarWhereInput | OrgMemberScalarWhereInput[]
  }

  export type OrgMemberCreateNestedManyWithoutOrgInput = {
    create?: XOR<OrgMemberCreateWithoutOrgInput, OrgMemberUncheckedCreateWithoutOrgInput> | OrgMemberCreateWithoutOrgInput[] | OrgMemberUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: OrgMemberCreateOrConnectWithoutOrgInput | OrgMemberCreateOrConnectWithoutOrgInput[]
    createMany?: OrgMemberCreateManyOrgInputEnvelope
    connect?: OrgMemberWhereUniqueInput | OrgMemberWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutOrgInput = {
    create?: XOR<ProjectCreateWithoutOrgInput, ProjectUncheckedCreateWithoutOrgInput> | ProjectCreateWithoutOrgInput[] | ProjectUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOrgInput | ProjectCreateOrConnectWithoutOrgInput[]
    createMany?: ProjectCreateManyOrgInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type InvitationCreateNestedManyWithoutOrgInput = {
    create?: XOR<InvitationCreateWithoutOrgInput, InvitationUncheckedCreateWithoutOrgInput> | InvitationCreateWithoutOrgInput[] | InvitationUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutOrgInput | InvitationCreateOrConnectWithoutOrgInput[]
    createMany?: InvitationCreateManyOrgInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type OrgMemberUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<OrgMemberCreateWithoutOrgInput, OrgMemberUncheckedCreateWithoutOrgInput> | OrgMemberCreateWithoutOrgInput[] | OrgMemberUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: OrgMemberCreateOrConnectWithoutOrgInput | OrgMemberCreateOrConnectWithoutOrgInput[]
    createMany?: OrgMemberCreateManyOrgInputEnvelope
    connect?: OrgMemberWhereUniqueInput | OrgMemberWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<ProjectCreateWithoutOrgInput, ProjectUncheckedCreateWithoutOrgInput> | ProjectCreateWithoutOrgInput[] | ProjectUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOrgInput | ProjectCreateOrConnectWithoutOrgInput[]
    createMany?: ProjectCreateManyOrgInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type InvitationUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<InvitationCreateWithoutOrgInput, InvitationUncheckedCreateWithoutOrgInput> | InvitationCreateWithoutOrgInput[] | InvitationUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutOrgInput | InvitationCreateOrConnectWithoutOrgInput[]
    createMany?: InvitationCreateManyOrgInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type OrgMemberUpdateManyWithoutOrgNestedInput = {
    create?: XOR<OrgMemberCreateWithoutOrgInput, OrgMemberUncheckedCreateWithoutOrgInput> | OrgMemberCreateWithoutOrgInput[] | OrgMemberUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: OrgMemberCreateOrConnectWithoutOrgInput | OrgMemberCreateOrConnectWithoutOrgInput[]
    upsert?: OrgMemberUpsertWithWhereUniqueWithoutOrgInput | OrgMemberUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: OrgMemberCreateManyOrgInputEnvelope
    set?: OrgMemberWhereUniqueInput | OrgMemberWhereUniqueInput[]
    disconnect?: OrgMemberWhereUniqueInput | OrgMemberWhereUniqueInput[]
    delete?: OrgMemberWhereUniqueInput | OrgMemberWhereUniqueInput[]
    connect?: OrgMemberWhereUniqueInput | OrgMemberWhereUniqueInput[]
    update?: OrgMemberUpdateWithWhereUniqueWithoutOrgInput | OrgMemberUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: OrgMemberUpdateManyWithWhereWithoutOrgInput | OrgMemberUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: OrgMemberScalarWhereInput | OrgMemberScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutOrgNestedInput = {
    create?: XOR<ProjectCreateWithoutOrgInput, ProjectUncheckedCreateWithoutOrgInput> | ProjectCreateWithoutOrgInput[] | ProjectUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOrgInput | ProjectCreateOrConnectWithoutOrgInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutOrgInput | ProjectUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: ProjectCreateManyOrgInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutOrgInput | ProjectUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutOrgInput | ProjectUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type InvitationUpdateManyWithoutOrgNestedInput = {
    create?: XOR<InvitationCreateWithoutOrgInput, InvitationUncheckedCreateWithoutOrgInput> | InvitationCreateWithoutOrgInput[] | InvitationUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutOrgInput | InvitationCreateOrConnectWithoutOrgInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutOrgInput | InvitationUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: InvitationCreateManyOrgInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutOrgInput | InvitationUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutOrgInput | InvitationUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type OrgMemberUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<OrgMemberCreateWithoutOrgInput, OrgMemberUncheckedCreateWithoutOrgInput> | OrgMemberCreateWithoutOrgInput[] | OrgMemberUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: OrgMemberCreateOrConnectWithoutOrgInput | OrgMemberCreateOrConnectWithoutOrgInput[]
    upsert?: OrgMemberUpsertWithWhereUniqueWithoutOrgInput | OrgMemberUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: OrgMemberCreateManyOrgInputEnvelope
    set?: OrgMemberWhereUniqueInput | OrgMemberWhereUniqueInput[]
    disconnect?: OrgMemberWhereUniqueInput | OrgMemberWhereUniqueInput[]
    delete?: OrgMemberWhereUniqueInput | OrgMemberWhereUniqueInput[]
    connect?: OrgMemberWhereUniqueInput | OrgMemberWhereUniqueInput[]
    update?: OrgMemberUpdateWithWhereUniqueWithoutOrgInput | OrgMemberUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: OrgMemberUpdateManyWithWhereWithoutOrgInput | OrgMemberUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: OrgMemberScalarWhereInput | OrgMemberScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<ProjectCreateWithoutOrgInput, ProjectUncheckedCreateWithoutOrgInput> | ProjectCreateWithoutOrgInput[] | ProjectUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOrgInput | ProjectCreateOrConnectWithoutOrgInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutOrgInput | ProjectUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: ProjectCreateManyOrgInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutOrgInput | ProjectUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutOrgInput | ProjectUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type InvitationUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<InvitationCreateWithoutOrgInput, InvitationUncheckedCreateWithoutOrgInput> | InvitationCreateWithoutOrgInput[] | InvitationUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutOrgInput | InvitationCreateOrConnectWithoutOrgInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutOrgInput | InvitationUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: InvitationCreateManyOrgInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutOrgInput | InvitationUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutOrgInput | InvitationUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutMembersInput = {
    create?: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput
    upsert?: UserUpsertWithoutMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMembershipsInput, UserUpdateWithoutMembershipsInput>, UserUncheckedUpdateWithoutMembershipsInput>
  }

  export type OrganizationUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembersInput
    upsert?: OrganizationUpsertWithoutMembersInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutMembersInput, OrganizationUpdateWithoutMembersInput>, OrganizationUncheckedUpdateWithoutMembersInput>
  }

  export type OrganizationCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<OrganizationCreateWithoutInvitationsInput, OrganizationUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutInvitationsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<OrganizationCreateWithoutInvitationsInput, OrganizationUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutInvitationsInput
    upsert?: OrganizationUpsertWithoutInvitationsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutInvitationsInput, OrganizationUpdateWithoutInvitationsInput>, OrganizationUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type OrganizationCreateNestedOneWithoutProjectsInput = {
    create?: XOR<OrganizationCreateWithoutProjectsInput, OrganizationUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutProjectsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type CheckCreateNestedManyWithoutProjectInput = {
    create?: XOR<CheckCreateWithoutProjectInput, CheckUncheckedCreateWithoutProjectInput> | CheckCreateWithoutProjectInput[] | CheckUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CheckCreateOrConnectWithoutProjectInput | CheckCreateOrConnectWithoutProjectInput[]
    createMany?: CheckCreateManyProjectInputEnvelope
    connect?: CheckWhereUniqueInput | CheckWhereUniqueInput[]
  }

  export type ChannelCreateNestedManyWithoutProjectInput = {
    create?: XOR<ChannelCreateWithoutProjectInput, ChannelUncheckedCreateWithoutProjectInput> | ChannelCreateWithoutProjectInput[] | ChannelUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutProjectInput | ChannelCreateOrConnectWithoutProjectInput[]
    createMany?: ChannelCreateManyProjectInputEnvelope
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
  }

  export type ApiKeyCreateNestedManyWithoutProjectInput = {
    create?: XOR<ApiKeyCreateWithoutProjectInput, ApiKeyUncheckedCreateWithoutProjectInput> | ApiKeyCreateWithoutProjectInput[] | ApiKeyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutProjectInput | ApiKeyCreateOrConnectWithoutProjectInput[]
    createMany?: ApiKeyCreateManyProjectInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type IncidentCreateNestedManyWithoutProjectInput = {
    create?: XOR<IncidentCreateWithoutProjectInput, IncidentUncheckedCreateWithoutProjectInput> | IncidentCreateWithoutProjectInput[] | IncidentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutProjectInput | IncidentCreateOrConnectWithoutProjectInput[]
    createMany?: IncidentCreateManyProjectInputEnvelope
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type MaintenanceCreateNestedManyWithoutProjectInput = {
    create?: XOR<MaintenanceCreateWithoutProjectInput, MaintenanceUncheckedCreateWithoutProjectInput> | MaintenanceCreateWithoutProjectInput[] | MaintenanceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutProjectInput | MaintenanceCreateOrConnectWithoutProjectInput[]
    createMany?: MaintenanceCreateManyProjectInputEnvelope
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
  }

  export type CheckUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<CheckCreateWithoutProjectInput, CheckUncheckedCreateWithoutProjectInput> | CheckCreateWithoutProjectInput[] | CheckUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CheckCreateOrConnectWithoutProjectInput | CheckCreateOrConnectWithoutProjectInput[]
    createMany?: CheckCreateManyProjectInputEnvelope
    connect?: CheckWhereUniqueInput | CheckWhereUniqueInput[]
  }

  export type ChannelUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ChannelCreateWithoutProjectInput, ChannelUncheckedCreateWithoutProjectInput> | ChannelCreateWithoutProjectInput[] | ChannelUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutProjectInput | ChannelCreateOrConnectWithoutProjectInput[]
    createMany?: ChannelCreateManyProjectInputEnvelope
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
  }

  export type ApiKeyUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ApiKeyCreateWithoutProjectInput, ApiKeyUncheckedCreateWithoutProjectInput> | ApiKeyCreateWithoutProjectInput[] | ApiKeyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutProjectInput | ApiKeyCreateOrConnectWithoutProjectInput[]
    createMany?: ApiKeyCreateManyProjectInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type IncidentUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<IncidentCreateWithoutProjectInput, IncidentUncheckedCreateWithoutProjectInput> | IncidentCreateWithoutProjectInput[] | IncidentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutProjectInput | IncidentCreateOrConnectWithoutProjectInput[]
    createMany?: IncidentCreateManyProjectInputEnvelope
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type MaintenanceUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<MaintenanceCreateWithoutProjectInput, MaintenanceUncheckedCreateWithoutProjectInput> | MaintenanceCreateWithoutProjectInput[] | MaintenanceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutProjectInput | MaintenanceCreateOrConnectWithoutProjectInput[]
    createMany?: MaintenanceCreateManyProjectInputEnvelope
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<OrganizationCreateWithoutProjectsInput, OrganizationUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutProjectsInput
    upsert?: OrganizationUpsertWithoutProjectsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutProjectsInput, OrganizationUpdateWithoutProjectsInput>, OrganizationUncheckedUpdateWithoutProjectsInput>
  }

  export type CheckUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CheckCreateWithoutProjectInput, CheckUncheckedCreateWithoutProjectInput> | CheckCreateWithoutProjectInput[] | CheckUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CheckCreateOrConnectWithoutProjectInput | CheckCreateOrConnectWithoutProjectInput[]
    upsert?: CheckUpsertWithWhereUniqueWithoutProjectInput | CheckUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CheckCreateManyProjectInputEnvelope
    set?: CheckWhereUniqueInput | CheckWhereUniqueInput[]
    disconnect?: CheckWhereUniqueInput | CheckWhereUniqueInput[]
    delete?: CheckWhereUniqueInput | CheckWhereUniqueInput[]
    connect?: CheckWhereUniqueInput | CheckWhereUniqueInput[]
    update?: CheckUpdateWithWhereUniqueWithoutProjectInput | CheckUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CheckUpdateManyWithWhereWithoutProjectInput | CheckUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CheckScalarWhereInput | CheckScalarWhereInput[]
  }

  export type ChannelUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ChannelCreateWithoutProjectInput, ChannelUncheckedCreateWithoutProjectInput> | ChannelCreateWithoutProjectInput[] | ChannelUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutProjectInput | ChannelCreateOrConnectWithoutProjectInput[]
    upsert?: ChannelUpsertWithWhereUniqueWithoutProjectInput | ChannelUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ChannelCreateManyProjectInputEnvelope
    set?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    disconnect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    delete?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    update?: ChannelUpdateWithWhereUniqueWithoutProjectInput | ChannelUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ChannelUpdateManyWithWhereWithoutProjectInput | ChannelUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
  }

  export type ApiKeyUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ApiKeyCreateWithoutProjectInput, ApiKeyUncheckedCreateWithoutProjectInput> | ApiKeyCreateWithoutProjectInput[] | ApiKeyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutProjectInput | ApiKeyCreateOrConnectWithoutProjectInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutProjectInput | ApiKeyUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ApiKeyCreateManyProjectInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutProjectInput | ApiKeyUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutProjectInput | ApiKeyUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type IncidentUpdateManyWithoutProjectNestedInput = {
    create?: XOR<IncidentCreateWithoutProjectInput, IncidentUncheckedCreateWithoutProjectInput> | IncidentCreateWithoutProjectInput[] | IncidentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutProjectInput | IncidentCreateOrConnectWithoutProjectInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutProjectInput | IncidentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: IncidentCreateManyProjectInputEnvelope
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutProjectInput | IncidentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutProjectInput | IncidentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type MaintenanceUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MaintenanceCreateWithoutProjectInput, MaintenanceUncheckedCreateWithoutProjectInput> | MaintenanceCreateWithoutProjectInput[] | MaintenanceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutProjectInput | MaintenanceCreateOrConnectWithoutProjectInput[]
    upsert?: MaintenanceUpsertWithWhereUniqueWithoutProjectInput | MaintenanceUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MaintenanceCreateManyProjectInputEnvelope
    set?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    disconnect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    delete?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    update?: MaintenanceUpdateWithWhereUniqueWithoutProjectInput | MaintenanceUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MaintenanceUpdateManyWithWhereWithoutProjectInput | MaintenanceUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
  }

  export type CheckUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CheckCreateWithoutProjectInput, CheckUncheckedCreateWithoutProjectInput> | CheckCreateWithoutProjectInput[] | CheckUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CheckCreateOrConnectWithoutProjectInput | CheckCreateOrConnectWithoutProjectInput[]
    upsert?: CheckUpsertWithWhereUniqueWithoutProjectInput | CheckUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CheckCreateManyProjectInputEnvelope
    set?: CheckWhereUniqueInput | CheckWhereUniqueInput[]
    disconnect?: CheckWhereUniqueInput | CheckWhereUniqueInput[]
    delete?: CheckWhereUniqueInput | CheckWhereUniqueInput[]
    connect?: CheckWhereUniqueInput | CheckWhereUniqueInput[]
    update?: CheckUpdateWithWhereUniqueWithoutProjectInput | CheckUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CheckUpdateManyWithWhereWithoutProjectInput | CheckUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CheckScalarWhereInput | CheckScalarWhereInput[]
  }

  export type ChannelUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ChannelCreateWithoutProjectInput, ChannelUncheckedCreateWithoutProjectInput> | ChannelCreateWithoutProjectInput[] | ChannelUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutProjectInput | ChannelCreateOrConnectWithoutProjectInput[]
    upsert?: ChannelUpsertWithWhereUniqueWithoutProjectInput | ChannelUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ChannelCreateManyProjectInputEnvelope
    set?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    disconnect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    delete?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    update?: ChannelUpdateWithWhereUniqueWithoutProjectInput | ChannelUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ChannelUpdateManyWithWhereWithoutProjectInput | ChannelUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
  }

  export type ApiKeyUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ApiKeyCreateWithoutProjectInput, ApiKeyUncheckedCreateWithoutProjectInput> | ApiKeyCreateWithoutProjectInput[] | ApiKeyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutProjectInput | ApiKeyCreateOrConnectWithoutProjectInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutProjectInput | ApiKeyUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ApiKeyCreateManyProjectInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutProjectInput | ApiKeyUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutProjectInput | ApiKeyUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type IncidentUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<IncidentCreateWithoutProjectInput, IncidentUncheckedCreateWithoutProjectInput> | IncidentCreateWithoutProjectInput[] | IncidentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutProjectInput | IncidentCreateOrConnectWithoutProjectInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutProjectInput | IncidentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: IncidentCreateManyProjectInputEnvelope
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutProjectInput | IncidentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutProjectInput | IncidentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type MaintenanceUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MaintenanceCreateWithoutProjectInput, MaintenanceUncheckedCreateWithoutProjectInput> | MaintenanceCreateWithoutProjectInput[] | MaintenanceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutProjectInput | MaintenanceCreateOrConnectWithoutProjectInput[]
    upsert?: MaintenanceUpsertWithWhereUniqueWithoutProjectInput | MaintenanceUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MaintenanceCreateManyProjectInputEnvelope
    set?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    disconnect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    delete?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    update?: MaintenanceUpdateWithWhereUniqueWithoutProjectInput | MaintenanceUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MaintenanceUpdateManyWithWhereWithoutProjectInput | MaintenanceUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutChecksInput = {
    create?: XOR<ProjectCreateWithoutChecksInput, ProjectUncheckedCreateWithoutChecksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutChecksInput
    connect?: ProjectWhereUniqueInput
  }

  export type PingCreateNestedManyWithoutCheckInput = {
    create?: XOR<PingCreateWithoutCheckInput, PingUncheckedCreateWithoutCheckInput> | PingCreateWithoutCheckInput[] | PingUncheckedCreateWithoutCheckInput[]
    connectOrCreate?: PingCreateOrConnectWithoutCheckInput | PingCreateOrConnectWithoutCheckInput[]
    createMany?: PingCreateManyCheckInputEnvelope
    connect?: PingWhereUniqueInput | PingWhereUniqueInput[]
  }

  export type CheckChannelCreateNestedManyWithoutCheckInput = {
    create?: XOR<CheckChannelCreateWithoutCheckInput, CheckChannelUncheckedCreateWithoutCheckInput> | CheckChannelCreateWithoutCheckInput[] | CheckChannelUncheckedCreateWithoutCheckInput[]
    connectOrCreate?: CheckChannelCreateOrConnectWithoutCheckInput | CheckChannelCreateOrConnectWithoutCheckInput[]
    createMany?: CheckChannelCreateManyCheckInputEnvelope
    connect?: CheckChannelWhereUniqueInput | CheckChannelWhereUniqueInput[]
  }

  export type AlertCreateNestedManyWithoutCheckInput = {
    create?: XOR<AlertCreateWithoutCheckInput, AlertUncheckedCreateWithoutCheckInput> | AlertCreateWithoutCheckInput[] | AlertUncheckedCreateWithoutCheckInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutCheckInput | AlertCreateOrConnectWithoutCheckInput[]
    createMany?: AlertCreateManyCheckInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type IncidentCheckCreateNestedManyWithoutCheckInput = {
    create?: XOR<IncidentCheckCreateWithoutCheckInput, IncidentCheckUncheckedCreateWithoutCheckInput> | IncidentCheckCreateWithoutCheckInput[] | IncidentCheckUncheckedCreateWithoutCheckInput[]
    connectOrCreate?: IncidentCheckCreateOrConnectWithoutCheckInput | IncidentCheckCreateOrConnectWithoutCheckInput[]
    createMany?: IncidentCheckCreateManyCheckInputEnvelope
    connect?: IncidentCheckWhereUniqueInput | IncidentCheckWhereUniqueInput[]
  }

  export type MaintenanceCheckCreateNestedManyWithoutCheckInput = {
    create?: XOR<MaintenanceCheckCreateWithoutCheckInput, MaintenanceCheckUncheckedCreateWithoutCheckInput> | MaintenanceCheckCreateWithoutCheckInput[] | MaintenanceCheckUncheckedCreateWithoutCheckInput[]
    connectOrCreate?: MaintenanceCheckCreateOrConnectWithoutCheckInput | MaintenanceCheckCreateOrConnectWithoutCheckInput[]
    createMany?: MaintenanceCheckCreateManyCheckInputEnvelope
    connect?: MaintenanceCheckWhereUniqueInput | MaintenanceCheckWhereUniqueInput[]
  }

  export type CheckDailyStatCreateNestedManyWithoutCheckInput = {
    create?: XOR<CheckDailyStatCreateWithoutCheckInput, CheckDailyStatUncheckedCreateWithoutCheckInput> | CheckDailyStatCreateWithoutCheckInput[] | CheckDailyStatUncheckedCreateWithoutCheckInput[]
    connectOrCreate?: CheckDailyStatCreateOrConnectWithoutCheckInput | CheckDailyStatCreateOrConnectWithoutCheckInput[]
    createMany?: CheckDailyStatCreateManyCheckInputEnvelope
    connect?: CheckDailyStatWhereUniqueInput | CheckDailyStatWhereUniqueInput[]
  }

  export type PingUncheckedCreateNestedManyWithoutCheckInput = {
    create?: XOR<PingCreateWithoutCheckInput, PingUncheckedCreateWithoutCheckInput> | PingCreateWithoutCheckInput[] | PingUncheckedCreateWithoutCheckInput[]
    connectOrCreate?: PingCreateOrConnectWithoutCheckInput | PingCreateOrConnectWithoutCheckInput[]
    createMany?: PingCreateManyCheckInputEnvelope
    connect?: PingWhereUniqueInput | PingWhereUniqueInput[]
  }

  export type CheckChannelUncheckedCreateNestedManyWithoutCheckInput = {
    create?: XOR<CheckChannelCreateWithoutCheckInput, CheckChannelUncheckedCreateWithoutCheckInput> | CheckChannelCreateWithoutCheckInput[] | CheckChannelUncheckedCreateWithoutCheckInput[]
    connectOrCreate?: CheckChannelCreateOrConnectWithoutCheckInput | CheckChannelCreateOrConnectWithoutCheckInput[]
    createMany?: CheckChannelCreateManyCheckInputEnvelope
    connect?: CheckChannelWhereUniqueInput | CheckChannelWhereUniqueInput[]
  }

  export type AlertUncheckedCreateNestedManyWithoutCheckInput = {
    create?: XOR<AlertCreateWithoutCheckInput, AlertUncheckedCreateWithoutCheckInput> | AlertCreateWithoutCheckInput[] | AlertUncheckedCreateWithoutCheckInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutCheckInput | AlertCreateOrConnectWithoutCheckInput[]
    createMany?: AlertCreateManyCheckInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type IncidentCheckUncheckedCreateNestedManyWithoutCheckInput = {
    create?: XOR<IncidentCheckCreateWithoutCheckInput, IncidentCheckUncheckedCreateWithoutCheckInput> | IncidentCheckCreateWithoutCheckInput[] | IncidentCheckUncheckedCreateWithoutCheckInput[]
    connectOrCreate?: IncidentCheckCreateOrConnectWithoutCheckInput | IncidentCheckCreateOrConnectWithoutCheckInput[]
    createMany?: IncidentCheckCreateManyCheckInputEnvelope
    connect?: IncidentCheckWhereUniqueInput | IncidentCheckWhereUniqueInput[]
  }

  export type MaintenanceCheckUncheckedCreateNestedManyWithoutCheckInput = {
    create?: XOR<MaintenanceCheckCreateWithoutCheckInput, MaintenanceCheckUncheckedCreateWithoutCheckInput> | MaintenanceCheckCreateWithoutCheckInput[] | MaintenanceCheckUncheckedCreateWithoutCheckInput[]
    connectOrCreate?: MaintenanceCheckCreateOrConnectWithoutCheckInput | MaintenanceCheckCreateOrConnectWithoutCheckInput[]
    createMany?: MaintenanceCheckCreateManyCheckInputEnvelope
    connect?: MaintenanceCheckWhereUniqueInput | MaintenanceCheckWhereUniqueInput[]
  }

  export type CheckDailyStatUncheckedCreateNestedManyWithoutCheckInput = {
    create?: XOR<CheckDailyStatCreateWithoutCheckInput, CheckDailyStatUncheckedCreateWithoutCheckInput> | CheckDailyStatCreateWithoutCheckInput[] | CheckDailyStatUncheckedCreateWithoutCheckInput[]
    connectOrCreate?: CheckDailyStatCreateOrConnectWithoutCheckInput | CheckDailyStatCreateOrConnectWithoutCheckInput[]
    createMany?: CheckDailyStatCreateManyCheckInputEnvelope
    connect?: CheckDailyStatWhereUniqueInput | CheckDailyStatWhereUniqueInput[]
  }

  export type EnumScheduleTypeFieldUpdateOperationsInput = {
    set?: $Enums.ScheduleType
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumCheckStatusFieldUpdateOperationsInput = {
    set?: $Enums.CheckStatus
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjectUpdateOneRequiredWithoutChecksNestedInput = {
    create?: XOR<ProjectCreateWithoutChecksInput, ProjectUncheckedCreateWithoutChecksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutChecksInput
    upsert?: ProjectUpsertWithoutChecksInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutChecksInput, ProjectUpdateWithoutChecksInput>, ProjectUncheckedUpdateWithoutChecksInput>
  }

  export type PingUpdateManyWithoutCheckNestedInput = {
    create?: XOR<PingCreateWithoutCheckInput, PingUncheckedCreateWithoutCheckInput> | PingCreateWithoutCheckInput[] | PingUncheckedCreateWithoutCheckInput[]
    connectOrCreate?: PingCreateOrConnectWithoutCheckInput | PingCreateOrConnectWithoutCheckInput[]
    upsert?: PingUpsertWithWhereUniqueWithoutCheckInput | PingUpsertWithWhereUniqueWithoutCheckInput[]
    createMany?: PingCreateManyCheckInputEnvelope
    set?: PingWhereUniqueInput | PingWhereUniqueInput[]
    disconnect?: PingWhereUniqueInput | PingWhereUniqueInput[]
    delete?: PingWhereUniqueInput | PingWhereUniqueInput[]
    connect?: PingWhereUniqueInput | PingWhereUniqueInput[]
    update?: PingUpdateWithWhereUniqueWithoutCheckInput | PingUpdateWithWhereUniqueWithoutCheckInput[]
    updateMany?: PingUpdateManyWithWhereWithoutCheckInput | PingUpdateManyWithWhereWithoutCheckInput[]
    deleteMany?: PingScalarWhereInput | PingScalarWhereInput[]
  }

  export type CheckChannelUpdateManyWithoutCheckNestedInput = {
    create?: XOR<CheckChannelCreateWithoutCheckInput, CheckChannelUncheckedCreateWithoutCheckInput> | CheckChannelCreateWithoutCheckInput[] | CheckChannelUncheckedCreateWithoutCheckInput[]
    connectOrCreate?: CheckChannelCreateOrConnectWithoutCheckInput | CheckChannelCreateOrConnectWithoutCheckInput[]
    upsert?: CheckChannelUpsertWithWhereUniqueWithoutCheckInput | CheckChannelUpsertWithWhereUniqueWithoutCheckInput[]
    createMany?: CheckChannelCreateManyCheckInputEnvelope
    set?: CheckChannelWhereUniqueInput | CheckChannelWhereUniqueInput[]
    disconnect?: CheckChannelWhereUniqueInput | CheckChannelWhereUniqueInput[]
    delete?: CheckChannelWhereUniqueInput | CheckChannelWhereUniqueInput[]
    connect?: CheckChannelWhereUniqueInput | CheckChannelWhereUniqueInput[]
    update?: CheckChannelUpdateWithWhereUniqueWithoutCheckInput | CheckChannelUpdateWithWhereUniqueWithoutCheckInput[]
    updateMany?: CheckChannelUpdateManyWithWhereWithoutCheckInput | CheckChannelUpdateManyWithWhereWithoutCheckInput[]
    deleteMany?: CheckChannelScalarWhereInput | CheckChannelScalarWhereInput[]
  }

  export type AlertUpdateManyWithoutCheckNestedInput = {
    create?: XOR<AlertCreateWithoutCheckInput, AlertUncheckedCreateWithoutCheckInput> | AlertCreateWithoutCheckInput[] | AlertUncheckedCreateWithoutCheckInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutCheckInput | AlertCreateOrConnectWithoutCheckInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutCheckInput | AlertUpsertWithWhereUniqueWithoutCheckInput[]
    createMany?: AlertCreateManyCheckInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutCheckInput | AlertUpdateWithWhereUniqueWithoutCheckInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutCheckInput | AlertUpdateManyWithWhereWithoutCheckInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type IncidentCheckUpdateManyWithoutCheckNestedInput = {
    create?: XOR<IncidentCheckCreateWithoutCheckInput, IncidentCheckUncheckedCreateWithoutCheckInput> | IncidentCheckCreateWithoutCheckInput[] | IncidentCheckUncheckedCreateWithoutCheckInput[]
    connectOrCreate?: IncidentCheckCreateOrConnectWithoutCheckInput | IncidentCheckCreateOrConnectWithoutCheckInput[]
    upsert?: IncidentCheckUpsertWithWhereUniqueWithoutCheckInput | IncidentCheckUpsertWithWhereUniqueWithoutCheckInput[]
    createMany?: IncidentCheckCreateManyCheckInputEnvelope
    set?: IncidentCheckWhereUniqueInput | IncidentCheckWhereUniqueInput[]
    disconnect?: IncidentCheckWhereUniqueInput | IncidentCheckWhereUniqueInput[]
    delete?: IncidentCheckWhereUniqueInput | IncidentCheckWhereUniqueInput[]
    connect?: IncidentCheckWhereUniqueInput | IncidentCheckWhereUniqueInput[]
    update?: IncidentCheckUpdateWithWhereUniqueWithoutCheckInput | IncidentCheckUpdateWithWhereUniqueWithoutCheckInput[]
    updateMany?: IncidentCheckUpdateManyWithWhereWithoutCheckInput | IncidentCheckUpdateManyWithWhereWithoutCheckInput[]
    deleteMany?: IncidentCheckScalarWhereInput | IncidentCheckScalarWhereInput[]
  }

  export type MaintenanceCheckUpdateManyWithoutCheckNestedInput = {
    create?: XOR<MaintenanceCheckCreateWithoutCheckInput, MaintenanceCheckUncheckedCreateWithoutCheckInput> | MaintenanceCheckCreateWithoutCheckInput[] | MaintenanceCheckUncheckedCreateWithoutCheckInput[]
    connectOrCreate?: MaintenanceCheckCreateOrConnectWithoutCheckInput | MaintenanceCheckCreateOrConnectWithoutCheckInput[]
    upsert?: MaintenanceCheckUpsertWithWhereUniqueWithoutCheckInput | MaintenanceCheckUpsertWithWhereUniqueWithoutCheckInput[]
    createMany?: MaintenanceCheckCreateManyCheckInputEnvelope
    set?: MaintenanceCheckWhereUniqueInput | MaintenanceCheckWhereUniqueInput[]
    disconnect?: MaintenanceCheckWhereUniqueInput | MaintenanceCheckWhereUniqueInput[]
    delete?: MaintenanceCheckWhereUniqueInput | MaintenanceCheckWhereUniqueInput[]
    connect?: MaintenanceCheckWhereUniqueInput | MaintenanceCheckWhereUniqueInput[]
    update?: MaintenanceCheckUpdateWithWhereUniqueWithoutCheckInput | MaintenanceCheckUpdateWithWhereUniqueWithoutCheckInput[]
    updateMany?: MaintenanceCheckUpdateManyWithWhereWithoutCheckInput | MaintenanceCheckUpdateManyWithWhereWithoutCheckInput[]
    deleteMany?: MaintenanceCheckScalarWhereInput | MaintenanceCheckScalarWhereInput[]
  }

  export type CheckDailyStatUpdateManyWithoutCheckNestedInput = {
    create?: XOR<CheckDailyStatCreateWithoutCheckInput, CheckDailyStatUncheckedCreateWithoutCheckInput> | CheckDailyStatCreateWithoutCheckInput[] | CheckDailyStatUncheckedCreateWithoutCheckInput[]
    connectOrCreate?: CheckDailyStatCreateOrConnectWithoutCheckInput | CheckDailyStatCreateOrConnectWithoutCheckInput[]
    upsert?: CheckDailyStatUpsertWithWhereUniqueWithoutCheckInput | CheckDailyStatUpsertWithWhereUniqueWithoutCheckInput[]
    createMany?: CheckDailyStatCreateManyCheckInputEnvelope
    set?: CheckDailyStatWhereUniqueInput | CheckDailyStatWhereUniqueInput[]
    disconnect?: CheckDailyStatWhereUniqueInput | CheckDailyStatWhereUniqueInput[]
    delete?: CheckDailyStatWhereUniqueInput | CheckDailyStatWhereUniqueInput[]
    connect?: CheckDailyStatWhereUniqueInput | CheckDailyStatWhereUniqueInput[]
    update?: CheckDailyStatUpdateWithWhereUniqueWithoutCheckInput | CheckDailyStatUpdateWithWhereUniqueWithoutCheckInput[]
    updateMany?: CheckDailyStatUpdateManyWithWhereWithoutCheckInput | CheckDailyStatUpdateManyWithWhereWithoutCheckInput[]
    deleteMany?: CheckDailyStatScalarWhereInput | CheckDailyStatScalarWhereInput[]
  }

  export type PingUncheckedUpdateManyWithoutCheckNestedInput = {
    create?: XOR<PingCreateWithoutCheckInput, PingUncheckedCreateWithoutCheckInput> | PingCreateWithoutCheckInput[] | PingUncheckedCreateWithoutCheckInput[]
    connectOrCreate?: PingCreateOrConnectWithoutCheckInput | PingCreateOrConnectWithoutCheckInput[]
    upsert?: PingUpsertWithWhereUniqueWithoutCheckInput | PingUpsertWithWhereUniqueWithoutCheckInput[]
    createMany?: PingCreateManyCheckInputEnvelope
    set?: PingWhereUniqueInput | PingWhereUniqueInput[]
    disconnect?: PingWhereUniqueInput | PingWhereUniqueInput[]
    delete?: PingWhereUniqueInput | PingWhereUniqueInput[]
    connect?: PingWhereUniqueInput | PingWhereUniqueInput[]
    update?: PingUpdateWithWhereUniqueWithoutCheckInput | PingUpdateWithWhereUniqueWithoutCheckInput[]
    updateMany?: PingUpdateManyWithWhereWithoutCheckInput | PingUpdateManyWithWhereWithoutCheckInput[]
    deleteMany?: PingScalarWhereInput | PingScalarWhereInput[]
  }

  export type CheckChannelUncheckedUpdateManyWithoutCheckNestedInput = {
    create?: XOR<CheckChannelCreateWithoutCheckInput, CheckChannelUncheckedCreateWithoutCheckInput> | CheckChannelCreateWithoutCheckInput[] | CheckChannelUncheckedCreateWithoutCheckInput[]
    connectOrCreate?: CheckChannelCreateOrConnectWithoutCheckInput | CheckChannelCreateOrConnectWithoutCheckInput[]
    upsert?: CheckChannelUpsertWithWhereUniqueWithoutCheckInput | CheckChannelUpsertWithWhereUniqueWithoutCheckInput[]
    createMany?: CheckChannelCreateManyCheckInputEnvelope
    set?: CheckChannelWhereUniqueInput | CheckChannelWhereUniqueInput[]
    disconnect?: CheckChannelWhereUniqueInput | CheckChannelWhereUniqueInput[]
    delete?: CheckChannelWhereUniqueInput | CheckChannelWhereUniqueInput[]
    connect?: CheckChannelWhereUniqueInput | CheckChannelWhereUniqueInput[]
    update?: CheckChannelUpdateWithWhereUniqueWithoutCheckInput | CheckChannelUpdateWithWhereUniqueWithoutCheckInput[]
    updateMany?: CheckChannelUpdateManyWithWhereWithoutCheckInput | CheckChannelUpdateManyWithWhereWithoutCheckInput[]
    deleteMany?: CheckChannelScalarWhereInput | CheckChannelScalarWhereInput[]
  }

  export type AlertUncheckedUpdateManyWithoutCheckNestedInput = {
    create?: XOR<AlertCreateWithoutCheckInput, AlertUncheckedCreateWithoutCheckInput> | AlertCreateWithoutCheckInput[] | AlertUncheckedCreateWithoutCheckInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutCheckInput | AlertCreateOrConnectWithoutCheckInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutCheckInput | AlertUpsertWithWhereUniqueWithoutCheckInput[]
    createMany?: AlertCreateManyCheckInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutCheckInput | AlertUpdateWithWhereUniqueWithoutCheckInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutCheckInput | AlertUpdateManyWithWhereWithoutCheckInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type IncidentCheckUncheckedUpdateManyWithoutCheckNestedInput = {
    create?: XOR<IncidentCheckCreateWithoutCheckInput, IncidentCheckUncheckedCreateWithoutCheckInput> | IncidentCheckCreateWithoutCheckInput[] | IncidentCheckUncheckedCreateWithoutCheckInput[]
    connectOrCreate?: IncidentCheckCreateOrConnectWithoutCheckInput | IncidentCheckCreateOrConnectWithoutCheckInput[]
    upsert?: IncidentCheckUpsertWithWhereUniqueWithoutCheckInput | IncidentCheckUpsertWithWhereUniqueWithoutCheckInput[]
    createMany?: IncidentCheckCreateManyCheckInputEnvelope
    set?: IncidentCheckWhereUniqueInput | IncidentCheckWhereUniqueInput[]
    disconnect?: IncidentCheckWhereUniqueInput | IncidentCheckWhereUniqueInput[]
    delete?: IncidentCheckWhereUniqueInput | IncidentCheckWhereUniqueInput[]
    connect?: IncidentCheckWhereUniqueInput | IncidentCheckWhereUniqueInput[]
    update?: IncidentCheckUpdateWithWhereUniqueWithoutCheckInput | IncidentCheckUpdateWithWhereUniqueWithoutCheckInput[]
    updateMany?: IncidentCheckUpdateManyWithWhereWithoutCheckInput | IncidentCheckUpdateManyWithWhereWithoutCheckInput[]
    deleteMany?: IncidentCheckScalarWhereInput | IncidentCheckScalarWhereInput[]
  }

  export type MaintenanceCheckUncheckedUpdateManyWithoutCheckNestedInput = {
    create?: XOR<MaintenanceCheckCreateWithoutCheckInput, MaintenanceCheckUncheckedCreateWithoutCheckInput> | MaintenanceCheckCreateWithoutCheckInput[] | MaintenanceCheckUncheckedCreateWithoutCheckInput[]
    connectOrCreate?: MaintenanceCheckCreateOrConnectWithoutCheckInput | MaintenanceCheckCreateOrConnectWithoutCheckInput[]
    upsert?: MaintenanceCheckUpsertWithWhereUniqueWithoutCheckInput | MaintenanceCheckUpsertWithWhereUniqueWithoutCheckInput[]
    createMany?: MaintenanceCheckCreateManyCheckInputEnvelope
    set?: MaintenanceCheckWhereUniqueInput | MaintenanceCheckWhereUniqueInput[]
    disconnect?: MaintenanceCheckWhereUniqueInput | MaintenanceCheckWhereUniqueInput[]
    delete?: MaintenanceCheckWhereUniqueInput | MaintenanceCheckWhereUniqueInput[]
    connect?: MaintenanceCheckWhereUniqueInput | MaintenanceCheckWhereUniqueInput[]
    update?: MaintenanceCheckUpdateWithWhereUniqueWithoutCheckInput | MaintenanceCheckUpdateWithWhereUniqueWithoutCheckInput[]
    updateMany?: MaintenanceCheckUpdateManyWithWhereWithoutCheckInput | MaintenanceCheckUpdateManyWithWhereWithoutCheckInput[]
    deleteMany?: MaintenanceCheckScalarWhereInput | MaintenanceCheckScalarWhereInput[]
  }

  export type CheckDailyStatUncheckedUpdateManyWithoutCheckNestedInput = {
    create?: XOR<CheckDailyStatCreateWithoutCheckInput, CheckDailyStatUncheckedCreateWithoutCheckInput> | CheckDailyStatCreateWithoutCheckInput[] | CheckDailyStatUncheckedCreateWithoutCheckInput[]
    connectOrCreate?: CheckDailyStatCreateOrConnectWithoutCheckInput | CheckDailyStatCreateOrConnectWithoutCheckInput[]
    upsert?: CheckDailyStatUpsertWithWhereUniqueWithoutCheckInput | CheckDailyStatUpsertWithWhereUniqueWithoutCheckInput[]
    createMany?: CheckDailyStatCreateManyCheckInputEnvelope
    set?: CheckDailyStatWhereUniqueInput | CheckDailyStatWhereUniqueInput[]
    disconnect?: CheckDailyStatWhereUniqueInput | CheckDailyStatWhereUniqueInput[]
    delete?: CheckDailyStatWhereUniqueInput | CheckDailyStatWhereUniqueInput[]
    connect?: CheckDailyStatWhereUniqueInput | CheckDailyStatWhereUniqueInput[]
    update?: CheckDailyStatUpdateWithWhereUniqueWithoutCheckInput | CheckDailyStatUpdateWithWhereUniqueWithoutCheckInput[]
    updateMany?: CheckDailyStatUpdateManyWithWhereWithoutCheckInput | CheckDailyStatUpdateManyWithWhereWithoutCheckInput[]
    deleteMany?: CheckDailyStatScalarWhereInput | CheckDailyStatScalarWhereInput[]
  }

  export type CheckCreateNestedOneWithoutPingsInput = {
    create?: XOR<CheckCreateWithoutPingsInput, CheckUncheckedCreateWithoutPingsInput>
    connectOrCreate?: CheckCreateOrConnectWithoutPingsInput
    connect?: CheckWhereUniqueInput
  }

  export type EnumPingTypeFieldUpdateOperationsInput = {
    set?: $Enums.PingType
  }

  export type CheckUpdateOneRequiredWithoutPingsNestedInput = {
    create?: XOR<CheckCreateWithoutPingsInput, CheckUncheckedCreateWithoutPingsInput>
    connectOrCreate?: CheckCreateOrConnectWithoutPingsInput
    upsert?: CheckUpsertWithoutPingsInput
    connect?: CheckWhereUniqueInput
    update?: XOR<XOR<CheckUpdateToOneWithWhereWithoutPingsInput, CheckUpdateWithoutPingsInput>, CheckUncheckedUpdateWithoutPingsInput>
  }

  export type CheckCreateNestedOneWithoutDailyStatsInput = {
    create?: XOR<CheckCreateWithoutDailyStatsInput, CheckUncheckedCreateWithoutDailyStatsInput>
    connectOrCreate?: CheckCreateOrConnectWithoutDailyStatsInput
    connect?: CheckWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CheckUpdateOneRequiredWithoutDailyStatsNestedInput = {
    create?: XOR<CheckCreateWithoutDailyStatsInput, CheckUncheckedCreateWithoutDailyStatsInput>
    connectOrCreate?: CheckCreateOrConnectWithoutDailyStatsInput
    upsert?: CheckUpsertWithoutDailyStatsInput
    connect?: CheckWhereUniqueInput
    update?: XOR<XOR<CheckUpdateToOneWithWhereWithoutDailyStatsInput, CheckUpdateWithoutDailyStatsInput>, CheckUncheckedUpdateWithoutDailyStatsInput>
  }

  export type ProjectCreateNestedOneWithoutChannelsInput = {
    create?: XOR<ProjectCreateWithoutChannelsInput, ProjectUncheckedCreateWithoutChannelsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutChannelsInput
    connect?: ProjectWhereUniqueInput
  }

  export type CheckChannelCreateNestedManyWithoutChannelInput = {
    create?: XOR<CheckChannelCreateWithoutChannelInput, CheckChannelUncheckedCreateWithoutChannelInput> | CheckChannelCreateWithoutChannelInput[] | CheckChannelUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: CheckChannelCreateOrConnectWithoutChannelInput | CheckChannelCreateOrConnectWithoutChannelInput[]
    createMany?: CheckChannelCreateManyChannelInputEnvelope
    connect?: CheckChannelWhereUniqueInput | CheckChannelWhereUniqueInput[]
  }

  export type CheckChannelUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<CheckChannelCreateWithoutChannelInput, CheckChannelUncheckedCreateWithoutChannelInput> | CheckChannelCreateWithoutChannelInput[] | CheckChannelUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: CheckChannelCreateOrConnectWithoutChannelInput | CheckChannelCreateOrConnectWithoutChannelInput[]
    createMany?: CheckChannelCreateManyChannelInputEnvelope
    connect?: CheckChannelWhereUniqueInput | CheckChannelWhereUniqueInput[]
  }

  export type EnumChannelTypeFieldUpdateOperationsInput = {
    set?: $Enums.ChannelType
  }

  export type ProjectUpdateOneRequiredWithoutChannelsNestedInput = {
    create?: XOR<ProjectCreateWithoutChannelsInput, ProjectUncheckedCreateWithoutChannelsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutChannelsInput
    upsert?: ProjectUpsertWithoutChannelsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutChannelsInput, ProjectUpdateWithoutChannelsInput>, ProjectUncheckedUpdateWithoutChannelsInput>
  }

  export type CheckChannelUpdateManyWithoutChannelNestedInput = {
    create?: XOR<CheckChannelCreateWithoutChannelInput, CheckChannelUncheckedCreateWithoutChannelInput> | CheckChannelCreateWithoutChannelInput[] | CheckChannelUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: CheckChannelCreateOrConnectWithoutChannelInput | CheckChannelCreateOrConnectWithoutChannelInput[]
    upsert?: CheckChannelUpsertWithWhereUniqueWithoutChannelInput | CheckChannelUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: CheckChannelCreateManyChannelInputEnvelope
    set?: CheckChannelWhereUniqueInput | CheckChannelWhereUniqueInput[]
    disconnect?: CheckChannelWhereUniqueInput | CheckChannelWhereUniqueInput[]
    delete?: CheckChannelWhereUniqueInput | CheckChannelWhereUniqueInput[]
    connect?: CheckChannelWhereUniqueInput | CheckChannelWhereUniqueInput[]
    update?: CheckChannelUpdateWithWhereUniqueWithoutChannelInput | CheckChannelUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: CheckChannelUpdateManyWithWhereWithoutChannelInput | CheckChannelUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: CheckChannelScalarWhereInput | CheckChannelScalarWhereInput[]
  }

  export type CheckChannelUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<CheckChannelCreateWithoutChannelInput, CheckChannelUncheckedCreateWithoutChannelInput> | CheckChannelCreateWithoutChannelInput[] | CheckChannelUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: CheckChannelCreateOrConnectWithoutChannelInput | CheckChannelCreateOrConnectWithoutChannelInput[]
    upsert?: CheckChannelUpsertWithWhereUniqueWithoutChannelInput | CheckChannelUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: CheckChannelCreateManyChannelInputEnvelope
    set?: CheckChannelWhereUniqueInput | CheckChannelWhereUniqueInput[]
    disconnect?: CheckChannelWhereUniqueInput | CheckChannelWhereUniqueInput[]
    delete?: CheckChannelWhereUniqueInput | CheckChannelWhereUniqueInput[]
    connect?: CheckChannelWhereUniqueInput | CheckChannelWhereUniqueInput[]
    update?: CheckChannelUpdateWithWhereUniqueWithoutChannelInput | CheckChannelUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: CheckChannelUpdateManyWithWhereWithoutChannelInput | CheckChannelUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: CheckChannelScalarWhereInput | CheckChannelScalarWhereInput[]
  }

  export type CheckCreateNestedOneWithoutCheckChannelsInput = {
    create?: XOR<CheckCreateWithoutCheckChannelsInput, CheckUncheckedCreateWithoutCheckChannelsInput>
    connectOrCreate?: CheckCreateOrConnectWithoutCheckChannelsInput
    connect?: CheckWhereUniqueInput
  }

  export type ChannelCreateNestedOneWithoutCheckChannelsInput = {
    create?: XOR<ChannelCreateWithoutCheckChannelsInput, ChannelUncheckedCreateWithoutCheckChannelsInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutCheckChannelsInput
    connect?: ChannelWhereUniqueInput
  }

  export type CheckUpdateOneRequiredWithoutCheckChannelsNestedInput = {
    create?: XOR<CheckCreateWithoutCheckChannelsInput, CheckUncheckedCreateWithoutCheckChannelsInput>
    connectOrCreate?: CheckCreateOrConnectWithoutCheckChannelsInput
    upsert?: CheckUpsertWithoutCheckChannelsInput
    connect?: CheckWhereUniqueInput
    update?: XOR<XOR<CheckUpdateToOneWithWhereWithoutCheckChannelsInput, CheckUpdateWithoutCheckChannelsInput>, CheckUncheckedUpdateWithoutCheckChannelsInput>
  }

  export type ChannelUpdateOneRequiredWithoutCheckChannelsNestedInput = {
    create?: XOR<ChannelCreateWithoutCheckChannelsInput, ChannelUncheckedCreateWithoutCheckChannelsInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutCheckChannelsInput
    upsert?: ChannelUpsertWithoutCheckChannelsInput
    connect?: ChannelWhereUniqueInput
    update?: XOR<XOR<ChannelUpdateToOneWithWhereWithoutCheckChannelsInput, ChannelUpdateWithoutCheckChannelsInput>, ChannelUncheckedUpdateWithoutCheckChannelsInput>
  }

  export type CheckCreateNestedOneWithoutAlertsInput = {
    create?: XOR<CheckCreateWithoutAlertsInput, CheckUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: CheckCreateOrConnectWithoutAlertsInput
    connect?: CheckWhereUniqueInput
  }

  export type CheckUpdateOneRequiredWithoutAlertsNestedInput = {
    create?: XOR<CheckCreateWithoutAlertsInput, CheckUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: CheckCreateOrConnectWithoutAlertsInput
    upsert?: CheckUpsertWithoutAlertsInput
    connect?: CheckWhereUniqueInput
    update?: XOR<XOR<CheckUpdateToOneWithWhereWithoutAlertsInput, CheckUpdateWithoutAlertsInput>, CheckUncheckedUpdateWithoutAlertsInput>
  }

  export type ProjectCreateNestedOneWithoutApiKeysInput = {
    create?: XOR<ProjectCreateWithoutApiKeysInput, ProjectUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutApiKeysInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutApiKeysNestedInput = {
    create?: XOR<ProjectCreateWithoutApiKeysInput, ProjectUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutApiKeysInput
    upsert?: ProjectUpsertWithoutApiKeysInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutApiKeysInput, ProjectUpdateWithoutApiKeysInput>, ProjectUncheckedUpdateWithoutApiKeysInput>
  }

  export type ProjectCreateNestedOneWithoutIncidentsInput = {
    create?: XOR<ProjectCreateWithoutIncidentsInput, ProjectUncheckedCreateWithoutIncidentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutIncidentsInput
    connect?: ProjectWhereUniqueInput
  }

  export type IncidentUpdateCreateNestedManyWithoutIncidentInput = {
    create?: XOR<IncidentUpdateCreateWithoutIncidentInput, IncidentUpdateUncheckedCreateWithoutIncidentInput> | IncidentUpdateCreateWithoutIncidentInput[] | IncidentUpdateUncheckedCreateWithoutIncidentInput[]
    connectOrCreate?: IncidentUpdateCreateOrConnectWithoutIncidentInput | IncidentUpdateCreateOrConnectWithoutIncidentInput[]
    createMany?: IncidentUpdateCreateManyIncidentInputEnvelope
    connect?: IncidentUpdateWhereUniqueInput | IncidentUpdateWhereUniqueInput[]
  }

  export type IncidentCheckCreateNestedManyWithoutIncidentInput = {
    create?: XOR<IncidentCheckCreateWithoutIncidentInput, IncidentCheckUncheckedCreateWithoutIncidentInput> | IncidentCheckCreateWithoutIncidentInput[] | IncidentCheckUncheckedCreateWithoutIncidentInput[]
    connectOrCreate?: IncidentCheckCreateOrConnectWithoutIncidentInput | IncidentCheckCreateOrConnectWithoutIncidentInput[]
    createMany?: IncidentCheckCreateManyIncidentInputEnvelope
    connect?: IncidentCheckWhereUniqueInput | IncidentCheckWhereUniqueInput[]
  }

  export type IncidentUpdateUncheckedCreateNestedManyWithoutIncidentInput = {
    create?: XOR<IncidentUpdateCreateWithoutIncidentInput, IncidentUpdateUncheckedCreateWithoutIncidentInput> | IncidentUpdateCreateWithoutIncidentInput[] | IncidentUpdateUncheckedCreateWithoutIncidentInput[]
    connectOrCreate?: IncidentUpdateCreateOrConnectWithoutIncidentInput | IncidentUpdateCreateOrConnectWithoutIncidentInput[]
    createMany?: IncidentUpdateCreateManyIncidentInputEnvelope
    connect?: IncidentUpdateWhereUniqueInput | IncidentUpdateWhereUniqueInput[]
  }

  export type IncidentCheckUncheckedCreateNestedManyWithoutIncidentInput = {
    create?: XOR<IncidentCheckCreateWithoutIncidentInput, IncidentCheckUncheckedCreateWithoutIncidentInput> | IncidentCheckCreateWithoutIncidentInput[] | IncidentCheckUncheckedCreateWithoutIncidentInput[]
    connectOrCreate?: IncidentCheckCreateOrConnectWithoutIncidentInput | IncidentCheckCreateOrConnectWithoutIncidentInput[]
    createMany?: IncidentCheckCreateManyIncidentInputEnvelope
    connect?: IncidentCheckWhereUniqueInput | IncidentCheckWhereUniqueInput[]
  }

  export type EnumIncidentStatusFieldUpdateOperationsInput = {
    set?: $Enums.IncidentStatus
  }

  export type EnumIncidentImpactFieldUpdateOperationsInput = {
    set?: $Enums.IncidentImpact
  }

  export type ProjectUpdateOneRequiredWithoutIncidentsNestedInput = {
    create?: XOR<ProjectCreateWithoutIncidentsInput, ProjectUncheckedCreateWithoutIncidentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutIncidentsInput
    upsert?: ProjectUpsertWithoutIncidentsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutIncidentsInput, ProjectUpdateWithoutIncidentsInput>, ProjectUncheckedUpdateWithoutIncidentsInput>
  }

  export type IncidentUpdateUpdateManyWithoutIncidentNestedInput = {
    create?: XOR<IncidentUpdateCreateWithoutIncidentInput, IncidentUpdateUncheckedCreateWithoutIncidentInput> | IncidentUpdateCreateWithoutIncidentInput[] | IncidentUpdateUncheckedCreateWithoutIncidentInput[]
    connectOrCreate?: IncidentUpdateCreateOrConnectWithoutIncidentInput | IncidentUpdateCreateOrConnectWithoutIncidentInput[]
    upsert?: IncidentUpdateUpsertWithWhereUniqueWithoutIncidentInput | IncidentUpdateUpsertWithWhereUniqueWithoutIncidentInput[]
    createMany?: IncidentUpdateCreateManyIncidentInputEnvelope
    set?: IncidentUpdateWhereUniqueInput | IncidentUpdateWhereUniqueInput[]
    disconnect?: IncidentUpdateWhereUniqueInput | IncidentUpdateWhereUniqueInput[]
    delete?: IncidentUpdateWhereUniqueInput | IncidentUpdateWhereUniqueInput[]
    connect?: IncidentUpdateWhereUniqueInput | IncidentUpdateWhereUniqueInput[]
    update?: IncidentUpdateUpdateWithWhereUniqueWithoutIncidentInput | IncidentUpdateUpdateWithWhereUniqueWithoutIncidentInput[]
    updateMany?: IncidentUpdateUpdateManyWithWhereWithoutIncidentInput | IncidentUpdateUpdateManyWithWhereWithoutIncidentInput[]
    deleteMany?: IncidentUpdateScalarWhereInput | IncidentUpdateScalarWhereInput[]
  }

  export type IncidentCheckUpdateManyWithoutIncidentNestedInput = {
    create?: XOR<IncidentCheckCreateWithoutIncidentInput, IncidentCheckUncheckedCreateWithoutIncidentInput> | IncidentCheckCreateWithoutIncidentInput[] | IncidentCheckUncheckedCreateWithoutIncidentInput[]
    connectOrCreate?: IncidentCheckCreateOrConnectWithoutIncidentInput | IncidentCheckCreateOrConnectWithoutIncidentInput[]
    upsert?: IncidentCheckUpsertWithWhereUniqueWithoutIncidentInput | IncidentCheckUpsertWithWhereUniqueWithoutIncidentInput[]
    createMany?: IncidentCheckCreateManyIncidentInputEnvelope
    set?: IncidentCheckWhereUniqueInput | IncidentCheckWhereUniqueInput[]
    disconnect?: IncidentCheckWhereUniqueInput | IncidentCheckWhereUniqueInput[]
    delete?: IncidentCheckWhereUniqueInput | IncidentCheckWhereUniqueInput[]
    connect?: IncidentCheckWhereUniqueInput | IncidentCheckWhereUniqueInput[]
    update?: IncidentCheckUpdateWithWhereUniqueWithoutIncidentInput | IncidentCheckUpdateWithWhereUniqueWithoutIncidentInput[]
    updateMany?: IncidentCheckUpdateManyWithWhereWithoutIncidentInput | IncidentCheckUpdateManyWithWhereWithoutIncidentInput[]
    deleteMany?: IncidentCheckScalarWhereInput | IncidentCheckScalarWhereInput[]
  }

  export type IncidentUpdateUncheckedUpdateManyWithoutIncidentNestedInput = {
    create?: XOR<IncidentUpdateCreateWithoutIncidentInput, IncidentUpdateUncheckedCreateWithoutIncidentInput> | IncidentUpdateCreateWithoutIncidentInput[] | IncidentUpdateUncheckedCreateWithoutIncidentInput[]
    connectOrCreate?: IncidentUpdateCreateOrConnectWithoutIncidentInput | IncidentUpdateCreateOrConnectWithoutIncidentInput[]
    upsert?: IncidentUpdateUpsertWithWhereUniqueWithoutIncidentInput | IncidentUpdateUpsertWithWhereUniqueWithoutIncidentInput[]
    createMany?: IncidentUpdateCreateManyIncidentInputEnvelope
    set?: IncidentUpdateWhereUniqueInput | IncidentUpdateWhereUniqueInput[]
    disconnect?: IncidentUpdateWhereUniqueInput | IncidentUpdateWhereUniqueInput[]
    delete?: IncidentUpdateWhereUniqueInput | IncidentUpdateWhereUniqueInput[]
    connect?: IncidentUpdateWhereUniqueInput | IncidentUpdateWhereUniqueInput[]
    update?: IncidentUpdateUpdateWithWhereUniqueWithoutIncidentInput | IncidentUpdateUpdateWithWhereUniqueWithoutIncidentInput[]
    updateMany?: IncidentUpdateUpdateManyWithWhereWithoutIncidentInput | IncidentUpdateUpdateManyWithWhereWithoutIncidentInput[]
    deleteMany?: IncidentUpdateScalarWhereInput | IncidentUpdateScalarWhereInput[]
  }

  export type IncidentCheckUncheckedUpdateManyWithoutIncidentNestedInput = {
    create?: XOR<IncidentCheckCreateWithoutIncidentInput, IncidentCheckUncheckedCreateWithoutIncidentInput> | IncidentCheckCreateWithoutIncidentInput[] | IncidentCheckUncheckedCreateWithoutIncidentInput[]
    connectOrCreate?: IncidentCheckCreateOrConnectWithoutIncidentInput | IncidentCheckCreateOrConnectWithoutIncidentInput[]
    upsert?: IncidentCheckUpsertWithWhereUniqueWithoutIncidentInput | IncidentCheckUpsertWithWhereUniqueWithoutIncidentInput[]
    createMany?: IncidentCheckCreateManyIncidentInputEnvelope
    set?: IncidentCheckWhereUniqueInput | IncidentCheckWhereUniqueInput[]
    disconnect?: IncidentCheckWhereUniqueInput | IncidentCheckWhereUniqueInput[]
    delete?: IncidentCheckWhereUniqueInput | IncidentCheckWhereUniqueInput[]
    connect?: IncidentCheckWhereUniqueInput | IncidentCheckWhereUniqueInput[]
    update?: IncidentCheckUpdateWithWhereUniqueWithoutIncidentInput | IncidentCheckUpdateWithWhereUniqueWithoutIncidentInput[]
    updateMany?: IncidentCheckUpdateManyWithWhereWithoutIncidentInput | IncidentCheckUpdateManyWithWhereWithoutIncidentInput[]
    deleteMany?: IncidentCheckScalarWhereInput | IncidentCheckScalarWhereInput[]
  }

  export type IncidentCreateNestedOneWithoutUpdatesInput = {
    create?: XOR<IncidentCreateWithoutUpdatesInput, IncidentUncheckedCreateWithoutUpdatesInput>
    connectOrCreate?: IncidentCreateOrConnectWithoutUpdatesInput
    connect?: IncidentWhereUniqueInput
  }

  export type IncidentUpdateOneRequiredWithoutUpdatesNestedInput = {
    create?: XOR<IncidentCreateWithoutUpdatesInput, IncidentUncheckedCreateWithoutUpdatesInput>
    connectOrCreate?: IncidentCreateOrConnectWithoutUpdatesInput
    upsert?: IncidentUpsertWithoutUpdatesInput
    connect?: IncidentWhereUniqueInput
    update?: XOR<XOR<IncidentUpdateToOneWithWhereWithoutUpdatesInput, IncidentUpdateWithoutUpdatesInput>, IncidentUncheckedUpdateWithoutUpdatesInput>
  }

  export type IncidentCreateNestedOneWithoutChecksInput = {
    create?: XOR<IncidentCreateWithoutChecksInput, IncidentUncheckedCreateWithoutChecksInput>
    connectOrCreate?: IncidentCreateOrConnectWithoutChecksInput
    connect?: IncidentWhereUniqueInput
  }

  export type CheckCreateNestedOneWithoutIncidentChecksInput = {
    create?: XOR<CheckCreateWithoutIncidentChecksInput, CheckUncheckedCreateWithoutIncidentChecksInput>
    connectOrCreate?: CheckCreateOrConnectWithoutIncidentChecksInput
    connect?: CheckWhereUniqueInput
  }

  export type IncidentUpdateOneRequiredWithoutChecksNestedInput = {
    create?: XOR<IncidentCreateWithoutChecksInput, IncidentUncheckedCreateWithoutChecksInput>
    connectOrCreate?: IncidentCreateOrConnectWithoutChecksInput
    upsert?: IncidentUpsertWithoutChecksInput
    connect?: IncidentWhereUniqueInput
    update?: XOR<XOR<IncidentUpdateToOneWithWhereWithoutChecksInput, IncidentUpdateWithoutChecksInput>, IncidentUncheckedUpdateWithoutChecksInput>
  }

  export type CheckUpdateOneRequiredWithoutIncidentChecksNestedInput = {
    create?: XOR<CheckCreateWithoutIncidentChecksInput, CheckUncheckedCreateWithoutIncidentChecksInput>
    connectOrCreate?: CheckCreateOrConnectWithoutIncidentChecksInput
    upsert?: CheckUpsertWithoutIncidentChecksInput
    connect?: CheckWhereUniqueInput
    update?: XOR<XOR<CheckUpdateToOneWithWhereWithoutIncidentChecksInput, CheckUpdateWithoutIncidentChecksInput>, CheckUncheckedUpdateWithoutIncidentChecksInput>
  }

  export type ProjectCreateNestedOneWithoutMaintenanceInput = {
    create?: XOR<ProjectCreateWithoutMaintenanceInput, ProjectUncheckedCreateWithoutMaintenanceInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMaintenanceInput
    connect?: ProjectWhereUniqueInput
  }

  export type MaintenanceCheckCreateNestedManyWithoutMaintenanceInput = {
    create?: XOR<MaintenanceCheckCreateWithoutMaintenanceInput, MaintenanceCheckUncheckedCreateWithoutMaintenanceInput> | MaintenanceCheckCreateWithoutMaintenanceInput[] | MaintenanceCheckUncheckedCreateWithoutMaintenanceInput[]
    connectOrCreate?: MaintenanceCheckCreateOrConnectWithoutMaintenanceInput | MaintenanceCheckCreateOrConnectWithoutMaintenanceInput[]
    createMany?: MaintenanceCheckCreateManyMaintenanceInputEnvelope
    connect?: MaintenanceCheckWhereUniqueInput | MaintenanceCheckWhereUniqueInput[]
  }

  export type MaintenanceCheckUncheckedCreateNestedManyWithoutMaintenanceInput = {
    create?: XOR<MaintenanceCheckCreateWithoutMaintenanceInput, MaintenanceCheckUncheckedCreateWithoutMaintenanceInput> | MaintenanceCheckCreateWithoutMaintenanceInput[] | MaintenanceCheckUncheckedCreateWithoutMaintenanceInput[]
    connectOrCreate?: MaintenanceCheckCreateOrConnectWithoutMaintenanceInput | MaintenanceCheckCreateOrConnectWithoutMaintenanceInput[]
    createMany?: MaintenanceCheckCreateManyMaintenanceInputEnvelope
    connect?: MaintenanceCheckWhereUniqueInput | MaintenanceCheckWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutMaintenanceNestedInput = {
    create?: XOR<ProjectCreateWithoutMaintenanceInput, ProjectUncheckedCreateWithoutMaintenanceInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMaintenanceInput
    upsert?: ProjectUpsertWithoutMaintenanceInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMaintenanceInput, ProjectUpdateWithoutMaintenanceInput>, ProjectUncheckedUpdateWithoutMaintenanceInput>
  }

  export type MaintenanceCheckUpdateManyWithoutMaintenanceNestedInput = {
    create?: XOR<MaintenanceCheckCreateWithoutMaintenanceInput, MaintenanceCheckUncheckedCreateWithoutMaintenanceInput> | MaintenanceCheckCreateWithoutMaintenanceInput[] | MaintenanceCheckUncheckedCreateWithoutMaintenanceInput[]
    connectOrCreate?: MaintenanceCheckCreateOrConnectWithoutMaintenanceInput | MaintenanceCheckCreateOrConnectWithoutMaintenanceInput[]
    upsert?: MaintenanceCheckUpsertWithWhereUniqueWithoutMaintenanceInput | MaintenanceCheckUpsertWithWhereUniqueWithoutMaintenanceInput[]
    createMany?: MaintenanceCheckCreateManyMaintenanceInputEnvelope
    set?: MaintenanceCheckWhereUniqueInput | MaintenanceCheckWhereUniqueInput[]
    disconnect?: MaintenanceCheckWhereUniqueInput | MaintenanceCheckWhereUniqueInput[]
    delete?: MaintenanceCheckWhereUniqueInput | MaintenanceCheckWhereUniqueInput[]
    connect?: MaintenanceCheckWhereUniqueInput | MaintenanceCheckWhereUniqueInput[]
    update?: MaintenanceCheckUpdateWithWhereUniqueWithoutMaintenanceInput | MaintenanceCheckUpdateWithWhereUniqueWithoutMaintenanceInput[]
    updateMany?: MaintenanceCheckUpdateManyWithWhereWithoutMaintenanceInput | MaintenanceCheckUpdateManyWithWhereWithoutMaintenanceInput[]
    deleteMany?: MaintenanceCheckScalarWhereInput | MaintenanceCheckScalarWhereInput[]
  }

  export type MaintenanceCheckUncheckedUpdateManyWithoutMaintenanceNestedInput = {
    create?: XOR<MaintenanceCheckCreateWithoutMaintenanceInput, MaintenanceCheckUncheckedCreateWithoutMaintenanceInput> | MaintenanceCheckCreateWithoutMaintenanceInput[] | MaintenanceCheckUncheckedCreateWithoutMaintenanceInput[]
    connectOrCreate?: MaintenanceCheckCreateOrConnectWithoutMaintenanceInput | MaintenanceCheckCreateOrConnectWithoutMaintenanceInput[]
    upsert?: MaintenanceCheckUpsertWithWhereUniqueWithoutMaintenanceInput | MaintenanceCheckUpsertWithWhereUniqueWithoutMaintenanceInput[]
    createMany?: MaintenanceCheckCreateManyMaintenanceInputEnvelope
    set?: MaintenanceCheckWhereUniqueInput | MaintenanceCheckWhereUniqueInput[]
    disconnect?: MaintenanceCheckWhereUniqueInput | MaintenanceCheckWhereUniqueInput[]
    delete?: MaintenanceCheckWhereUniqueInput | MaintenanceCheckWhereUniqueInput[]
    connect?: MaintenanceCheckWhereUniqueInput | MaintenanceCheckWhereUniqueInput[]
    update?: MaintenanceCheckUpdateWithWhereUniqueWithoutMaintenanceInput | MaintenanceCheckUpdateWithWhereUniqueWithoutMaintenanceInput[]
    updateMany?: MaintenanceCheckUpdateManyWithWhereWithoutMaintenanceInput | MaintenanceCheckUpdateManyWithWhereWithoutMaintenanceInput[]
    deleteMany?: MaintenanceCheckScalarWhereInput | MaintenanceCheckScalarWhereInput[]
  }

  export type MaintenanceCreateNestedOneWithoutChecksInput = {
    create?: XOR<MaintenanceCreateWithoutChecksInput, MaintenanceUncheckedCreateWithoutChecksInput>
    connectOrCreate?: MaintenanceCreateOrConnectWithoutChecksInput
    connect?: MaintenanceWhereUniqueInput
  }

  export type CheckCreateNestedOneWithoutMaintenanceChecksInput = {
    create?: XOR<CheckCreateWithoutMaintenanceChecksInput, CheckUncheckedCreateWithoutMaintenanceChecksInput>
    connectOrCreate?: CheckCreateOrConnectWithoutMaintenanceChecksInput
    connect?: CheckWhereUniqueInput
  }

  export type MaintenanceUpdateOneRequiredWithoutChecksNestedInput = {
    create?: XOR<MaintenanceCreateWithoutChecksInput, MaintenanceUncheckedCreateWithoutChecksInput>
    connectOrCreate?: MaintenanceCreateOrConnectWithoutChecksInput
    upsert?: MaintenanceUpsertWithoutChecksInput
    connect?: MaintenanceWhereUniqueInput
    update?: XOR<XOR<MaintenanceUpdateToOneWithWhereWithoutChecksInput, MaintenanceUpdateWithoutChecksInput>, MaintenanceUncheckedUpdateWithoutChecksInput>
  }

  export type CheckUpdateOneRequiredWithoutMaintenanceChecksNestedInput = {
    create?: XOR<CheckCreateWithoutMaintenanceChecksInput, CheckUncheckedCreateWithoutMaintenanceChecksInput>
    connectOrCreate?: CheckCreateOrConnectWithoutMaintenanceChecksInput
    upsert?: CheckUpsertWithoutMaintenanceChecksInput
    connect?: CheckWhereUniqueInput
    update?: XOR<XOR<CheckUpdateToOneWithWhereWithoutMaintenanceChecksInput, CheckUpdateWithoutMaintenanceChecksInput>, CheckUncheckedUpdateWithoutMaintenanceChecksInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumScheduleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleType | EnumScheduleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleType[] | ListEnumScheduleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleType[] | ListEnumScheduleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleTypeFilter<$PrismaModel> | $Enums.ScheduleType
  }

  export type NestedEnumCheckStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CheckStatus | EnumCheckStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CheckStatus[] | ListEnumCheckStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CheckStatus[] | ListEnumCheckStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCheckStatusFilter<$PrismaModel> | $Enums.CheckStatus
  }

  export type NestedEnumScheduleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleType | EnumScheduleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleType[] | ListEnumScheduleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleType[] | ListEnumScheduleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleTypeWithAggregatesFilter<$PrismaModel> | $Enums.ScheduleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScheduleTypeFilter<$PrismaModel>
    _max?: NestedEnumScheduleTypeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumCheckStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CheckStatus | EnumCheckStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CheckStatus[] | ListEnumCheckStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CheckStatus[] | ListEnumCheckStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCheckStatusWithAggregatesFilter<$PrismaModel> | $Enums.CheckStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCheckStatusFilter<$PrismaModel>
    _max?: NestedEnumCheckStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumPingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PingType | EnumPingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PingType[] | ListEnumPingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PingType[] | ListEnumPingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPingTypeFilter<$PrismaModel> | $Enums.PingType
  }

  export type NestedEnumPingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PingType | EnumPingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PingType[] | ListEnumPingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PingType[] | ListEnumPingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPingTypeWithAggregatesFilter<$PrismaModel> | $Enums.PingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPingTypeFilter<$PrismaModel>
    _max?: NestedEnumPingTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumChannelTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChannelType | EnumChannelTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChannelType[] | ListEnumChannelTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChannelType[] | ListEnumChannelTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChannelTypeFilter<$PrismaModel> | $Enums.ChannelType
  }

  export type NestedEnumChannelTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChannelType | EnumChannelTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChannelType[] | ListEnumChannelTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChannelType[] | ListEnumChannelTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChannelTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChannelType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChannelTypeFilter<$PrismaModel>
    _max?: NestedEnumChannelTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumIncidentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentStatusFilter<$PrismaModel> | $Enums.IncidentStatus
  }

  export type NestedEnumIncidentImpactFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentImpact | EnumIncidentImpactFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentImpact[] | ListEnumIncidentImpactFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentImpact[] | ListEnumIncidentImpactFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentImpactFilter<$PrismaModel> | $Enums.IncidentImpact
  }

  export type NestedEnumIncidentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentStatus[] | ListEnumIncidentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentStatusWithAggregatesFilter<$PrismaModel> | $Enums.IncidentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentStatusFilter<$PrismaModel>
    _max?: NestedEnumIncidentStatusFilter<$PrismaModel>
  }

  export type NestedEnumIncidentImpactWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentImpact | EnumIncidentImpactFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentImpact[] | ListEnumIncidentImpactFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncidentImpact[] | ListEnumIncidentImpactFieldRefInput<$PrismaModel>
    not?: NestedEnumIncidentImpactWithAggregatesFilter<$PrismaModel> | $Enums.IncidentImpact
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentImpactFilter<$PrismaModel>
    _max?: NestedEnumIncidentImpactFilter<$PrismaModel>
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrgMemberCreateWithoutUserInput = {
    id?: string
    role?: string
    createdAt?: Date | string
    org: OrganizationCreateNestedOneWithoutMembersInput
  }

  export type OrgMemberUncheckedCreateWithoutUserInput = {
    id?: string
    role?: string
    orgId: string
    createdAt?: Date | string
  }

  export type OrgMemberCreateOrConnectWithoutUserInput = {
    where: OrgMemberWhereUniqueInput
    create: XOR<OrgMemberCreateWithoutUserInput, OrgMemberUncheckedCreateWithoutUserInput>
  }

  export type OrgMemberCreateManyUserInputEnvelope = {
    data: OrgMemberCreateManyUserInput | OrgMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type OrgMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: OrgMemberWhereUniqueInput
    update: XOR<OrgMemberUpdateWithoutUserInput, OrgMemberUncheckedUpdateWithoutUserInput>
    create: XOR<OrgMemberCreateWithoutUserInput, OrgMemberUncheckedCreateWithoutUserInput>
  }

  export type OrgMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: OrgMemberWhereUniqueInput
    data: XOR<OrgMemberUpdateWithoutUserInput, OrgMemberUncheckedUpdateWithoutUserInput>
  }

  export type OrgMemberUpdateManyWithWhereWithoutUserInput = {
    where: OrgMemberScalarWhereInput
    data: XOR<OrgMemberUpdateManyMutationInput, OrgMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type OrgMemberScalarWhereInput = {
    AND?: OrgMemberScalarWhereInput | OrgMemberScalarWhereInput[]
    OR?: OrgMemberScalarWhereInput[]
    NOT?: OrgMemberScalarWhereInput | OrgMemberScalarWhereInput[]
    id?: StringFilter<"OrgMember"> | string
    role?: StringFilter<"OrgMember"> | string
    userId?: StringFilter<"OrgMember"> | string
    orgId?: StringFilter<"OrgMember"> | string
    createdAt?: DateTimeFilter<"OrgMember"> | Date | string
  }

  export type OrgMemberCreateWithoutOrgInput = {
    id?: string
    role?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMembershipsInput
  }

  export type OrgMemberUncheckedCreateWithoutOrgInput = {
    id?: string
    role?: string
    userId: string
    createdAt?: Date | string
  }

  export type OrgMemberCreateOrConnectWithoutOrgInput = {
    where: OrgMemberWhereUniqueInput
    create: XOR<OrgMemberCreateWithoutOrgInput, OrgMemberUncheckedCreateWithoutOrgInput>
  }

  export type OrgMemberCreateManyOrgInputEnvelope = {
    data: OrgMemberCreateManyOrgInput | OrgMemberCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutOrgInput = {
    id?: string
    name: string
    slug: string
    timezone?: string
    statusPageEnabled?: boolean
    statusPageTitle?: string | null
    statusPageLogoUrl?: string | null
    customDomain?: string | null
    domainVerified?: boolean
    domainVerifyToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    checks?: CheckCreateNestedManyWithoutProjectInput
    channels?: ChannelCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyCreateNestedManyWithoutProjectInput
    incidents?: IncidentCreateNestedManyWithoutProjectInput
    maintenance?: MaintenanceCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutOrgInput = {
    id?: string
    name: string
    slug: string
    timezone?: string
    statusPageEnabled?: boolean
    statusPageTitle?: string | null
    statusPageLogoUrl?: string | null
    customDomain?: string | null
    domainVerified?: boolean
    domainVerifyToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    checks?: CheckUncheckedCreateNestedManyWithoutProjectInput
    channels?: ChannelUncheckedCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutProjectInput
    maintenance?: MaintenanceUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutOrgInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutOrgInput, ProjectUncheckedCreateWithoutOrgInput>
  }

  export type ProjectCreateManyOrgInputEnvelope = {
    data: ProjectCreateManyOrgInput | ProjectCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type InvitationCreateWithoutOrgInput = {
    id?: string
    email: string
    role?: string
    token: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type InvitationUncheckedCreateWithoutOrgInput = {
    id?: string
    email: string
    role?: string
    token: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type InvitationCreateOrConnectWithoutOrgInput = {
    where: InvitationWhereUniqueInput
    create: XOR<InvitationCreateWithoutOrgInput, InvitationUncheckedCreateWithoutOrgInput>
  }

  export type InvitationCreateManyOrgInputEnvelope = {
    data: InvitationCreateManyOrgInput | InvitationCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type OrgMemberUpsertWithWhereUniqueWithoutOrgInput = {
    where: OrgMemberWhereUniqueInput
    update: XOR<OrgMemberUpdateWithoutOrgInput, OrgMemberUncheckedUpdateWithoutOrgInput>
    create: XOR<OrgMemberCreateWithoutOrgInput, OrgMemberUncheckedCreateWithoutOrgInput>
  }

  export type OrgMemberUpdateWithWhereUniqueWithoutOrgInput = {
    where: OrgMemberWhereUniqueInput
    data: XOR<OrgMemberUpdateWithoutOrgInput, OrgMemberUncheckedUpdateWithoutOrgInput>
  }

  export type OrgMemberUpdateManyWithWhereWithoutOrgInput = {
    where: OrgMemberScalarWhereInput
    data: XOR<OrgMemberUpdateManyMutationInput, OrgMemberUncheckedUpdateManyWithoutOrgInput>
  }

  export type ProjectUpsertWithWhereUniqueWithoutOrgInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutOrgInput, ProjectUncheckedUpdateWithoutOrgInput>
    create: XOR<ProjectCreateWithoutOrgInput, ProjectUncheckedCreateWithoutOrgInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutOrgInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutOrgInput, ProjectUncheckedUpdateWithoutOrgInput>
  }

  export type ProjectUpdateManyWithWhereWithoutOrgInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutOrgInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    orgId?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    slug?: StringFilter<"Project"> | string
    timezone?: StringFilter<"Project"> | string
    statusPageEnabled?: BoolFilter<"Project"> | boolean
    statusPageTitle?: StringNullableFilter<"Project"> | string | null
    statusPageLogoUrl?: StringNullableFilter<"Project"> | string | null
    customDomain?: StringNullableFilter<"Project"> | string | null
    domainVerified?: BoolFilter<"Project"> | boolean
    domainVerifyToken?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
  }

  export type InvitationUpsertWithWhereUniqueWithoutOrgInput = {
    where: InvitationWhereUniqueInput
    update: XOR<InvitationUpdateWithoutOrgInput, InvitationUncheckedUpdateWithoutOrgInput>
    create: XOR<InvitationCreateWithoutOrgInput, InvitationUncheckedCreateWithoutOrgInput>
  }

  export type InvitationUpdateWithWhereUniqueWithoutOrgInput = {
    where: InvitationWhereUniqueInput
    data: XOR<InvitationUpdateWithoutOrgInput, InvitationUncheckedUpdateWithoutOrgInput>
  }

  export type InvitationUpdateManyWithWhereWithoutOrgInput = {
    where: InvitationScalarWhereInput
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyWithoutOrgInput>
  }

  export type InvitationScalarWhereInput = {
    AND?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
    OR?: InvitationScalarWhereInput[]
    NOT?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
    id?: StringFilter<"Invitation"> | string
    email?: StringFilter<"Invitation"> | string
    orgId?: StringFilter<"Invitation"> | string
    role?: StringFilter<"Invitation"> | string
    token?: StringFilter<"Invitation"> | string
    expiresAt?: DateTimeFilter<"Invitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"Invitation"> | Date | string | null
    createdAt?: DateTimeFilter<"Invitation"> | Date | string
  }

  export type UserCreateWithoutMembershipsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMembershipsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
  }

  export type OrganizationCreateWithoutMembersInput = {
    id?: string
    name: string
    slug: string
    plan?: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    trialEndsAt?: Date | string | null
    autoCreateIncidents?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutOrgInput
    invitations?: InvitationCreateNestedManyWithoutOrgInput
  }

  export type OrganizationUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    slug: string
    plan?: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    trialEndsAt?: Date | string | null
    autoCreateIncidents?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutOrgInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrganizationCreateOrConnectWithoutMembersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
  }

  export type UserUpsertWithoutMembershipsInput = {
    update: XOR<UserUpdateWithoutMembershipsInput, UserUncheckedUpdateWithoutMembershipsInput>
    create: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMembershipsInput, UserUncheckedUpdateWithoutMembershipsInput>
  }

  export type UserUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationUpsertWithoutMembersInput = {
    update: XOR<OrganizationUpdateWithoutMembersInput, OrganizationUncheckedUpdateWithoutMembersInput>
    create: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutMembersInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutMembersInput, OrganizationUncheckedUpdateWithoutMembersInput>
  }

  export type OrganizationUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoCreateIncidents?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutOrgNestedInput
    invitations?: InvitationUpdateManyWithoutOrgNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoCreateIncidents?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutOrgNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type OrganizationCreateWithoutInvitationsInput = {
    id?: string
    name: string
    slug: string
    plan?: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    trialEndsAt?: Date | string | null
    autoCreateIncidents?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: OrgMemberCreateNestedManyWithoutOrgInput
    projects?: ProjectCreateNestedManyWithoutOrgInput
  }

  export type OrganizationUncheckedCreateWithoutInvitationsInput = {
    id?: string
    name: string
    slug: string
    plan?: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    trialEndsAt?: Date | string | null
    autoCreateIncidents?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: OrgMemberUncheckedCreateNestedManyWithoutOrgInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrganizationCreateOrConnectWithoutInvitationsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutInvitationsInput, OrganizationUncheckedCreateWithoutInvitationsInput>
  }

  export type OrganizationUpsertWithoutInvitationsInput = {
    update: XOR<OrganizationUpdateWithoutInvitationsInput, OrganizationUncheckedUpdateWithoutInvitationsInput>
    create: XOR<OrganizationCreateWithoutInvitationsInput, OrganizationUncheckedCreateWithoutInvitationsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutInvitationsInput, OrganizationUncheckedUpdateWithoutInvitationsInput>
  }

  export type OrganizationUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoCreateIncidents?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: OrgMemberUpdateManyWithoutOrgNestedInput
    projects?: ProjectUpdateManyWithoutOrgNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoCreateIncidents?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: OrgMemberUncheckedUpdateManyWithoutOrgNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    memberships?: OrgMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    memberships?: OrgMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    memberships?: OrgMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    memberships?: OrgMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    memberships?: OrgMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    memberships?: OrgMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    memberships?: OrgMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    memberships?: OrgMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationCreateWithoutProjectsInput = {
    id?: string
    name: string
    slug: string
    plan?: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    trialEndsAt?: Date | string | null
    autoCreateIncidents?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: OrgMemberCreateNestedManyWithoutOrgInput
    invitations?: InvitationCreateNestedManyWithoutOrgInput
  }

  export type OrganizationUncheckedCreateWithoutProjectsInput = {
    id?: string
    name: string
    slug: string
    plan?: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    trialEndsAt?: Date | string | null
    autoCreateIncidents?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: OrgMemberUncheckedCreateNestedManyWithoutOrgInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrganizationCreateOrConnectWithoutProjectsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutProjectsInput, OrganizationUncheckedCreateWithoutProjectsInput>
  }

  export type CheckCreateWithoutProjectInput = {
    id?: string
    name: string
    slug?: string | null
    scheduleType: $Enums.ScheduleType
    scheduleValue: string
    graceSeconds?: number
    timezone?: string | null
    status?: $Enums.CheckStatus
    lastPingAt?: Date | string | null
    lastStartedAt?: Date | string | null
    nextExpectedAt?: Date | string | null
    lastAlertAt?: Date | string | null
    alertOnRecovery?: boolean
    reminderIntervalHours?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pings?: PingCreateNestedManyWithoutCheckInput
    checkChannels?: CheckChannelCreateNestedManyWithoutCheckInput
    alerts?: AlertCreateNestedManyWithoutCheckInput
    incidentChecks?: IncidentCheckCreateNestedManyWithoutCheckInput
    maintenanceChecks?: MaintenanceCheckCreateNestedManyWithoutCheckInput
    dailyStats?: CheckDailyStatCreateNestedManyWithoutCheckInput
  }

  export type CheckUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    slug?: string | null
    scheduleType: $Enums.ScheduleType
    scheduleValue: string
    graceSeconds?: number
    timezone?: string | null
    status?: $Enums.CheckStatus
    lastPingAt?: Date | string | null
    lastStartedAt?: Date | string | null
    nextExpectedAt?: Date | string | null
    lastAlertAt?: Date | string | null
    alertOnRecovery?: boolean
    reminderIntervalHours?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pings?: PingUncheckedCreateNestedManyWithoutCheckInput
    checkChannels?: CheckChannelUncheckedCreateNestedManyWithoutCheckInput
    alerts?: AlertUncheckedCreateNestedManyWithoutCheckInput
    incidentChecks?: IncidentCheckUncheckedCreateNestedManyWithoutCheckInput
    maintenanceChecks?: MaintenanceCheckUncheckedCreateNestedManyWithoutCheckInput
    dailyStats?: CheckDailyStatUncheckedCreateNestedManyWithoutCheckInput
  }

  export type CheckCreateOrConnectWithoutProjectInput = {
    where: CheckWhereUniqueInput
    create: XOR<CheckCreateWithoutProjectInput, CheckUncheckedCreateWithoutProjectInput>
  }

  export type CheckCreateManyProjectInputEnvelope = {
    data: CheckCreateManyProjectInput | CheckCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ChannelCreateWithoutProjectInput = {
    id?: string
    type: $Enums.ChannelType
    name: string
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    checkChannels?: CheckChannelCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateWithoutProjectInput = {
    id?: string
    type: $Enums.ChannelType
    name: string
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    checkChannels?: CheckChannelUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelCreateOrConnectWithoutProjectInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutProjectInput, ChannelUncheckedCreateWithoutProjectInput>
  }

  export type ChannelCreateManyProjectInputEnvelope = {
    data: ChannelCreateManyProjectInput | ChannelCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ApiKeyCreateWithoutProjectInput = {
    id?: string
    name: string
    keyHash: string
    keyPrefix: string
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ApiKeyUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    keyHash: string
    keyPrefix: string
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ApiKeyCreateOrConnectWithoutProjectInput = {
    where: ApiKeyWhereUniqueInput
    create: XOR<ApiKeyCreateWithoutProjectInput, ApiKeyUncheckedCreateWithoutProjectInput>
  }

  export type ApiKeyCreateManyProjectInputEnvelope = {
    data: ApiKeyCreateManyProjectInput | ApiKeyCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type IncidentCreateWithoutProjectInput = {
    id?: string
    title: string
    status?: $Enums.IncidentStatus
    impact?: $Enums.IncidentImpact
    autoCreated?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updates?: IncidentUpdateCreateNestedManyWithoutIncidentInput
    checks?: IncidentCheckCreateNestedManyWithoutIncidentInput
  }

  export type IncidentUncheckedCreateWithoutProjectInput = {
    id?: string
    title: string
    status?: $Enums.IncidentStatus
    impact?: $Enums.IncidentImpact
    autoCreated?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updates?: IncidentUpdateUncheckedCreateNestedManyWithoutIncidentInput
    checks?: IncidentCheckUncheckedCreateNestedManyWithoutIncidentInput
  }

  export type IncidentCreateOrConnectWithoutProjectInput = {
    where: IncidentWhereUniqueInput
    create: XOR<IncidentCreateWithoutProjectInput, IncidentUncheckedCreateWithoutProjectInput>
  }

  export type IncidentCreateManyProjectInputEnvelope = {
    data: IncidentCreateManyProjectInput | IncidentCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type MaintenanceCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    startsAt: Date | string
    endsAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    checks?: MaintenanceCheckCreateNestedManyWithoutMaintenanceInput
  }

  export type MaintenanceUncheckedCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    startsAt: Date | string
    endsAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    checks?: MaintenanceCheckUncheckedCreateNestedManyWithoutMaintenanceInput
  }

  export type MaintenanceCreateOrConnectWithoutProjectInput = {
    where: MaintenanceWhereUniqueInput
    create: XOR<MaintenanceCreateWithoutProjectInput, MaintenanceUncheckedCreateWithoutProjectInput>
  }

  export type MaintenanceCreateManyProjectInputEnvelope = {
    data: MaintenanceCreateManyProjectInput | MaintenanceCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutProjectsInput = {
    update: XOR<OrganizationUpdateWithoutProjectsInput, OrganizationUncheckedUpdateWithoutProjectsInput>
    create: XOR<OrganizationCreateWithoutProjectsInput, OrganizationUncheckedCreateWithoutProjectsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutProjectsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutProjectsInput, OrganizationUncheckedUpdateWithoutProjectsInput>
  }

  export type OrganizationUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoCreateIncidents?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: OrgMemberUpdateManyWithoutOrgNestedInput
    invitations?: InvitationUpdateManyWithoutOrgNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoCreateIncidents?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: OrgMemberUncheckedUpdateManyWithoutOrgNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type CheckUpsertWithWhereUniqueWithoutProjectInput = {
    where: CheckWhereUniqueInput
    update: XOR<CheckUpdateWithoutProjectInput, CheckUncheckedUpdateWithoutProjectInput>
    create: XOR<CheckCreateWithoutProjectInput, CheckUncheckedCreateWithoutProjectInput>
  }

  export type CheckUpdateWithWhereUniqueWithoutProjectInput = {
    where: CheckWhereUniqueInput
    data: XOR<CheckUpdateWithoutProjectInput, CheckUncheckedUpdateWithoutProjectInput>
  }

  export type CheckUpdateManyWithWhereWithoutProjectInput = {
    where: CheckScalarWhereInput
    data: XOR<CheckUpdateManyMutationInput, CheckUncheckedUpdateManyWithoutProjectInput>
  }

  export type CheckScalarWhereInput = {
    AND?: CheckScalarWhereInput | CheckScalarWhereInput[]
    OR?: CheckScalarWhereInput[]
    NOT?: CheckScalarWhereInput | CheckScalarWhereInput[]
    id?: StringFilter<"Check"> | string
    projectId?: StringFilter<"Check"> | string
    name?: StringFilter<"Check"> | string
    slug?: StringNullableFilter<"Check"> | string | null
    scheduleType?: EnumScheduleTypeFilter<"Check"> | $Enums.ScheduleType
    scheduleValue?: StringFilter<"Check"> | string
    graceSeconds?: IntFilter<"Check"> | number
    timezone?: StringNullableFilter<"Check"> | string | null
    status?: EnumCheckStatusFilter<"Check"> | $Enums.CheckStatus
    lastPingAt?: DateTimeNullableFilter<"Check"> | Date | string | null
    lastStartedAt?: DateTimeNullableFilter<"Check"> | Date | string | null
    nextExpectedAt?: DateTimeNullableFilter<"Check"> | Date | string | null
    lastAlertAt?: DateTimeNullableFilter<"Check"> | Date | string | null
    alertOnRecovery?: BoolFilter<"Check"> | boolean
    reminderIntervalHours?: IntNullableFilter<"Check"> | number | null
    createdAt?: DateTimeFilter<"Check"> | Date | string
    updatedAt?: DateTimeFilter<"Check"> | Date | string
  }

  export type ChannelUpsertWithWhereUniqueWithoutProjectInput = {
    where: ChannelWhereUniqueInput
    update: XOR<ChannelUpdateWithoutProjectInput, ChannelUncheckedUpdateWithoutProjectInput>
    create: XOR<ChannelCreateWithoutProjectInput, ChannelUncheckedCreateWithoutProjectInput>
  }

  export type ChannelUpdateWithWhereUniqueWithoutProjectInput = {
    where: ChannelWhereUniqueInput
    data: XOR<ChannelUpdateWithoutProjectInput, ChannelUncheckedUpdateWithoutProjectInput>
  }

  export type ChannelUpdateManyWithWhereWithoutProjectInput = {
    where: ChannelScalarWhereInput
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyWithoutProjectInput>
  }

  export type ChannelScalarWhereInput = {
    AND?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
    OR?: ChannelScalarWhereInput[]
    NOT?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
    id?: StringFilter<"Channel"> | string
    projectId?: StringFilter<"Channel"> | string
    type?: EnumChannelTypeFilter<"Channel"> | $Enums.ChannelType
    name?: StringFilter<"Channel"> | string
    config?: JsonFilter<"Channel">
    createdAt?: DateTimeFilter<"Channel"> | Date | string
    updatedAt?: DateTimeFilter<"Channel"> | Date | string
  }

  export type ApiKeyUpsertWithWhereUniqueWithoutProjectInput = {
    where: ApiKeyWhereUniqueInput
    update: XOR<ApiKeyUpdateWithoutProjectInput, ApiKeyUncheckedUpdateWithoutProjectInput>
    create: XOR<ApiKeyCreateWithoutProjectInput, ApiKeyUncheckedCreateWithoutProjectInput>
  }

  export type ApiKeyUpdateWithWhereUniqueWithoutProjectInput = {
    where: ApiKeyWhereUniqueInput
    data: XOR<ApiKeyUpdateWithoutProjectInput, ApiKeyUncheckedUpdateWithoutProjectInput>
  }

  export type ApiKeyUpdateManyWithWhereWithoutProjectInput = {
    where: ApiKeyScalarWhereInput
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyWithoutProjectInput>
  }

  export type ApiKeyScalarWhereInput = {
    AND?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    OR?: ApiKeyScalarWhereInput[]
    NOT?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    projectId?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    keyHash?: StringFilter<"ApiKey"> | string
    keyPrefix?: StringFilter<"ApiKey"> | string
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
  }

  export type IncidentUpsertWithWhereUniqueWithoutProjectInput = {
    where: IncidentWhereUniqueInput
    update: XOR<IncidentUpdateWithoutProjectInput, IncidentUncheckedUpdateWithoutProjectInput>
    create: XOR<IncidentCreateWithoutProjectInput, IncidentUncheckedCreateWithoutProjectInput>
  }

  export type IncidentUpdateWithWhereUniqueWithoutProjectInput = {
    where: IncidentWhereUniqueInput
    data: XOR<IncidentUpdateWithoutProjectInput, IncidentUncheckedUpdateWithoutProjectInput>
  }

  export type IncidentUpdateManyWithWhereWithoutProjectInput = {
    where: IncidentScalarWhereInput
    data: XOR<IncidentUpdateManyMutationInput, IncidentUncheckedUpdateManyWithoutProjectInput>
  }

  export type IncidentScalarWhereInput = {
    AND?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
    OR?: IncidentScalarWhereInput[]
    NOT?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
    id?: StringFilter<"Incident"> | string
    projectId?: StringFilter<"Incident"> | string
    title?: StringFilter<"Incident"> | string
    status?: EnumIncidentStatusFilter<"Incident"> | $Enums.IncidentStatus
    impact?: EnumIncidentImpactFilter<"Incident"> | $Enums.IncidentImpact
    autoCreated?: BoolFilter<"Incident"> | boolean
    resolvedAt?: DateTimeNullableFilter<"Incident"> | Date | string | null
    createdAt?: DateTimeFilter<"Incident"> | Date | string
    updatedAt?: DateTimeFilter<"Incident"> | Date | string
  }

  export type MaintenanceUpsertWithWhereUniqueWithoutProjectInput = {
    where: MaintenanceWhereUniqueInput
    update: XOR<MaintenanceUpdateWithoutProjectInput, MaintenanceUncheckedUpdateWithoutProjectInput>
    create: XOR<MaintenanceCreateWithoutProjectInput, MaintenanceUncheckedCreateWithoutProjectInput>
  }

  export type MaintenanceUpdateWithWhereUniqueWithoutProjectInput = {
    where: MaintenanceWhereUniqueInput
    data: XOR<MaintenanceUpdateWithoutProjectInput, MaintenanceUncheckedUpdateWithoutProjectInput>
  }

  export type MaintenanceUpdateManyWithWhereWithoutProjectInput = {
    where: MaintenanceScalarWhereInput
    data: XOR<MaintenanceUpdateManyMutationInput, MaintenanceUncheckedUpdateManyWithoutProjectInput>
  }

  export type MaintenanceScalarWhereInput = {
    AND?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
    OR?: MaintenanceScalarWhereInput[]
    NOT?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
    id?: StringFilter<"Maintenance"> | string
    projectId?: StringFilter<"Maintenance"> | string
    title?: StringFilter<"Maintenance"> | string
    description?: StringNullableFilter<"Maintenance"> | string | null
    startsAt?: DateTimeFilter<"Maintenance"> | Date | string
    endsAt?: DateTimeFilter<"Maintenance"> | Date | string
    createdAt?: DateTimeFilter<"Maintenance"> | Date | string
    updatedAt?: DateTimeFilter<"Maintenance"> | Date | string
  }

  export type ProjectCreateWithoutChecksInput = {
    id?: string
    name: string
    slug: string
    timezone?: string
    statusPageEnabled?: boolean
    statusPageTitle?: string | null
    statusPageLogoUrl?: string | null
    customDomain?: string | null
    domainVerified?: boolean
    domainVerifyToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    org: OrganizationCreateNestedOneWithoutProjectsInput
    channels?: ChannelCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyCreateNestedManyWithoutProjectInput
    incidents?: IncidentCreateNestedManyWithoutProjectInput
    maintenance?: MaintenanceCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutChecksInput = {
    id?: string
    orgId: string
    name: string
    slug: string
    timezone?: string
    statusPageEnabled?: boolean
    statusPageTitle?: string | null
    statusPageLogoUrl?: string | null
    customDomain?: string | null
    domainVerified?: boolean
    domainVerifyToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    channels?: ChannelUncheckedCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutProjectInput
    maintenance?: MaintenanceUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutChecksInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutChecksInput, ProjectUncheckedCreateWithoutChecksInput>
  }

  export type PingCreateWithoutCheckInput = {
    id?: string
    type: $Enums.PingType
    body?: string | null
    sourceIp: string
    createdAt?: Date | string
  }

  export type PingUncheckedCreateWithoutCheckInput = {
    id?: string
    type: $Enums.PingType
    body?: string | null
    sourceIp: string
    createdAt?: Date | string
  }

  export type PingCreateOrConnectWithoutCheckInput = {
    where: PingWhereUniqueInput
    create: XOR<PingCreateWithoutCheckInput, PingUncheckedCreateWithoutCheckInput>
  }

  export type PingCreateManyCheckInputEnvelope = {
    data: PingCreateManyCheckInput | PingCreateManyCheckInput[]
    skipDuplicates?: boolean
  }

  export type CheckChannelCreateWithoutCheckInput = {
    channel: ChannelCreateNestedOneWithoutCheckChannelsInput
  }

  export type CheckChannelUncheckedCreateWithoutCheckInput = {
    channelId: string
  }

  export type CheckChannelCreateOrConnectWithoutCheckInput = {
    where: CheckChannelWhereUniqueInput
    create: XOR<CheckChannelCreateWithoutCheckInput, CheckChannelUncheckedCreateWithoutCheckInput>
  }

  export type CheckChannelCreateManyCheckInputEnvelope = {
    data: CheckChannelCreateManyCheckInput | CheckChannelCreateManyCheckInput[]
    skipDuplicates?: boolean
  }

  export type AlertCreateWithoutCheckInput = {
    id?: string
    event: string
    channels: JsonNullValueInput | InputJsonValue
    success: boolean
    error?: string | null
    createdAt?: Date | string
  }

  export type AlertUncheckedCreateWithoutCheckInput = {
    id?: string
    event: string
    channels: JsonNullValueInput | InputJsonValue
    success: boolean
    error?: string | null
    createdAt?: Date | string
  }

  export type AlertCreateOrConnectWithoutCheckInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutCheckInput, AlertUncheckedCreateWithoutCheckInput>
  }

  export type AlertCreateManyCheckInputEnvelope = {
    data: AlertCreateManyCheckInput | AlertCreateManyCheckInput[]
    skipDuplicates?: boolean
  }

  export type IncidentCheckCreateWithoutCheckInput = {
    incident: IncidentCreateNestedOneWithoutChecksInput
  }

  export type IncidentCheckUncheckedCreateWithoutCheckInput = {
    incidentId: string
  }

  export type IncidentCheckCreateOrConnectWithoutCheckInput = {
    where: IncidentCheckWhereUniqueInput
    create: XOR<IncidentCheckCreateWithoutCheckInput, IncidentCheckUncheckedCreateWithoutCheckInput>
  }

  export type IncidentCheckCreateManyCheckInputEnvelope = {
    data: IncidentCheckCreateManyCheckInput | IncidentCheckCreateManyCheckInput[]
    skipDuplicates?: boolean
  }

  export type MaintenanceCheckCreateWithoutCheckInput = {
    maintenance: MaintenanceCreateNestedOneWithoutChecksInput
  }

  export type MaintenanceCheckUncheckedCreateWithoutCheckInput = {
    maintenanceId: string
  }

  export type MaintenanceCheckCreateOrConnectWithoutCheckInput = {
    where: MaintenanceCheckWhereUniqueInput
    create: XOR<MaintenanceCheckCreateWithoutCheckInput, MaintenanceCheckUncheckedCreateWithoutCheckInput>
  }

  export type MaintenanceCheckCreateManyCheckInputEnvelope = {
    data: MaintenanceCheckCreateManyCheckInput | MaintenanceCheckCreateManyCheckInput[]
    skipDuplicates?: boolean
  }

  export type CheckDailyStatCreateWithoutCheckInput = {
    id?: string
    date: Date | string
    upMinutes?: number
    downMinutes?: number
    totalPings?: number
    upPercent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CheckDailyStatUncheckedCreateWithoutCheckInput = {
    id?: string
    date: Date | string
    upMinutes?: number
    downMinutes?: number
    totalPings?: number
    upPercent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CheckDailyStatCreateOrConnectWithoutCheckInput = {
    where: CheckDailyStatWhereUniqueInput
    create: XOR<CheckDailyStatCreateWithoutCheckInput, CheckDailyStatUncheckedCreateWithoutCheckInput>
  }

  export type CheckDailyStatCreateManyCheckInputEnvelope = {
    data: CheckDailyStatCreateManyCheckInput | CheckDailyStatCreateManyCheckInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutChecksInput = {
    update: XOR<ProjectUpdateWithoutChecksInput, ProjectUncheckedUpdateWithoutChecksInput>
    create: XOR<ProjectCreateWithoutChecksInput, ProjectUncheckedCreateWithoutChecksInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutChecksInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutChecksInput, ProjectUncheckedUpdateWithoutChecksInput>
  }

  export type ProjectUpdateWithoutChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    statusPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    statusPageTitle?: NullableStringFieldUpdateOperationsInput | string | null
    statusPageLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    domainVerified?: BoolFieldUpdateOperationsInput | boolean
    domainVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    channels?: ChannelUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutProjectNestedInput
    incidents?: IncidentUpdateManyWithoutProjectNestedInput
    maintenance?: MaintenanceUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    statusPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    statusPageTitle?: NullableStringFieldUpdateOperationsInput | string | null
    statusPageLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    domainVerified?: BoolFieldUpdateOperationsInput | boolean
    domainVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channels?: ChannelUncheckedUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutProjectNestedInput
    maintenance?: MaintenanceUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type PingUpsertWithWhereUniqueWithoutCheckInput = {
    where: PingWhereUniqueInput
    update: XOR<PingUpdateWithoutCheckInput, PingUncheckedUpdateWithoutCheckInput>
    create: XOR<PingCreateWithoutCheckInput, PingUncheckedCreateWithoutCheckInput>
  }

  export type PingUpdateWithWhereUniqueWithoutCheckInput = {
    where: PingWhereUniqueInput
    data: XOR<PingUpdateWithoutCheckInput, PingUncheckedUpdateWithoutCheckInput>
  }

  export type PingUpdateManyWithWhereWithoutCheckInput = {
    where: PingScalarWhereInput
    data: XOR<PingUpdateManyMutationInput, PingUncheckedUpdateManyWithoutCheckInput>
  }

  export type PingScalarWhereInput = {
    AND?: PingScalarWhereInput | PingScalarWhereInput[]
    OR?: PingScalarWhereInput[]
    NOT?: PingScalarWhereInput | PingScalarWhereInput[]
    id?: StringFilter<"Ping"> | string
    checkId?: StringFilter<"Ping"> | string
    type?: EnumPingTypeFilter<"Ping"> | $Enums.PingType
    body?: StringNullableFilter<"Ping"> | string | null
    sourceIp?: StringFilter<"Ping"> | string
    createdAt?: DateTimeFilter<"Ping"> | Date | string
  }

  export type CheckChannelUpsertWithWhereUniqueWithoutCheckInput = {
    where: CheckChannelWhereUniqueInput
    update: XOR<CheckChannelUpdateWithoutCheckInput, CheckChannelUncheckedUpdateWithoutCheckInput>
    create: XOR<CheckChannelCreateWithoutCheckInput, CheckChannelUncheckedCreateWithoutCheckInput>
  }

  export type CheckChannelUpdateWithWhereUniqueWithoutCheckInput = {
    where: CheckChannelWhereUniqueInput
    data: XOR<CheckChannelUpdateWithoutCheckInput, CheckChannelUncheckedUpdateWithoutCheckInput>
  }

  export type CheckChannelUpdateManyWithWhereWithoutCheckInput = {
    where: CheckChannelScalarWhereInput
    data: XOR<CheckChannelUpdateManyMutationInput, CheckChannelUncheckedUpdateManyWithoutCheckInput>
  }

  export type CheckChannelScalarWhereInput = {
    AND?: CheckChannelScalarWhereInput | CheckChannelScalarWhereInput[]
    OR?: CheckChannelScalarWhereInput[]
    NOT?: CheckChannelScalarWhereInput | CheckChannelScalarWhereInput[]
    checkId?: StringFilter<"CheckChannel"> | string
    channelId?: StringFilter<"CheckChannel"> | string
  }

  export type AlertUpsertWithWhereUniqueWithoutCheckInput = {
    where: AlertWhereUniqueInput
    update: XOR<AlertUpdateWithoutCheckInput, AlertUncheckedUpdateWithoutCheckInput>
    create: XOR<AlertCreateWithoutCheckInput, AlertUncheckedCreateWithoutCheckInput>
  }

  export type AlertUpdateWithWhereUniqueWithoutCheckInput = {
    where: AlertWhereUniqueInput
    data: XOR<AlertUpdateWithoutCheckInput, AlertUncheckedUpdateWithoutCheckInput>
  }

  export type AlertUpdateManyWithWhereWithoutCheckInput = {
    where: AlertScalarWhereInput
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyWithoutCheckInput>
  }

  export type AlertScalarWhereInput = {
    AND?: AlertScalarWhereInput | AlertScalarWhereInput[]
    OR?: AlertScalarWhereInput[]
    NOT?: AlertScalarWhereInput | AlertScalarWhereInput[]
    id?: StringFilter<"Alert"> | string
    checkId?: StringFilter<"Alert"> | string
    event?: StringFilter<"Alert"> | string
    channels?: JsonFilter<"Alert">
    success?: BoolFilter<"Alert"> | boolean
    error?: StringNullableFilter<"Alert"> | string | null
    createdAt?: DateTimeFilter<"Alert"> | Date | string
  }

  export type IncidentCheckUpsertWithWhereUniqueWithoutCheckInput = {
    where: IncidentCheckWhereUniqueInput
    update: XOR<IncidentCheckUpdateWithoutCheckInput, IncidentCheckUncheckedUpdateWithoutCheckInput>
    create: XOR<IncidentCheckCreateWithoutCheckInput, IncidentCheckUncheckedCreateWithoutCheckInput>
  }

  export type IncidentCheckUpdateWithWhereUniqueWithoutCheckInput = {
    where: IncidentCheckWhereUniqueInput
    data: XOR<IncidentCheckUpdateWithoutCheckInput, IncidentCheckUncheckedUpdateWithoutCheckInput>
  }

  export type IncidentCheckUpdateManyWithWhereWithoutCheckInput = {
    where: IncidentCheckScalarWhereInput
    data: XOR<IncidentCheckUpdateManyMutationInput, IncidentCheckUncheckedUpdateManyWithoutCheckInput>
  }

  export type IncidentCheckScalarWhereInput = {
    AND?: IncidentCheckScalarWhereInput | IncidentCheckScalarWhereInput[]
    OR?: IncidentCheckScalarWhereInput[]
    NOT?: IncidentCheckScalarWhereInput | IncidentCheckScalarWhereInput[]
    incidentId?: StringFilter<"IncidentCheck"> | string
    checkId?: StringFilter<"IncidentCheck"> | string
  }

  export type MaintenanceCheckUpsertWithWhereUniqueWithoutCheckInput = {
    where: MaintenanceCheckWhereUniqueInput
    update: XOR<MaintenanceCheckUpdateWithoutCheckInput, MaintenanceCheckUncheckedUpdateWithoutCheckInput>
    create: XOR<MaintenanceCheckCreateWithoutCheckInput, MaintenanceCheckUncheckedCreateWithoutCheckInput>
  }

  export type MaintenanceCheckUpdateWithWhereUniqueWithoutCheckInput = {
    where: MaintenanceCheckWhereUniqueInput
    data: XOR<MaintenanceCheckUpdateWithoutCheckInput, MaintenanceCheckUncheckedUpdateWithoutCheckInput>
  }

  export type MaintenanceCheckUpdateManyWithWhereWithoutCheckInput = {
    where: MaintenanceCheckScalarWhereInput
    data: XOR<MaintenanceCheckUpdateManyMutationInput, MaintenanceCheckUncheckedUpdateManyWithoutCheckInput>
  }

  export type MaintenanceCheckScalarWhereInput = {
    AND?: MaintenanceCheckScalarWhereInput | MaintenanceCheckScalarWhereInput[]
    OR?: MaintenanceCheckScalarWhereInput[]
    NOT?: MaintenanceCheckScalarWhereInput | MaintenanceCheckScalarWhereInput[]
    maintenanceId?: StringFilter<"MaintenanceCheck"> | string
    checkId?: StringFilter<"MaintenanceCheck"> | string
  }

  export type CheckDailyStatUpsertWithWhereUniqueWithoutCheckInput = {
    where: CheckDailyStatWhereUniqueInput
    update: XOR<CheckDailyStatUpdateWithoutCheckInput, CheckDailyStatUncheckedUpdateWithoutCheckInput>
    create: XOR<CheckDailyStatCreateWithoutCheckInput, CheckDailyStatUncheckedCreateWithoutCheckInput>
  }

  export type CheckDailyStatUpdateWithWhereUniqueWithoutCheckInput = {
    where: CheckDailyStatWhereUniqueInput
    data: XOR<CheckDailyStatUpdateWithoutCheckInput, CheckDailyStatUncheckedUpdateWithoutCheckInput>
  }

  export type CheckDailyStatUpdateManyWithWhereWithoutCheckInput = {
    where: CheckDailyStatScalarWhereInput
    data: XOR<CheckDailyStatUpdateManyMutationInput, CheckDailyStatUncheckedUpdateManyWithoutCheckInput>
  }

  export type CheckDailyStatScalarWhereInput = {
    AND?: CheckDailyStatScalarWhereInput | CheckDailyStatScalarWhereInput[]
    OR?: CheckDailyStatScalarWhereInput[]
    NOT?: CheckDailyStatScalarWhereInput | CheckDailyStatScalarWhereInput[]
    id?: StringFilter<"CheckDailyStat"> | string
    checkId?: StringFilter<"CheckDailyStat"> | string
    date?: DateTimeFilter<"CheckDailyStat"> | Date | string
    upMinutes?: IntFilter<"CheckDailyStat"> | number
    downMinutes?: IntFilter<"CheckDailyStat"> | number
    totalPings?: IntFilter<"CheckDailyStat"> | number
    upPercent?: FloatFilter<"CheckDailyStat"> | number
    createdAt?: DateTimeFilter<"CheckDailyStat"> | Date | string
    updatedAt?: DateTimeFilter<"CheckDailyStat"> | Date | string
  }

  export type CheckCreateWithoutPingsInput = {
    id?: string
    name: string
    slug?: string | null
    scheduleType: $Enums.ScheduleType
    scheduleValue: string
    graceSeconds?: number
    timezone?: string | null
    status?: $Enums.CheckStatus
    lastPingAt?: Date | string | null
    lastStartedAt?: Date | string | null
    nextExpectedAt?: Date | string | null
    lastAlertAt?: Date | string | null
    alertOnRecovery?: boolean
    reminderIntervalHours?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutChecksInput
    checkChannels?: CheckChannelCreateNestedManyWithoutCheckInput
    alerts?: AlertCreateNestedManyWithoutCheckInput
    incidentChecks?: IncidentCheckCreateNestedManyWithoutCheckInput
    maintenanceChecks?: MaintenanceCheckCreateNestedManyWithoutCheckInput
    dailyStats?: CheckDailyStatCreateNestedManyWithoutCheckInput
  }

  export type CheckUncheckedCreateWithoutPingsInput = {
    id?: string
    projectId: string
    name: string
    slug?: string | null
    scheduleType: $Enums.ScheduleType
    scheduleValue: string
    graceSeconds?: number
    timezone?: string | null
    status?: $Enums.CheckStatus
    lastPingAt?: Date | string | null
    lastStartedAt?: Date | string | null
    nextExpectedAt?: Date | string | null
    lastAlertAt?: Date | string | null
    alertOnRecovery?: boolean
    reminderIntervalHours?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    checkChannels?: CheckChannelUncheckedCreateNestedManyWithoutCheckInput
    alerts?: AlertUncheckedCreateNestedManyWithoutCheckInput
    incidentChecks?: IncidentCheckUncheckedCreateNestedManyWithoutCheckInput
    maintenanceChecks?: MaintenanceCheckUncheckedCreateNestedManyWithoutCheckInput
    dailyStats?: CheckDailyStatUncheckedCreateNestedManyWithoutCheckInput
  }

  export type CheckCreateOrConnectWithoutPingsInput = {
    where: CheckWhereUniqueInput
    create: XOR<CheckCreateWithoutPingsInput, CheckUncheckedCreateWithoutPingsInput>
  }

  export type CheckUpsertWithoutPingsInput = {
    update: XOR<CheckUpdateWithoutPingsInput, CheckUncheckedUpdateWithoutPingsInput>
    create: XOR<CheckCreateWithoutPingsInput, CheckUncheckedCreateWithoutPingsInput>
    where?: CheckWhereInput
  }

  export type CheckUpdateToOneWithWhereWithoutPingsInput = {
    where?: CheckWhereInput
    data: XOR<CheckUpdateWithoutPingsInput, CheckUncheckedUpdateWithoutPingsInput>
  }

  export type CheckUpdateWithoutPingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumScheduleTypeFieldUpdateOperationsInput | $Enums.ScheduleType
    scheduleValue?: StringFieldUpdateOperationsInput | string
    graceSeconds?: IntFieldUpdateOperationsInput | number
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCheckStatusFieldUpdateOperationsInput | $Enums.CheckStatus
    lastPingAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExpectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertOnRecovery?: BoolFieldUpdateOperationsInput | boolean
    reminderIntervalHours?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutChecksNestedInput
    checkChannels?: CheckChannelUpdateManyWithoutCheckNestedInput
    alerts?: AlertUpdateManyWithoutCheckNestedInput
    incidentChecks?: IncidentCheckUpdateManyWithoutCheckNestedInput
    maintenanceChecks?: MaintenanceCheckUpdateManyWithoutCheckNestedInput
    dailyStats?: CheckDailyStatUpdateManyWithoutCheckNestedInput
  }

  export type CheckUncheckedUpdateWithoutPingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumScheduleTypeFieldUpdateOperationsInput | $Enums.ScheduleType
    scheduleValue?: StringFieldUpdateOperationsInput | string
    graceSeconds?: IntFieldUpdateOperationsInput | number
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCheckStatusFieldUpdateOperationsInput | $Enums.CheckStatus
    lastPingAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExpectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertOnRecovery?: BoolFieldUpdateOperationsInput | boolean
    reminderIntervalHours?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkChannels?: CheckChannelUncheckedUpdateManyWithoutCheckNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutCheckNestedInput
    incidentChecks?: IncidentCheckUncheckedUpdateManyWithoutCheckNestedInput
    maintenanceChecks?: MaintenanceCheckUncheckedUpdateManyWithoutCheckNestedInput
    dailyStats?: CheckDailyStatUncheckedUpdateManyWithoutCheckNestedInput
  }

  export type CheckCreateWithoutDailyStatsInput = {
    id?: string
    name: string
    slug?: string | null
    scheduleType: $Enums.ScheduleType
    scheduleValue: string
    graceSeconds?: number
    timezone?: string | null
    status?: $Enums.CheckStatus
    lastPingAt?: Date | string | null
    lastStartedAt?: Date | string | null
    nextExpectedAt?: Date | string | null
    lastAlertAt?: Date | string | null
    alertOnRecovery?: boolean
    reminderIntervalHours?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutChecksInput
    pings?: PingCreateNestedManyWithoutCheckInput
    checkChannels?: CheckChannelCreateNestedManyWithoutCheckInput
    alerts?: AlertCreateNestedManyWithoutCheckInput
    incidentChecks?: IncidentCheckCreateNestedManyWithoutCheckInput
    maintenanceChecks?: MaintenanceCheckCreateNestedManyWithoutCheckInput
  }

  export type CheckUncheckedCreateWithoutDailyStatsInput = {
    id?: string
    projectId: string
    name: string
    slug?: string | null
    scheduleType: $Enums.ScheduleType
    scheduleValue: string
    graceSeconds?: number
    timezone?: string | null
    status?: $Enums.CheckStatus
    lastPingAt?: Date | string | null
    lastStartedAt?: Date | string | null
    nextExpectedAt?: Date | string | null
    lastAlertAt?: Date | string | null
    alertOnRecovery?: boolean
    reminderIntervalHours?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pings?: PingUncheckedCreateNestedManyWithoutCheckInput
    checkChannels?: CheckChannelUncheckedCreateNestedManyWithoutCheckInput
    alerts?: AlertUncheckedCreateNestedManyWithoutCheckInput
    incidentChecks?: IncidentCheckUncheckedCreateNestedManyWithoutCheckInput
    maintenanceChecks?: MaintenanceCheckUncheckedCreateNestedManyWithoutCheckInput
  }

  export type CheckCreateOrConnectWithoutDailyStatsInput = {
    where: CheckWhereUniqueInput
    create: XOR<CheckCreateWithoutDailyStatsInput, CheckUncheckedCreateWithoutDailyStatsInput>
  }

  export type CheckUpsertWithoutDailyStatsInput = {
    update: XOR<CheckUpdateWithoutDailyStatsInput, CheckUncheckedUpdateWithoutDailyStatsInput>
    create: XOR<CheckCreateWithoutDailyStatsInput, CheckUncheckedCreateWithoutDailyStatsInput>
    where?: CheckWhereInput
  }

  export type CheckUpdateToOneWithWhereWithoutDailyStatsInput = {
    where?: CheckWhereInput
    data: XOR<CheckUpdateWithoutDailyStatsInput, CheckUncheckedUpdateWithoutDailyStatsInput>
  }

  export type CheckUpdateWithoutDailyStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumScheduleTypeFieldUpdateOperationsInput | $Enums.ScheduleType
    scheduleValue?: StringFieldUpdateOperationsInput | string
    graceSeconds?: IntFieldUpdateOperationsInput | number
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCheckStatusFieldUpdateOperationsInput | $Enums.CheckStatus
    lastPingAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExpectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertOnRecovery?: BoolFieldUpdateOperationsInput | boolean
    reminderIntervalHours?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutChecksNestedInput
    pings?: PingUpdateManyWithoutCheckNestedInput
    checkChannels?: CheckChannelUpdateManyWithoutCheckNestedInput
    alerts?: AlertUpdateManyWithoutCheckNestedInput
    incidentChecks?: IncidentCheckUpdateManyWithoutCheckNestedInput
    maintenanceChecks?: MaintenanceCheckUpdateManyWithoutCheckNestedInput
  }

  export type CheckUncheckedUpdateWithoutDailyStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumScheduleTypeFieldUpdateOperationsInput | $Enums.ScheduleType
    scheduleValue?: StringFieldUpdateOperationsInput | string
    graceSeconds?: IntFieldUpdateOperationsInput | number
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCheckStatusFieldUpdateOperationsInput | $Enums.CheckStatus
    lastPingAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExpectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertOnRecovery?: BoolFieldUpdateOperationsInput | boolean
    reminderIntervalHours?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pings?: PingUncheckedUpdateManyWithoutCheckNestedInput
    checkChannels?: CheckChannelUncheckedUpdateManyWithoutCheckNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutCheckNestedInput
    incidentChecks?: IncidentCheckUncheckedUpdateManyWithoutCheckNestedInput
    maintenanceChecks?: MaintenanceCheckUncheckedUpdateManyWithoutCheckNestedInput
  }

  export type ProjectCreateWithoutChannelsInput = {
    id?: string
    name: string
    slug: string
    timezone?: string
    statusPageEnabled?: boolean
    statusPageTitle?: string | null
    statusPageLogoUrl?: string | null
    customDomain?: string | null
    domainVerified?: boolean
    domainVerifyToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    org: OrganizationCreateNestedOneWithoutProjectsInput
    checks?: CheckCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyCreateNestedManyWithoutProjectInput
    incidents?: IncidentCreateNestedManyWithoutProjectInput
    maintenance?: MaintenanceCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutChannelsInput = {
    id?: string
    orgId: string
    name: string
    slug: string
    timezone?: string
    statusPageEnabled?: boolean
    statusPageTitle?: string | null
    statusPageLogoUrl?: string | null
    customDomain?: string | null
    domainVerified?: boolean
    domainVerifyToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    checks?: CheckUncheckedCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutProjectInput
    maintenance?: MaintenanceUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutChannelsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutChannelsInput, ProjectUncheckedCreateWithoutChannelsInput>
  }

  export type CheckChannelCreateWithoutChannelInput = {
    check: CheckCreateNestedOneWithoutCheckChannelsInput
  }

  export type CheckChannelUncheckedCreateWithoutChannelInput = {
    checkId: string
  }

  export type CheckChannelCreateOrConnectWithoutChannelInput = {
    where: CheckChannelWhereUniqueInput
    create: XOR<CheckChannelCreateWithoutChannelInput, CheckChannelUncheckedCreateWithoutChannelInput>
  }

  export type CheckChannelCreateManyChannelInputEnvelope = {
    data: CheckChannelCreateManyChannelInput | CheckChannelCreateManyChannelInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutChannelsInput = {
    update: XOR<ProjectUpdateWithoutChannelsInput, ProjectUncheckedUpdateWithoutChannelsInput>
    create: XOR<ProjectCreateWithoutChannelsInput, ProjectUncheckedCreateWithoutChannelsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutChannelsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutChannelsInput, ProjectUncheckedUpdateWithoutChannelsInput>
  }

  export type ProjectUpdateWithoutChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    statusPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    statusPageTitle?: NullableStringFieldUpdateOperationsInput | string | null
    statusPageLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    domainVerified?: BoolFieldUpdateOperationsInput | boolean
    domainVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    checks?: CheckUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutProjectNestedInput
    incidents?: IncidentUpdateManyWithoutProjectNestedInput
    maintenance?: MaintenanceUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    statusPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    statusPageTitle?: NullableStringFieldUpdateOperationsInput | string | null
    statusPageLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    domainVerified?: BoolFieldUpdateOperationsInput | boolean
    domainVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checks?: CheckUncheckedUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutProjectNestedInput
    maintenance?: MaintenanceUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type CheckChannelUpsertWithWhereUniqueWithoutChannelInput = {
    where: CheckChannelWhereUniqueInput
    update: XOR<CheckChannelUpdateWithoutChannelInput, CheckChannelUncheckedUpdateWithoutChannelInput>
    create: XOR<CheckChannelCreateWithoutChannelInput, CheckChannelUncheckedCreateWithoutChannelInput>
  }

  export type CheckChannelUpdateWithWhereUniqueWithoutChannelInput = {
    where: CheckChannelWhereUniqueInput
    data: XOR<CheckChannelUpdateWithoutChannelInput, CheckChannelUncheckedUpdateWithoutChannelInput>
  }

  export type CheckChannelUpdateManyWithWhereWithoutChannelInput = {
    where: CheckChannelScalarWhereInput
    data: XOR<CheckChannelUpdateManyMutationInput, CheckChannelUncheckedUpdateManyWithoutChannelInput>
  }

  export type CheckCreateWithoutCheckChannelsInput = {
    id?: string
    name: string
    slug?: string | null
    scheduleType: $Enums.ScheduleType
    scheduleValue: string
    graceSeconds?: number
    timezone?: string | null
    status?: $Enums.CheckStatus
    lastPingAt?: Date | string | null
    lastStartedAt?: Date | string | null
    nextExpectedAt?: Date | string | null
    lastAlertAt?: Date | string | null
    alertOnRecovery?: boolean
    reminderIntervalHours?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutChecksInput
    pings?: PingCreateNestedManyWithoutCheckInput
    alerts?: AlertCreateNestedManyWithoutCheckInput
    incidentChecks?: IncidentCheckCreateNestedManyWithoutCheckInput
    maintenanceChecks?: MaintenanceCheckCreateNestedManyWithoutCheckInput
    dailyStats?: CheckDailyStatCreateNestedManyWithoutCheckInput
  }

  export type CheckUncheckedCreateWithoutCheckChannelsInput = {
    id?: string
    projectId: string
    name: string
    slug?: string | null
    scheduleType: $Enums.ScheduleType
    scheduleValue: string
    graceSeconds?: number
    timezone?: string | null
    status?: $Enums.CheckStatus
    lastPingAt?: Date | string | null
    lastStartedAt?: Date | string | null
    nextExpectedAt?: Date | string | null
    lastAlertAt?: Date | string | null
    alertOnRecovery?: boolean
    reminderIntervalHours?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pings?: PingUncheckedCreateNestedManyWithoutCheckInput
    alerts?: AlertUncheckedCreateNestedManyWithoutCheckInput
    incidentChecks?: IncidentCheckUncheckedCreateNestedManyWithoutCheckInput
    maintenanceChecks?: MaintenanceCheckUncheckedCreateNestedManyWithoutCheckInput
    dailyStats?: CheckDailyStatUncheckedCreateNestedManyWithoutCheckInput
  }

  export type CheckCreateOrConnectWithoutCheckChannelsInput = {
    where: CheckWhereUniqueInput
    create: XOR<CheckCreateWithoutCheckChannelsInput, CheckUncheckedCreateWithoutCheckChannelsInput>
  }

  export type ChannelCreateWithoutCheckChannelsInput = {
    id?: string
    type: $Enums.ChannelType
    name: string
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutChannelsInput
  }

  export type ChannelUncheckedCreateWithoutCheckChannelsInput = {
    id?: string
    projectId: string
    type: $Enums.ChannelType
    name: string
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelCreateOrConnectWithoutCheckChannelsInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutCheckChannelsInput, ChannelUncheckedCreateWithoutCheckChannelsInput>
  }

  export type CheckUpsertWithoutCheckChannelsInput = {
    update: XOR<CheckUpdateWithoutCheckChannelsInput, CheckUncheckedUpdateWithoutCheckChannelsInput>
    create: XOR<CheckCreateWithoutCheckChannelsInput, CheckUncheckedCreateWithoutCheckChannelsInput>
    where?: CheckWhereInput
  }

  export type CheckUpdateToOneWithWhereWithoutCheckChannelsInput = {
    where?: CheckWhereInput
    data: XOR<CheckUpdateWithoutCheckChannelsInput, CheckUncheckedUpdateWithoutCheckChannelsInput>
  }

  export type CheckUpdateWithoutCheckChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumScheduleTypeFieldUpdateOperationsInput | $Enums.ScheduleType
    scheduleValue?: StringFieldUpdateOperationsInput | string
    graceSeconds?: IntFieldUpdateOperationsInput | number
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCheckStatusFieldUpdateOperationsInput | $Enums.CheckStatus
    lastPingAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExpectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertOnRecovery?: BoolFieldUpdateOperationsInput | boolean
    reminderIntervalHours?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutChecksNestedInput
    pings?: PingUpdateManyWithoutCheckNestedInput
    alerts?: AlertUpdateManyWithoutCheckNestedInput
    incidentChecks?: IncidentCheckUpdateManyWithoutCheckNestedInput
    maintenanceChecks?: MaintenanceCheckUpdateManyWithoutCheckNestedInput
    dailyStats?: CheckDailyStatUpdateManyWithoutCheckNestedInput
  }

  export type CheckUncheckedUpdateWithoutCheckChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumScheduleTypeFieldUpdateOperationsInput | $Enums.ScheduleType
    scheduleValue?: StringFieldUpdateOperationsInput | string
    graceSeconds?: IntFieldUpdateOperationsInput | number
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCheckStatusFieldUpdateOperationsInput | $Enums.CheckStatus
    lastPingAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExpectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertOnRecovery?: BoolFieldUpdateOperationsInput | boolean
    reminderIntervalHours?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pings?: PingUncheckedUpdateManyWithoutCheckNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutCheckNestedInput
    incidentChecks?: IncidentCheckUncheckedUpdateManyWithoutCheckNestedInput
    maintenanceChecks?: MaintenanceCheckUncheckedUpdateManyWithoutCheckNestedInput
    dailyStats?: CheckDailyStatUncheckedUpdateManyWithoutCheckNestedInput
  }

  export type ChannelUpsertWithoutCheckChannelsInput = {
    update: XOR<ChannelUpdateWithoutCheckChannelsInput, ChannelUncheckedUpdateWithoutCheckChannelsInput>
    create: XOR<ChannelCreateWithoutCheckChannelsInput, ChannelUncheckedCreateWithoutCheckChannelsInput>
    where?: ChannelWhereInput
  }

  export type ChannelUpdateToOneWithWhereWithoutCheckChannelsInput = {
    where?: ChannelWhereInput
    data: XOR<ChannelUpdateWithoutCheckChannelsInput, ChannelUncheckedUpdateWithoutCheckChannelsInput>
  }

  export type ChannelUpdateWithoutCheckChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChannelTypeFieldUpdateOperationsInput | $Enums.ChannelType
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutChannelsNestedInput
  }

  export type ChannelUncheckedUpdateWithoutCheckChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    type?: EnumChannelTypeFieldUpdateOperationsInput | $Enums.ChannelType
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckCreateWithoutAlertsInput = {
    id?: string
    name: string
    slug?: string | null
    scheduleType: $Enums.ScheduleType
    scheduleValue: string
    graceSeconds?: number
    timezone?: string | null
    status?: $Enums.CheckStatus
    lastPingAt?: Date | string | null
    lastStartedAt?: Date | string | null
    nextExpectedAt?: Date | string | null
    lastAlertAt?: Date | string | null
    alertOnRecovery?: boolean
    reminderIntervalHours?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutChecksInput
    pings?: PingCreateNestedManyWithoutCheckInput
    checkChannels?: CheckChannelCreateNestedManyWithoutCheckInput
    incidentChecks?: IncidentCheckCreateNestedManyWithoutCheckInput
    maintenanceChecks?: MaintenanceCheckCreateNestedManyWithoutCheckInput
    dailyStats?: CheckDailyStatCreateNestedManyWithoutCheckInput
  }

  export type CheckUncheckedCreateWithoutAlertsInput = {
    id?: string
    projectId: string
    name: string
    slug?: string | null
    scheduleType: $Enums.ScheduleType
    scheduleValue: string
    graceSeconds?: number
    timezone?: string | null
    status?: $Enums.CheckStatus
    lastPingAt?: Date | string | null
    lastStartedAt?: Date | string | null
    nextExpectedAt?: Date | string | null
    lastAlertAt?: Date | string | null
    alertOnRecovery?: boolean
    reminderIntervalHours?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pings?: PingUncheckedCreateNestedManyWithoutCheckInput
    checkChannels?: CheckChannelUncheckedCreateNestedManyWithoutCheckInput
    incidentChecks?: IncidentCheckUncheckedCreateNestedManyWithoutCheckInput
    maintenanceChecks?: MaintenanceCheckUncheckedCreateNestedManyWithoutCheckInput
    dailyStats?: CheckDailyStatUncheckedCreateNestedManyWithoutCheckInput
  }

  export type CheckCreateOrConnectWithoutAlertsInput = {
    where: CheckWhereUniqueInput
    create: XOR<CheckCreateWithoutAlertsInput, CheckUncheckedCreateWithoutAlertsInput>
  }

  export type CheckUpsertWithoutAlertsInput = {
    update: XOR<CheckUpdateWithoutAlertsInput, CheckUncheckedUpdateWithoutAlertsInput>
    create: XOR<CheckCreateWithoutAlertsInput, CheckUncheckedCreateWithoutAlertsInput>
    where?: CheckWhereInput
  }

  export type CheckUpdateToOneWithWhereWithoutAlertsInput = {
    where?: CheckWhereInput
    data: XOR<CheckUpdateWithoutAlertsInput, CheckUncheckedUpdateWithoutAlertsInput>
  }

  export type CheckUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumScheduleTypeFieldUpdateOperationsInput | $Enums.ScheduleType
    scheduleValue?: StringFieldUpdateOperationsInput | string
    graceSeconds?: IntFieldUpdateOperationsInput | number
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCheckStatusFieldUpdateOperationsInput | $Enums.CheckStatus
    lastPingAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExpectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertOnRecovery?: BoolFieldUpdateOperationsInput | boolean
    reminderIntervalHours?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutChecksNestedInput
    pings?: PingUpdateManyWithoutCheckNestedInput
    checkChannels?: CheckChannelUpdateManyWithoutCheckNestedInput
    incidentChecks?: IncidentCheckUpdateManyWithoutCheckNestedInput
    maintenanceChecks?: MaintenanceCheckUpdateManyWithoutCheckNestedInput
    dailyStats?: CheckDailyStatUpdateManyWithoutCheckNestedInput
  }

  export type CheckUncheckedUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumScheduleTypeFieldUpdateOperationsInput | $Enums.ScheduleType
    scheduleValue?: StringFieldUpdateOperationsInput | string
    graceSeconds?: IntFieldUpdateOperationsInput | number
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCheckStatusFieldUpdateOperationsInput | $Enums.CheckStatus
    lastPingAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExpectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertOnRecovery?: BoolFieldUpdateOperationsInput | boolean
    reminderIntervalHours?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pings?: PingUncheckedUpdateManyWithoutCheckNestedInput
    checkChannels?: CheckChannelUncheckedUpdateManyWithoutCheckNestedInput
    incidentChecks?: IncidentCheckUncheckedUpdateManyWithoutCheckNestedInput
    maintenanceChecks?: MaintenanceCheckUncheckedUpdateManyWithoutCheckNestedInput
    dailyStats?: CheckDailyStatUncheckedUpdateManyWithoutCheckNestedInput
  }

  export type ProjectCreateWithoutApiKeysInput = {
    id?: string
    name: string
    slug: string
    timezone?: string
    statusPageEnabled?: boolean
    statusPageTitle?: string | null
    statusPageLogoUrl?: string | null
    customDomain?: string | null
    domainVerified?: boolean
    domainVerifyToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    org: OrganizationCreateNestedOneWithoutProjectsInput
    checks?: CheckCreateNestedManyWithoutProjectInput
    channels?: ChannelCreateNestedManyWithoutProjectInput
    incidents?: IncidentCreateNestedManyWithoutProjectInput
    maintenance?: MaintenanceCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutApiKeysInput = {
    id?: string
    orgId: string
    name: string
    slug: string
    timezone?: string
    statusPageEnabled?: boolean
    statusPageTitle?: string | null
    statusPageLogoUrl?: string | null
    customDomain?: string | null
    domainVerified?: boolean
    domainVerifyToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    checks?: CheckUncheckedCreateNestedManyWithoutProjectInput
    channels?: ChannelUncheckedCreateNestedManyWithoutProjectInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutProjectInput
    maintenance?: MaintenanceUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutApiKeysInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutApiKeysInput, ProjectUncheckedCreateWithoutApiKeysInput>
  }

  export type ProjectUpsertWithoutApiKeysInput = {
    update: XOR<ProjectUpdateWithoutApiKeysInput, ProjectUncheckedUpdateWithoutApiKeysInput>
    create: XOR<ProjectCreateWithoutApiKeysInput, ProjectUncheckedCreateWithoutApiKeysInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutApiKeysInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutApiKeysInput, ProjectUncheckedUpdateWithoutApiKeysInput>
  }

  export type ProjectUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    statusPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    statusPageTitle?: NullableStringFieldUpdateOperationsInput | string | null
    statusPageLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    domainVerified?: BoolFieldUpdateOperationsInput | boolean
    domainVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    checks?: CheckUpdateManyWithoutProjectNestedInput
    channels?: ChannelUpdateManyWithoutProjectNestedInput
    incidents?: IncidentUpdateManyWithoutProjectNestedInput
    maintenance?: MaintenanceUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    statusPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    statusPageTitle?: NullableStringFieldUpdateOperationsInput | string | null
    statusPageLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    domainVerified?: BoolFieldUpdateOperationsInput | boolean
    domainVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checks?: CheckUncheckedUpdateManyWithoutProjectNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutProjectNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutProjectNestedInput
    maintenance?: MaintenanceUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutIncidentsInput = {
    id?: string
    name: string
    slug: string
    timezone?: string
    statusPageEnabled?: boolean
    statusPageTitle?: string | null
    statusPageLogoUrl?: string | null
    customDomain?: string | null
    domainVerified?: boolean
    domainVerifyToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    org: OrganizationCreateNestedOneWithoutProjectsInput
    checks?: CheckCreateNestedManyWithoutProjectInput
    channels?: ChannelCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyCreateNestedManyWithoutProjectInput
    maintenance?: MaintenanceCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutIncidentsInput = {
    id?: string
    orgId: string
    name: string
    slug: string
    timezone?: string
    statusPageEnabled?: boolean
    statusPageTitle?: string | null
    statusPageLogoUrl?: string | null
    customDomain?: string | null
    domainVerified?: boolean
    domainVerifyToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    checks?: CheckUncheckedCreateNestedManyWithoutProjectInput
    channels?: ChannelUncheckedCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    maintenance?: MaintenanceUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutIncidentsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutIncidentsInput, ProjectUncheckedCreateWithoutIncidentsInput>
  }

  export type IncidentUpdateCreateWithoutIncidentInput = {
    id?: string
    status: $Enums.IncidentStatus
    message: string
    createdAt?: Date | string
  }

  export type IncidentUpdateUncheckedCreateWithoutIncidentInput = {
    id?: string
    status: $Enums.IncidentStatus
    message: string
    createdAt?: Date | string
  }

  export type IncidentUpdateCreateOrConnectWithoutIncidentInput = {
    where: IncidentUpdateWhereUniqueInput
    create: XOR<IncidentUpdateCreateWithoutIncidentInput, IncidentUpdateUncheckedCreateWithoutIncidentInput>
  }

  export type IncidentUpdateCreateManyIncidentInputEnvelope = {
    data: IncidentUpdateCreateManyIncidentInput | IncidentUpdateCreateManyIncidentInput[]
    skipDuplicates?: boolean
  }

  export type IncidentCheckCreateWithoutIncidentInput = {
    check: CheckCreateNestedOneWithoutIncidentChecksInput
  }

  export type IncidentCheckUncheckedCreateWithoutIncidentInput = {
    checkId: string
  }

  export type IncidentCheckCreateOrConnectWithoutIncidentInput = {
    where: IncidentCheckWhereUniqueInput
    create: XOR<IncidentCheckCreateWithoutIncidentInput, IncidentCheckUncheckedCreateWithoutIncidentInput>
  }

  export type IncidentCheckCreateManyIncidentInputEnvelope = {
    data: IncidentCheckCreateManyIncidentInput | IncidentCheckCreateManyIncidentInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutIncidentsInput = {
    update: XOR<ProjectUpdateWithoutIncidentsInput, ProjectUncheckedUpdateWithoutIncidentsInput>
    create: XOR<ProjectCreateWithoutIncidentsInput, ProjectUncheckedCreateWithoutIncidentsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutIncidentsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutIncidentsInput, ProjectUncheckedUpdateWithoutIncidentsInput>
  }

  export type ProjectUpdateWithoutIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    statusPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    statusPageTitle?: NullableStringFieldUpdateOperationsInput | string | null
    statusPageLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    domainVerified?: BoolFieldUpdateOperationsInput | boolean
    domainVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    checks?: CheckUpdateManyWithoutProjectNestedInput
    channels?: ChannelUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutProjectNestedInput
    maintenance?: MaintenanceUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    statusPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    statusPageTitle?: NullableStringFieldUpdateOperationsInput | string | null
    statusPageLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    domainVerified?: BoolFieldUpdateOperationsInput | boolean
    domainVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checks?: CheckUncheckedUpdateManyWithoutProjectNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    maintenance?: MaintenanceUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type IncidentUpdateUpsertWithWhereUniqueWithoutIncidentInput = {
    where: IncidentUpdateWhereUniqueInput
    update: XOR<IncidentUpdateUpdateWithoutIncidentInput, IncidentUpdateUncheckedUpdateWithoutIncidentInput>
    create: XOR<IncidentUpdateCreateWithoutIncidentInput, IncidentUpdateUncheckedCreateWithoutIncidentInput>
  }

  export type IncidentUpdateUpdateWithWhereUniqueWithoutIncidentInput = {
    where: IncidentUpdateWhereUniqueInput
    data: XOR<IncidentUpdateUpdateWithoutIncidentInput, IncidentUpdateUncheckedUpdateWithoutIncidentInput>
  }

  export type IncidentUpdateUpdateManyWithWhereWithoutIncidentInput = {
    where: IncidentUpdateScalarWhereInput
    data: XOR<IncidentUpdateUpdateManyMutationInput, IncidentUpdateUncheckedUpdateManyWithoutIncidentInput>
  }

  export type IncidentUpdateScalarWhereInput = {
    AND?: IncidentUpdateScalarWhereInput | IncidentUpdateScalarWhereInput[]
    OR?: IncidentUpdateScalarWhereInput[]
    NOT?: IncidentUpdateScalarWhereInput | IncidentUpdateScalarWhereInput[]
    id?: StringFilter<"IncidentUpdate"> | string
    incidentId?: StringFilter<"IncidentUpdate"> | string
    status?: EnumIncidentStatusFilter<"IncidentUpdate"> | $Enums.IncidentStatus
    message?: StringFilter<"IncidentUpdate"> | string
    createdAt?: DateTimeFilter<"IncidentUpdate"> | Date | string
  }

  export type IncidentCheckUpsertWithWhereUniqueWithoutIncidentInput = {
    where: IncidentCheckWhereUniqueInput
    update: XOR<IncidentCheckUpdateWithoutIncidentInput, IncidentCheckUncheckedUpdateWithoutIncidentInput>
    create: XOR<IncidentCheckCreateWithoutIncidentInput, IncidentCheckUncheckedCreateWithoutIncidentInput>
  }

  export type IncidentCheckUpdateWithWhereUniqueWithoutIncidentInput = {
    where: IncidentCheckWhereUniqueInput
    data: XOR<IncidentCheckUpdateWithoutIncidentInput, IncidentCheckUncheckedUpdateWithoutIncidentInput>
  }

  export type IncidentCheckUpdateManyWithWhereWithoutIncidentInput = {
    where: IncidentCheckScalarWhereInput
    data: XOR<IncidentCheckUpdateManyMutationInput, IncidentCheckUncheckedUpdateManyWithoutIncidentInput>
  }

  export type IncidentCreateWithoutUpdatesInput = {
    id?: string
    title: string
    status?: $Enums.IncidentStatus
    impact?: $Enums.IncidentImpact
    autoCreated?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutIncidentsInput
    checks?: IncidentCheckCreateNestedManyWithoutIncidentInput
  }

  export type IncidentUncheckedCreateWithoutUpdatesInput = {
    id?: string
    projectId: string
    title: string
    status?: $Enums.IncidentStatus
    impact?: $Enums.IncidentImpact
    autoCreated?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    checks?: IncidentCheckUncheckedCreateNestedManyWithoutIncidentInput
  }

  export type IncidentCreateOrConnectWithoutUpdatesInput = {
    where: IncidentWhereUniqueInput
    create: XOR<IncidentCreateWithoutUpdatesInput, IncidentUncheckedCreateWithoutUpdatesInput>
  }

  export type IncidentUpsertWithoutUpdatesInput = {
    update: XOR<IncidentUpdateWithoutUpdatesInput, IncidentUncheckedUpdateWithoutUpdatesInput>
    create: XOR<IncidentCreateWithoutUpdatesInput, IncidentUncheckedCreateWithoutUpdatesInput>
    where?: IncidentWhereInput
  }

  export type IncidentUpdateToOneWithWhereWithoutUpdatesInput = {
    where?: IncidentWhereInput
    data: XOR<IncidentUpdateWithoutUpdatesInput, IncidentUncheckedUpdateWithoutUpdatesInput>
  }

  export type IncidentUpdateWithoutUpdatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    impact?: EnumIncidentImpactFieldUpdateOperationsInput | $Enums.IncidentImpact
    autoCreated?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutIncidentsNestedInput
    checks?: IncidentCheckUpdateManyWithoutIncidentNestedInput
  }

  export type IncidentUncheckedUpdateWithoutUpdatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    impact?: EnumIncidentImpactFieldUpdateOperationsInput | $Enums.IncidentImpact
    autoCreated?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checks?: IncidentCheckUncheckedUpdateManyWithoutIncidentNestedInput
  }

  export type IncidentCreateWithoutChecksInput = {
    id?: string
    title: string
    status?: $Enums.IncidentStatus
    impact?: $Enums.IncidentImpact
    autoCreated?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutIncidentsInput
    updates?: IncidentUpdateCreateNestedManyWithoutIncidentInput
  }

  export type IncidentUncheckedCreateWithoutChecksInput = {
    id?: string
    projectId: string
    title: string
    status?: $Enums.IncidentStatus
    impact?: $Enums.IncidentImpact
    autoCreated?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updates?: IncidentUpdateUncheckedCreateNestedManyWithoutIncidentInput
  }

  export type IncidentCreateOrConnectWithoutChecksInput = {
    where: IncidentWhereUniqueInput
    create: XOR<IncidentCreateWithoutChecksInput, IncidentUncheckedCreateWithoutChecksInput>
  }

  export type CheckCreateWithoutIncidentChecksInput = {
    id?: string
    name: string
    slug?: string | null
    scheduleType: $Enums.ScheduleType
    scheduleValue: string
    graceSeconds?: number
    timezone?: string | null
    status?: $Enums.CheckStatus
    lastPingAt?: Date | string | null
    lastStartedAt?: Date | string | null
    nextExpectedAt?: Date | string | null
    lastAlertAt?: Date | string | null
    alertOnRecovery?: boolean
    reminderIntervalHours?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutChecksInput
    pings?: PingCreateNestedManyWithoutCheckInput
    checkChannels?: CheckChannelCreateNestedManyWithoutCheckInput
    alerts?: AlertCreateNestedManyWithoutCheckInput
    maintenanceChecks?: MaintenanceCheckCreateNestedManyWithoutCheckInput
    dailyStats?: CheckDailyStatCreateNestedManyWithoutCheckInput
  }

  export type CheckUncheckedCreateWithoutIncidentChecksInput = {
    id?: string
    projectId: string
    name: string
    slug?: string | null
    scheduleType: $Enums.ScheduleType
    scheduleValue: string
    graceSeconds?: number
    timezone?: string | null
    status?: $Enums.CheckStatus
    lastPingAt?: Date | string | null
    lastStartedAt?: Date | string | null
    nextExpectedAt?: Date | string | null
    lastAlertAt?: Date | string | null
    alertOnRecovery?: boolean
    reminderIntervalHours?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pings?: PingUncheckedCreateNestedManyWithoutCheckInput
    checkChannels?: CheckChannelUncheckedCreateNestedManyWithoutCheckInput
    alerts?: AlertUncheckedCreateNestedManyWithoutCheckInput
    maintenanceChecks?: MaintenanceCheckUncheckedCreateNestedManyWithoutCheckInput
    dailyStats?: CheckDailyStatUncheckedCreateNestedManyWithoutCheckInput
  }

  export type CheckCreateOrConnectWithoutIncidentChecksInput = {
    where: CheckWhereUniqueInput
    create: XOR<CheckCreateWithoutIncidentChecksInput, CheckUncheckedCreateWithoutIncidentChecksInput>
  }

  export type IncidentUpsertWithoutChecksInput = {
    update: XOR<IncidentUpdateWithoutChecksInput, IncidentUncheckedUpdateWithoutChecksInput>
    create: XOR<IncidentCreateWithoutChecksInput, IncidentUncheckedCreateWithoutChecksInput>
    where?: IncidentWhereInput
  }

  export type IncidentUpdateToOneWithWhereWithoutChecksInput = {
    where?: IncidentWhereInput
    data: XOR<IncidentUpdateWithoutChecksInput, IncidentUncheckedUpdateWithoutChecksInput>
  }

  export type IncidentUpdateWithoutChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    impact?: EnumIncidentImpactFieldUpdateOperationsInput | $Enums.IncidentImpact
    autoCreated?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutIncidentsNestedInput
    updates?: IncidentUpdateUpdateManyWithoutIncidentNestedInput
  }

  export type IncidentUncheckedUpdateWithoutChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    impact?: EnumIncidentImpactFieldUpdateOperationsInput | $Enums.IncidentImpact
    autoCreated?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updates?: IncidentUpdateUncheckedUpdateManyWithoutIncidentNestedInput
  }

  export type CheckUpsertWithoutIncidentChecksInput = {
    update: XOR<CheckUpdateWithoutIncidentChecksInput, CheckUncheckedUpdateWithoutIncidentChecksInput>
    create: XOR<CheckCreateWithoutIncidentChecksInput, CheckUncheckedCreateWithoutIncidentChecksInput>
    where?: CheckWhereInput
  }

  export type CheckUpdateToOneWithWhereWithoutIncidentChecksInput = {
    where?: CheckWhereInput
    data: XOR<CheckUpdateWithoutIncidentChecksInput, CheckUncheckedUpdateWithoutIncidentChecksInput>
  }

  export type CheckUpdateWithoutIncidentChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumScheduleTypeFieldUpdateOperationsInput | $Enums.ScheduleType
    scheduleValue?: StringFieldUpdateOperationsInput | string
    graceSeconds?: IntFieldUpdateOperationsInput | number
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCheckStatusFieldUpdateOperationsInput | $Enums.CheckStatus
    lastPingAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExpectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertOnRecovery?: BoolFieldUpdateOperationsInput | boolean
    reminderIntervalHours?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutChecksNestedInput
    pings?: PingUpdateManyWithoutCheckNestedInput
    checkChannels?: CheckChannelUpdateManyWithoutCheckNestedInput
    alerts?: AlertUpdateManyWithoutCheckNestedInput
    maintenanceChecks?: MaintenanceCheckUpdateManyWithoutCheckNestedInput
    dailyStats?: CheckDailyStatUpdateManyWithoutCheckNestedInput
  }

  export type CheckUncheckedUpdateWithoutIncidentChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumScheduleTypeFieldUpdateOperationsInput | $Enums.ScheduleType
    scheduleValue?: StringFieldUpdateOperationsInput | string
    graceSeconds?: IntFieldUpdateOperationsInput | number
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCheckStatusFieldUpdateOperationsInput | $Enums.CheckStatus
    lastPingAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExpectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertOnRecovery?: BoolFieldUpdateOperationsInput | boolean
    reminderIntervalHours?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pings?: PingUncheckedUpdateManyWithoutCheckNestedInput
    checkChannels?: CheckChannelUncheckedUpdateManyWithoutCheckNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutCheckNestedInput
    maintenanceChecks?: MaintenanceCheckUncheckedUpdateManyWithoutCheckNestedInput
    dailyStats?: CheckDailyStatUncheckedUpdateManyWithoutCheckNestedInput
  }

  export type ProjectCreateWithoutMaintenanceInput = {
    id?: string
    name: string
    slug: string
    timezone?: string
    statusPageEnabled?: boolean
    statusPageTitle?: string | null
    statusPageLogoUrl?: string | null
    customDomain?: string | null
    domainVerified?: boolean
    domainVerifyToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    org: OrganizationCreateNestedOneWithoutProjectsInput
    checks?: CheckCreateNestedManyWithoutProjectInput
    channels?: ChannelCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyCreateNestedManyWithoutProjectInput
    incidents?: IncidentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMaintenanceInput = {
    id?: string
    orgId: string
    name: string
    slug: string
    timezone?: string
    statusPageEnabled?: boolean
    statusPageTitle?: string | null
    statusPageLogoUrl?: string | null
    customDomain?: string | null
    domainVerified?: boolean
    domainVerifyToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    checks?: CheckUncheckedCreateNestedManyWithoutProjectInput
    channels?: ChannelUncheckedCreateNestedManyWithoutProjectInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    incidents?: IncidentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMaintenanceInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMaintenanceInput, ProjectUncheckedCreateWithoutMaintenanceInput>
  }

  export type MaintenanceCheckCreateWithoutMaintenanceInput = {
    check: CheckCreateNestedOneWithoutMaintenanceChecksInput
  }

  export type MaintenanceCheckUncheckedCreateWithoutMaintenanceInput = {
    checkId: string
  }

  export type MaintenanceCheckCreateOrConnectWithoutMaintenanceInput = {
    where: MaintenanceCheckWhereUniqueInput
    create: XOR<MaintenanceCheckCreateWithoutMaintenanceInput, MaintenanceCheckUncheckedCreateWithoutMaintenanceInput>
  }

  export type MaintenanceCheckCreateManyMaintenanceInputEnvelope = {
    data: MaintenanceCheckCreateManyMaintenanceInput | MaintenanceCheckCreateManyMaintenanceInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutMaintenanceInput = {
    update: XOR<ProjectUpdateWithoutMaintenanceInput, ProjectUncheckedUpdateWithoutMaintenanceInput>
    create: XOR<ProjectCreateWithoutMaintenanceInput, ProjectUncheckedCreateWithoutMaintenanceInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMaintenanceInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMaintenanceInput, ProjectUncheckedUpdateWithoutMaintenanceInput>
  }

  export type ProjectUpdateWithoutMaintenanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    statusPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    statusPageTitle?: NullableStringFieldUpdateOperationsInput | string | null
    statusPageLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    domainVerified?: BoolFieldUpdateOperationsInput | boolean
    domainVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    checks?: CheckUpdateManyWithoutProjectNestedInput
    channels?: ChannelUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutProjectNestedInput
    incidents?: IncidentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMaintenanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    statusPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    statusPageTitle?: NullableStringFieldUpdateOperationsInput | string | null
    statusPageLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    domainVerified?: BoolFieldUpdateOperationsInput | boolean
    domainVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checks?: CheckUncheckedUpdateManyWithoutProjectNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type MaintenanceCheckUpsertWithWhereUniqueWithoutMaintenanceInput = {
    where: MaintenanceCheckWhereUniqueInput
    update: XOR<MaintenanceCheckUpdateWithoutMaintenanceInput, MaintenanceCheckUncheckedUpdateWithoutMaintenanceInput>
    create: XOR<MaintenanceCheckCreateWithoutMaintenanceInput, MaintenanceCheckUncheckedCreateWithoutMaintenanceInput>
  }

  export type MaintenanceCheckUpdateWithWhereUniqueWithoutMaintenanceInput = {
    where: MaintenanceCheckWhereUniqueInput
    data: XOR<MaintenanceCheckUpdateWithoutMaintenanceInput, MaintenanceCheckUncheckedUpdateWithoutMaintenanceInput>
  }

  export type MaintenanceCheckUpdateManyWithWhereWithoutMaintenanceInput = {
    where: MaintenanceCheckScalarWhereInput
    data: XOR<MaintenanceCheckUpdateManyMutationInput, MaintenanceCheckUncheckedUpdateManyWithoutMaintenanceInput>
  }

  export type MaintenanceCreateWithoutChecksInput = {
    id?: string
    title: string
    description?: string | null
    startsAt: Date | string
    endsAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMaintenanceInput
  }

  export type MaintenanceUncheckedCreateWithoutChecksInput = {
    id?: string
    projectId: string
    title: string
    description?: string | null
    startsAt: Date | string
    endsAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceCreateOrConnectWithoutChecksInput = {
    where: MaintenanceWhereUniqueInput
    create: XOR<MaintenanceCreateWithoutChecksInput, MaintenanceUncheckedCreateWithoutChecksInput>
  }

  export type CheckCreateWithoutMaintenanceChecksInput = {
    id?: string
    name: string
    slug?: string | null
    scheduleType: $Enums.ScheduleType
    scheduleValue: string
    graceSeconds?: number
    timezone?: string | null
    status?: $Enums.CheckStatus
    lastPingAt?: Date | string | null
    lastStartedAt?: Date | string | null
    nextExpectedAt?: Date | string | null
    lastAlertAt?: Date | string | null
    alertOnRecovery?: boolean
    reminderIntervalHours?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutChecksInput
    pings?: PingCreateNestedManyWithoutCheckInput
    checkChannels?: CheckChannelCreateNestedManyWithoutCheckInput
    alerts?: AlertCreateNestedManyWithoutCheckInput
    incidentChecks?: IncidentCheckCreateNestedManyWithoutCheckInput
    dailyStats?: CheckDailyStatCreateNestedManyWithoutCheckInput
  }

  export type CheckUncheckedCreateWithoutMaintenanceChecksInput = {
    id?: string
    projectId: string
    name: string
    slug?: string | null
    scheduleType: $Enums.ScheduleType
    scheduleValue: string
    graceSeconds?: number
    timezone?: string | null
    status?: $Enums.CheckStatus
    lastPingAt?: Date | string | null
    lastStartedAt?: Date | string | null
    nextExpectedAt?: Date | string | null
    lastAlertAt?: Date | string | null
    alertOnRecovery?: boolean
    reminderIntervalHours?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pings?: PingUncheckedCreateNestedManyWithoutCheckInput
    checkChannels?: CheckChannelUncheckedCreateNestedManyWithoutCheckInput
    alerts?: AlertUncheckedCreateNestedManyWithoutCheckInput
    incidentChecks?: IncidentCheckUncheckedCreateNestedManyWithoutCheckInput
    dailyStats?: CheckDailyStatUncheckedCreateNestedManyWithoutCheckInput
  }

  export type CheckCreateOrConnectWithoutMaintenanceChecksInput = {
    where: CheckWhereUniqueInput
    create: XOR<CheckCreateWithoutMaintenanceChecksInput, CheckUncheckedCreateWithoutMaintenanceChecksInput>
  }

  export type MaintenanceUpsertWithoutChecksInput = {
    update: XOR<MaintenanceUpdateWithoutChecksInput, MaintenanceUncheckedUpdateWithoutChecksInput>
    create: XOR<MaintenanceCreateWithoutChecksInput, MaintenanceUncheckedCreateWithoutChecksInput>
    where?: MaintenanceWhereInput
  }

  export type MaintenanceUpdateToOneWithWhereWithoutChecksInput = {
    where?: MaintenanceWhereInput
    data: XOR<MaintenanceUpdateWithoutChecksInput, MaintenanceUncheckedUpdateWithoutChecksInput>
  }

  export type MaintenanceUpdateWithoutChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMaintenanceNestedInput
  }

  export type MaintenanceUncheckedUpdateWithoutChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckUpsertWithoutMaintenanceChecksInput = {
    update: XOR<CheckUpdateWithoutMaintenanceChecksInput, CheckUncheckedUpdateWithoutMaintenanceChecksInput>
    create: XOR<CheckCreateWithoutMaintenanceChecksInput, CheckUncheckedCreateWithoutMaintenanceChecksInput>
    where?: CheckWhereInput
  }

  export type CheckUpdateToOneWithWhereWithoutMaintenanceChecksInput = {
    where?: CheckWhereInput
    data: XOR<CheckUpdateWithoutMaintenanceChecksInput, CheckUncheckedUpdateWithoutMaintenanceChecksInput>
  }

  export type CheckUpdateWithoutMaintenanceChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumScheduleTypeFieldUpdateOperationsInput | $Enums.ScheduleType
    scheduleValue?: StringFieldUpdateOperationsInput | string
    graceSeconds?: IntFieldUpdateOperationsInput | number
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCheckStatusFieldUpdateOperationsInput | $Enums.CheckStatus
    lastPingAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExpectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertOnRecovery?: BoolFieldUpdateOperationsInput | boolean
    reminderIntervalHours?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutChecksNestedInput
    pings?: PingUpdateManyWithoutCheckNestedInput
    checkChannels?: CheckChannelUpdateManyWithoutCheckNestedInput
    alerts?: AlertUpdateManyWithoutCheckNestedInput
    incidentChecks?: IncidentCheckUpdateManyWithoutCheckNestedInput
    dailyStats?: CheckDailyStatUpdateManyWithoutCheckNestedInput
  }

  export type CheckUncheckedUpdateWithoutMaintenanceChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumScheduleTypeFieldUpdateOperationsInput | $Enums.ScheduleType
    scheduleValue?: StringFieldUpdateOperationsInput | string
    graceSeconds?: IntFieldUpdateOperationsInput | number
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCheckStatusFieldUpdateOperationsInput | $Enums.CheckStatus
    lastPingAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExpectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertOnRecovery?: BoolFieldUpdateOperationsInput | boolean
    reminderIntervalHours?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pings?: PingUncheckedUpdateManyWithoutCheckNestedInput
    checkChannels?: CheckChannelUncheckedUpdateManyWithoutCheckNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutCheckNestedInput
    incidentChecks?: IncidentCheckUncheckedUpdateManyWithoutCheckNestedInput
    dailyStats?: CheckDailyStatUncheckedUpdateManyWithoutCheckNestedInput
  }

  export type SessionCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type AccountCreateManyUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrgMemberCreateManyUserInput = {
    id?: string
    role?: string
    orgId: string
    createdAt?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrgMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    org?: OrganizationUpdateOneRequiredWithoutMembersNestedInput
  }

  export type OrgMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrgMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrgMemberCreateManyOrgInput = {
    id?: string
    role?: string
    userId: string
    createdAt?: Date | string
  }

  export type ProjectCreateManyOrgInput = {
    id?: string
    name: string
    slug: string
    timezone?: string
    statusPageEnabled?: boolean
    statusPageTitle?: string | null
    statusPageLogoUrl?: string | null
    customDomain?: string | null
    domainVerified?: boolean
    domainVerifyToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvitationCreateManyOrgInput = {
    id?: string
    email: string
    role?: string
    token: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type OrgMemberUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type OrgMemberUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrgMemberUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    statusPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    statusPageTitle?: NullableStringFieldUpdateOperationsInput | string | null
    statusPageLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    domainVerified?: BoolFieldUpdateOperationsInput | boolean
    domainVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checks?: CheckUpdateManyWithoutProjectNestedInput
    channels?: ChannelUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutProjectNestedInput
    incidents?: IncidentUpdateManyWithoutProjectNestedInput
    maintenance?: MaintenanceUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    statusPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    statusPageTitle?: NullableStringFieldUpdateOperationsInput | string | null
    statusPageLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    domainVerified?: BoolFieldUpdateOperationsInput | boolean
    domainVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checks?: CheckUncheckedUpdateManyWithoutProjectNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutProjectNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    incidents?: IncidentUncheckedUpdateManyWithoutProjectNestedInput
    maintenance?: MaintenanceUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    statusPageEnabled?: BoolFieldUpdateOperationsInput | boolean
    statusPageTitle?: NullableStringFieldUpdateOperationsInput | string | null
    statusPageLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    domainVerified?: BoolFieldUpdateOperationsInput | boolean
    domainVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckCreateManyProjectInput = {
    id?: string
    name: string
    slug?: string | null
    scheduleType: $Enums.ScheduleType
    scheduleValue: string
    graceSeconds?: number
    timezone?: string | null
    status?: $Enums.CheckStatus
    lastPingAt?: Date | string | null
    lastStartedAt?: Date | string | null
    nextExpectedAt?: Date | string | null
    lastAlertAt?: Date | string | null
    alertOnRecovery?: boolean
    reminderIntervalHours?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelCreateManyProjectInput = {
    id?: string
    type: $Enums.ChannelType
    name: string
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyCreateManyProjectInput = {
    id?: string
    name: string
    keyHash: string
    keyPrefix: string
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type IncidentCreateManyProjectInput = {
    id?: string
    title: string
    status?: $Enums.IncidentStatus
    impact?: $Enums.IncidentImpact
    autoCreated?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceCreateManyProjectInput = {
    id?: string
    title: string
    description?: string | null
    startsAt: Date | string
    endsAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CheckUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumScheduleTypeFieldUpdateOperationsInput | $Enums.ScheduleType
    scheduleValue?: StringFieldUpdateOperationsInput | string
    graceSeconds?: IntFieldUpdateOperationsInput | number
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCheckStatusFieldUpdateOperationsInput | $Enums.CheckStatus
    lastPingAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExpectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertOnRecovery?: BoolFieldUpdateOperationsInput | boolean
    reminderIntervalHours?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pings?: PingUpdateManyWithoutCheckNestedInput
    checkChannels?: CheckChannelUpdateManyWithoutCheckNestedInput
    alerts?: AlertUpdateManyWithoutCheckNestedInput
    incidentChecks?: IncidentCheckUpdateManyWithoutCheckNestedInput
    maintenanceChecks?: MaintenanceCheckUpdateManyWithoutCheckNestedInput
    dailyStats?: CheckDailyStatUpdateManyWithoutCheckNestedInput
  }

  export type CheckUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumScheduleTypeFieldUpdateOperationsInput | $Enums.ScheduleType
    scheduleValue?: StringFieldUpdateOperationsInput | string
    graceSeconds?: IntFieldUpdateOperationsInput | number
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCheckStatusFieldUpdateOperationsInput | $Enums.CheckStatus
    lastPingAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExpectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertOnRecovery?: BoolFieldUpdateOperationsInput | boolean
    reminderIntervalHours?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pings?: PingUncheckedUpdateManyWithoutCheckNestedInput
    checkChannels?: CheckChannelUncheckedUpdateManyWithoutCheckNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutCheckNestedInput
    incidentChecks?: IncidentCheckUncheckedUpdateManyWithoutCheckNestedInput
    maintenanceChecks?: MaintenanceCheckUncheckedUpdateManyWithoutCheckNestedInput
    dailyStats?: CheckDailyStatUncheckedUpdateManyWithoutCheckNestedInput
  }

  export type CheckUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumScheduleTypeFieldUpdateOperationsInput | $Enums.ScheduleType
    scheduleValue?: StringFieldUpdateOperationsInput | string
    graceSeconds?: IntFieldUpdateOperationsInput | number
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCheckStatusFieldUpdateOperationsInput | $Enums.CheckStatus
    lastPingAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextExpectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAlertAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertOnRecovery?: BoolFieldUpdateOperationsInput | boolean
    reminderIntervalHours?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChannelTypeFieldUpdateOperationsInput | $Enums.ChannelType
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkChannels?: CheckChannelUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChannelTypeFieldUpdateOperationsInput | $Enums.ChannelType
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkChannels?: CheckChannelUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChannelTypeFieldUpdateOperationsInput | $Enums.ChannelType
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    impact?: EnumIncidentImpactFieldUpdateOperationsInput | $Enums.IncidentImpact
    autoCreated?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updates?: IncidentUpdateUpdateManyWithoutIncidentNestedInput
    checks?: IncidentCheckUpdateManyWithoutIncidentNestedInput
  }

  export type IncidentUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    impact?: EnumIncidentImpactFieldUpdateOperationsInput | $Enums.IncidentImpact
    autoCreated?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updates?: IncidentUpdateUncheckedUpdateManyWithoutIncidentNestedInput
    checks?: IncidentCheckUncheckedUpdateManyWithoutIncidentNestedInput
  }

  export type IncidentUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    impact?: EnumIncidentImpactFieldUpdateOperationsInput | $Enums.IncidentImpact
    autoCreated?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checks?: MaintenanceCheckUpdateManyWithoutMaintenanceNestedInput
  }

  export type MaintenanceUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checks?: MaintenanceCheckUncheckedUpdateManyWithoutMaintenanceNestedInput
  }

  export type MaintenanceUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PingCreateManyCheckInput = {
    id?: string
    type: $Enums.PingType
    body?: string | null
    sourceIp: string
    createdAt?: Date | string
  }

  export type CheckChannelCreateManyCheckInput = {
    channelId: string
  }

  export type AlertCreateManyCheckInput = {
    id?: string
    event: string
    channels: JsonNullValueInput | InputJsonValue
    success: boolean
    error?: string | null
    createdAt?: Date | string
  }

  export type IncidentCheckCreateManyCheckInput = {
    incidentId: string
  }

  export type MaintenanceCheckCreateManyCheckInput = {
    maintenanceId: string
  }

  export type CheckDailyStatCreateManyCheckInput = {
    id?: string
    date: Date | string
    upMinutes?: number
    downMinutes?: number
    totalPings?: number
    upPercent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PingUpdateWithoutCheckInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPingTypeFieldUpdateOperationsInput | $Enums.PingType
    body?: NullableStringFieldUpdateOperationsInput | string | null
    sourceIp?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PingUncheckedUpdateWithoutCheckInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPingTypeFieldUpdateOperationsInput | $Enums.PingType
    body?: NullableStringFieldUpdateOperationsInput | string | null
    sourceIp?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PingUncheckedUpdateManyWithoutCheckInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPingTypeFieldUpdateOperationsInput | $Enums.PingType
    body?: NullableStringFieldUpdateOperationsInput | string | null
    sourceIp?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckChannelUpdateWithoutCheckInput = {
    channel?: ChannelUpdateOneRequiredWithoutCheckChannelsNestedInput
  }

  export type CheckChannelUncheckedUpdateWithoutCheckInput = {
    channelId?: StringFieldUpdateOperationsInput | string
  }

  export type CheckChannelUncheckedUpdateManyWithoutCheckInput = {
    channelId?: StringFieldUpdateOperationsInput | string
  }

  export type AlertUpdateWithoutCheckInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    channels?: JsonNullValueInput | InputJsonValue
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertUncheckedUpdateWithoutCheckInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    channels?: JsonNullValueInput | InputJsonValue
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertUncheckedUpdateManyWithoutCheckInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    channels?: JsonNullValueInput | InputJsonValue
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentCheckUpdateWithoutCheckInput = {
    incident?: IncidentUpdateOneRequiredWithoutChecksNestedInput
  }

  export type IncidentCheckUncheckedUpdateWithoutCheckInput = {
    incidentId?: StringFieldUpdateOperationsInput | string
  }

  export type IncidentCheckUncheckedUpdateManyWithoutCheckInput = {
    incidentId?: StringFieldUpdateOperationsInput | string
  }

  export type MaintenanceCheckUpdateWithoutCheckInput = {
    maintenance?: MaintenanceUpdateOneRequiredWithoutChecksNestedInput
  }

  export type MaintenanceCheckUncheckedUpdateWithoutCheckInput = {
    maintenanceId?: StringFieldUpdateOperationsInput | string
  }

  export type MaintenanceCheckUncheckedUpdateManyWithoutCheckInput = {
    maintenanceId?: StringFieldUpdateOperationsInput | string
  }

  export type CheckDailyStatUpdateWithoutCheckInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    upMinutes?: IntFieldUpdateOperationsInput | number
    downMinutes?: IntFieldUpdateOperationsInput | number
    totalPings?: IntFieldUpdateOperationsInput | number
    upPercent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckDailyStatUncheckedUpdateWithoutCheckInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    upMinutes?: IntFieldUpdateOperationsInput | number
    downMinutes?: IntFieldUpdateOperationsInput | number
    totalPings?: IntFieldUpdateOperationsInput | number
    upPercent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckDailyStatUncheckedUpdateManyWithoutCheckInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    upMinutes?: IntFieldUpdateOperationsInput | number
    downMinutes?: IntFieldUpdateOperationsInput | number
    totalPings?: IntFieldUpdateOperationsInput | number
    upPercent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckChannelCreateManyChannelInput = {
    checkId: string
  }

  export type CheckChannelUpdateWithoutChannelInput = {
    check?: CheckUpdateOneRequiredWithoutCheckChannelsNestedInput
  }

  export type CheckChannelUncheckedUpdateWithoutChannelInput = {
    checkId?: StringFieldUpdateOperationsInput | string
  }

  export type CheckChannelUncheckedUpdateManyWithoutChannelInput = {
    checkId?: StringFieldUpdateOperationsInput | string
  }

  export type IncidentUpdateCreateManyIncidentInput = {
    id?: string
    status: $Enums.IncidentStatus
    message: string
    createdAt?: Date | string
  }

  export type IncidentCheckCreateManyIncidentInput = {
    checkId: string
  }

  export type IncidentUpdateUpdateWithoutIncidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUpdateUncheckedUpdateWithoutIncidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUpdateUncheckedUpdateManyWithoutIncidentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentCheckUpdateWithoutIncidentInput = {
    check?: CheckUpdateOneRequiredWithoutIncidentChecksNestedInput
  }

  export type IncidentCheckUncheckedUpdateWithoutIncidentInput = {
    checkId?: StringFieldUpdateOperationsInput | string
  }

  export type IncidentCheckUncheckedUpdateManyWithoutIncidentInput = {
    checkId?: StringFieldUpdateOperationsInput | string
  }

  export type MaintenanceCheckCreateManyMaintenanceInput = {
    checkId: string
  }

  export type MaintenanceCheckUpdateWithoutMaintenanceInput = {
    check?: CheckUpdateOneRequiredWithoutMaintenanceChecksNestedInput
  }

  export type MaintenanceCheckUncheckedUpdateWithoutMaintenanceInput = {
    checkId?: StringFieldUpdateOperationsInput | string
  }

  export type MaintenanceCheckUncheckedUpdateManyWithoutMaintenanceInput = {
    checkId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}